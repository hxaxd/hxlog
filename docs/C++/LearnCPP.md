# LearnCPP

## 参考资料

- [LearnCPP](https://learncpp.com.cn/)

## 入门

- 环境配置

## C++ 基础

- UB 未定义行为
    - 使用未初始化的内部类型变量
    - 不返回值的有返回值函数 (`main` 会隐式返回 `0`)
    - 类型, 模板, 内联函数和内联变量在不同文件中重复定义且不相同
    - 表达式求出的值超出其类型的表示范围
- 未指定行为 依赖于实现的行为
- `override` `final` `import` `module` 不是关键字, 但是特定情况具有特殊含义 (特殊标识符)
- 全局变量在 `main` 之前初始化, 所以它们的构造函数先于 `main` 执行

## 初始化

```C++
int a; // 默认初始化

int a = 0; // 复制初始化

int a(0); // 直接初始化

int a{0}; // 列表初始化, 禁止窄化转换
int a = {0}; // 会被优化为列表初始化

int a{}; // 值初始化

[[maybe_unused]] int a{}; // 忽略未使用变量的编译器警告
```

- 默认初始化
    - 基本类型未初始化, 类类型调用默认构造函数
    - 类类型调用默认构造函数
- 复制初始化
    - 基本类型直接赋值
    - 曾经 RVO 不强的情况下, `My_class a = My_class()` 可能产生额外的构造开销
    - 也用于隐式复制值, 如按值将参数传递给函数, 按值从函数返回或按值捕获异常是构造的临时对象
- 直接初始化
    - 调用构造函数
    - `My_class a = static_cast<My_class>(b)` 强制转换就是直接初始化 `myclass a = My_class tmp(b)`
- 列表初始化
    - 基本行为类似直接初始化
- 值初始化
    - 基本类型触发零初始化
    - 类类型调用默认构造函数, 类类型没有默认构造函数则递归触发零初始化, 再调用编译器合成的默认构造函数

## 语句

- 表达式: 操作符和操作数的组合, 除调用 `void` 函数外必有返回值, 可能有副作用
- 基本语句
    - 声明语句
    - 表达式语句: 表达式后跟分号
    - 复合语句
    - 空语句
- 控制流语句
    - 跳转语句
    - 选择语句
    - 迭代语句
- try-catch 语句

## 函数

- 无返回值函数无需在结尾使用 `return`
- 未命名参数
    - 用于向后兼容 `func(int /* 但是你应说明清楚 */);`
    - 用于在运算符重载时区分 `++` 和 `--` 的前置与后置版本
    - 需要模板参数的类型信息做决策, 但不需要参数值

## 生命周期与作用域

- 生命周期是对象的运行时概念, 作用域是标识符的编译时概念
- 在作用域外无法访问对象, 但对象可能依然存在
- 离开作用域等同于生命周期结束, 对象在此之后销毁
- 进入作用域等同于生命周期开始, 对象在此之前创建

## 声明与定义

- 所有定义都是声明, 非定义的声明称为纯声明
- 纯声明包括变量, 函数, 类的前向声明
- 标识符可用性
    - 模板与类的标识符必须有完整定义才能使用
    - 变量与函数的标识符只需有声明即可使用
- 一次定义规则 (ODR - One Definition Rule)
    - 在一个文件内, 给定作用域内的每个函数, 变量, 类型或模板只能有一个定义 (编译器重定义错误)
    - 在一个程序内, 给定作用域内的每个函数或变量只能有一个定义 (链接器重定义错误)
    - 类型, 模板, 内联函数和内联变量允许在不同文件中具有重复定义, 只要每个定义都相同 (未定义行为)

## 宏

- `#define FOO` 会将所有 `FOO` 替换为空, 包括注释和字符串字面值内的 `FOO`
- 但是 `#if defined(FOO)` / `#ifdef` 会检测宏是否定义, 不会展开宏
    - 还有 `# if !defined(FOO)` / `#ifndef`
- 但但是 `#if` 与 `#elif` 中的表达式会展开宏

## 基本类型

- 不完整类型是已声明但尚未定义的类型
- void 类型表示无类型, 是故意的不完整类型, 无法实例化
    - 函数返回类型为 void 表示无返回值
    - 函数参数类型为 void 表示无参数 (已弃用)
    - void 指针可以指向任何类型的数据, 但不能解引用
    - 混用无符号与有符号整数类型会触发整数提升, 导致结果一定为无符号类型\
- `cstdint` 中定义了固定宽度整数类型
    - `int8_t` `int16_t` `int32_t` `int64_t`
    - `uint8_t` `uint16_t` `uint32_t` `uint64_t`
    - 注意 `int8_t` 与 `uint8_t` 可能被定义为 `char` 类型
- `std::size_t` 是某个无符号整数类型, 最好通过 `cstddef` 引入
    - `sizeof` 运算符返回该类型, 但你不需要显式引入
    - 构造一个其对象表示中的字节数超过 `std::size_t` 类型中可表示的最大值的类型是格式错误的
    - 一些编译器将可创建的最大对象限制为 `std::size_t` 类型的最大值的一半
- 无符号整数转换为有符号整数时, 发生模数环绕 (C++ 20)

## 类型限定符: `const` `volatile`

- 对于基本类型, 返回类型上的 `const` 限定符会被忽略
- 对于类类型, 返回类型上的 `const` 限定符会阻碍某些类型的编译器优化
    - 本来就是将亡值, 何必再加个 `const` 呢
- 常量
    - 编译时常量: 字面量 + 初始化器为编译时常量的常量对象
    - 运行时常量: 常量函数参数 + 初始化器不是编译时常量的常量对象
- 常量表达式: 字面量, 常量变量, 运算符和函数调用的非空序列
    - 要求所有组成部分都是编译时可计算的
    - 带有常量表达式参数的 `constexpr` 函数调用
    - 枚举器
    - 类型特性
    - `constexpr lambda` 表达式
    - 非类型模板参数
    - 注意: 没有带有常量表达式初始化器的 `const` 非整型类型
- `constexpr` 常量在编译时求值, 必须使用常量表达式初始化

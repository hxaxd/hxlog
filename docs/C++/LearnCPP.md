# LearnCPP

## 参考资料与入门

- [LearnCPP](https://learncpp.com.cn/)

## 基础规则与运行机制

### 基础行为与生命周期

- UB 未定义行为
    - 使用未初始化的内部类型变量
    - 不返回值的有返回值函数 (`main` 会隐式返回 `0`)
    - 类型, 模板, 内联函数和内联变量在不同文件中重复定义且不相同
    - 表达式求出的值超出其类型的表示范围
    - 悬空指针解引用
    - 悬空视图访问
- 未指定行为
    - 依赖于实现的行为
- 特殊标识符
    - `override` `final` `import` `module` 不是关键字, 但是特定情况具有特殊含义
- 全局变量初始化
    - 在 `main` 之前初始化, 所以它们的构造函数先于 `main` 执行
    - 首先进行静态初始化, 然后进行动态初始化
        - 静态初始化: 零初始化 + 常量初始化
        - 动态初始化: 非常量初始化 (运行时求值)
    - 初始化顺序未指定, 不要依赖于某个全局变量先于另一个初始化
        - 尤其是跨翻译单元的全局变量
- 生命周期与作用域
    - 生命周期是对象的运行时概念, 作用域是标识符的编译时概念
    - 在作用域外无法访问对象, 但对象可能依然存在
    - 离开作用域等同于生命周期结束, 对象在此之后销毁
    - 进入作用域等同于生命周期开始, 对象在此之前创建

### 命名空间与链接

- `::foo` 指定全局命名空间的 `foo`
- 前向声明也需要命名空间限定
- `namespace A = B::C;` 创建命名空间别名
- 在命名空间内部声明的变量也是全局变量, 只是需要命名空间限定符访问
- `using` 语句的作用域仅为当前作用域
- 匿名命名空间用于给所有内部函数加上内部链接
- 内联命名空间用于版本控制
    - 内联命名空间内的标识符可直接通过外部命名空间访问 (但不影响链接属性)

### 存储类说明符: `static` `extern` `thread_local` `mutable`

- 内部链接
    - `static` 变量为静态存储期, 全局变量为内部链接, 局部变量为无链接
        - 常量变量默认为内部链接, 需要 `extern` 才能有外部链接
    - `static` 函数为内部链接, 否则默认为外部链接
    - 我们当然不满足于变量与函数, 匿名命名空间可使其内部的所有标识符均为内部链接
- 外部链接
    - `extern` 全局变量为静态存储期, 外部链接
        - 其前向声明为无初始化器的 `extern` 声明
        - 如果想定义一个未初始化的非 `const` 全局变量, 不要使用 `extern`, 会被误解为前向声明

### 声明、定义与 ODR

- 声明与定义
    - 所有定义都是声明, 非定义的声明称为纯声明
    - 纯声明包括变量, 函数, 类的前向声明
- 标识符可用性
    - 模板与类的标识符必须有完整定义才能使用
    - 变量与函数的标识符只需有声明即可使用
- 一次定义规则 (ODR - One Definition Rule)
    - 在一个文件内, 给定作用域内的每个函数, 变量, 类型或模板只能有一个定义 (编译器重定义错误)
    - 在一个程序内, 给定作用域内的每个函数或变量只能有一个定义 (链接器重定义错误)
    - 类型, 模板, 内联函数和内联变量允许在不同文件中具有重复定义, 只要每个定义都相同 (未定义行为)

### 宏与预处理

- `#define FOO` 会将所有 `FOO` 替换为空, 包括注释和字符串字面值内的 `FOO`
- 但是 `#if defined(FOO)` / `#ifdef` 会检测宏是否定义, 不会展开宏
    - 还有 `# if !defined(FOO)` / `#ifndef`
- 但但是 `#if` 与 `#elif` 中的表达式会展开宏

## 类型系统

### 基本类型

- 不完整类型
    - 是已声明但尚未定义的类型
- void 类型
    - 表示无类型, 是故意的不完整类型, 无法实例化
    - 函数返回类型为 void 表示无返回值
    - 函数参数类型为 void 表示无参数 (已弃用)
    - void 指针可以指向任何类型的数据, 但不能解引用
- 类型转换
    - 混用无符号与有符号整数类型会触发整数提升, 导致结果一定为无符号类型
- 固定宽度整数 (`cstdint`)
    - `int8_t` `int16_t` `int32_t` `int64_t`
    - `uint8_t` `uint16_t` `uint32_t` `uint64_t`
    - 注意 `int8_t` 与 `uint8_t` 可能被定义为 `char` 类型
- 大小与环绕
    - `std::size_t` 是某个无符号整数类型, 最好通过 `<cstddef>` 引入
    - `sizeof` 运算符返回该类型, 但你不需要显式引入
    - 构造一个其对象表示中的字节数超过 `std::size_t` 类型中可表示的最大值的类型是格式错误的
    - 一些编译器将可创建的最大对象限制为 `std::size_t` 类型的最大值的一半 (保证指针减法结果在 `std::ptrdiff_t` 范围内)
    - 无符号整数转换为有符号整数时, 发生模数环绕 (C++ 20)

### 初始化

```C++
int a; // 默认初始化

int a = 0; // 复制初始化

int a(0); // 直接初始化

int a{0}; // 列表初始化, 禁止窄化转换
int a = {0}; // 会被优化为列表初始化

int a{}; // 值初始化

[[maybe_unused]] int a{}; // 忽略未使用变量的编译器警告
```

- 默认初始化
    - 基本类型未初始化, 类类型调用默认构造函数
    - 类类型调用默认构造函数
- 复制初始化
    - 基本类型直接赋值
    - 曾经 RVO 不强的情况下, `My_class a = My_class()` 可能产生额外的构造开销
    - 也用于隐式复制值, 如按值将参数传递给函数, 按值从函数返回或按值捕获异常是构造的临时对象
- 直接初始化
    - 调用构造函数
    - `My_class a = static_cast<My_class>(b)` 强制转换就是直接初始化 `myclass a = My_class tmp(b)`
- 列表初始化
    - 基本行为类似直接初始化
- 值初始化
    - 基本类型触发零初始化
    - 类类型调用默认构造函数, 没有默认构造函数则递归触发零初始化, 再调用编译器合成的默认构造函数

### 类型限定符: `const` 与 `volatile`

- `const`
    - 对于基本类型, 返回类型上的 `const` 限定符会被忽略
    - 对于类类型, 返回类型上的 `const` 限定符会阻碍某些类型的编译器优化
        - 本来就是将亡值, 何必再加个 `const` 呢
- 常量分类
    - 编译时常量: 字面量 + 初始化器为编译时常量的常量对象
    - 运行时常量: 常量函数参数 + 初始化器不是编译时常量的常量对象
- 常量表达式
    - 只能调用 `constexpr` 函数
    - 定义: 字面量, 常量变量, 运算符和函数调用的非空序列
    - 要求所有组成部分都是编译时可计算的
    - 包括: 带有常量表达式参数的 `constexpr` 函数调用, 枚举器, 类型特性, `constexpr lambda` 表达式, 非类型模板参数
    - 注意: 没有带有常量表达式初始化器的 `const` 非整型类型 (同样的 `const` 整型类型可以声明数组大小)
    - 并不是所有常量表达式都是编译时求值, 由编译器决定何时求值
- `constexpr`
    - `constexpr` 常量在编译时求值, 必须使用常量表达式初始化
    - 会隐式具有 `const` 限定符
    - `constexpr` 函数可以在运行时求值, 但如果传入的参数是常量表达式, 则可以在编译时求值
    - 在常量表达式中调用 `constexpr` 函数时, 必须编译时可计算
    - `consteval` 函数必须在编译时求值
    - `constexpr` 只能用 `const` 前向声明
- `constexpr` 函数中使用 `if consteval` 感知编译时与运行时求值
    - 实际上是强制编译时求值与非强制编译时求值 + 运行时求值
    - 强制编译时求值: `if consteval` 为真分支
    - 非强制编译时求值 + 运行时求值: `if consteval` 为假分支

### 隐式类型转换

- 情况
    - 初始化或赋值
    - 返回值类型与实际返回类型不匹配
    - 函数参数类型与实参类型不匹配
    - 具有不同类型操作数的某些二元运算符
    - if 语句的条件表达式类型与布尔类型不匹配
- 转换的类型
    - 限定符转换: 添加或移除 `const` 或 `volatile` 限定符
    - 指针的类型转换
        - 指针间的转换
        - 空指针转换为成员指针 / 将基类的成员指针转换为派生类的成员指针
        - 非抛异常的函数指针转换为函数指针
- 数字提升
    - 整数提升: 小于 `int` 的整数类型提升为 `int` 或 `unsigned int`
    - 浮点数提升: `float` 提升为 `double`
- 数值转换
    - 整数与浮点数间的转换
    - 不同大小整数间的转换
    - 不同大小的浮点数间的转换
    - 将整数, 无作用域枚举, 指针或成员指针转换为布尔值
- 值类别转换
    - 将左值表达式转换为右值表达式
    - 数组退化
    - 将函数转换为函数指针
    - 将值转换为临时对象

### 窄化转换

- 定义
    - 目标类型无法容纳源类型的所有值 (潜在不安全)
    - 场景: 浮点转整型, 浮点精度降低, 整数无法精确表示 (宽转窄 / 符号转换)
- `constexpr` 初始化式豁免
    - 若源值为 `constexpr` 且*精确存储在目标类型中, 不视为窄化转换
    - 允许字面量初始化无需后缀 (`unsigned int u { 5 };` 无需 `5u`)
    - 允许 `constexpr` 变量跨类型初始化
    - 特例: 浮点转整型始终视为窄化, 即使 `constexpr` 且无损 (`int n { 5.0 };` 错误)
    - 特例: `constexpr` 浮点转低精度浮点, 只要在范围内, 精度丢失也不视为窄化

### 强制类型转换

- C 风格强制转换
    - `(new_type)expression` 或 `new_type(expression)`
    - 尝试按顺序执行 `const_cast`, `static_cast`, `static_cast` + `const_cast`, `reinterpret_cast`, `reinterpret_cast` + `const_cast`
    - 不安全, 不推荐使用
- `static_cast<new_type>(expression)`
    - 用于相关类型间的转换 (类层次结构内的上行与下行转换, 数值类型间的转换)
    - 不允许移除 `const` 或 `volatile` 限定符
    - 不允许无关类型间的转换
- `dynamic_cast<new_type>(expression)`
    - 用于类层次结构内的安全下行转换
    - 只能用于有虚函数的类
    - 如果转换失败, 指针类型返回空指针, 引用类型抛出 `std::bad_cast` 异常
- `const_cast<new_type>(expression)`
    - 用于添加或移除 `const` 或 `volatile` 限定符
    - 只能用于指针或引用类型
    - 移除 `const` 后修改对象会导致 UB, 除非对象本来就不是常量
- `reinterpret_cast<new_type>(expression)`
    - 用于无关类型间的转换 (指针与整数间的转换, 不同指针类型间的转换)
    - 不保证转换后指针的对齐要求
    - 通常不可移植, 应谨慎使用

### 类型推导

- `auto`
    - 忽略顶层 `const` 和引用
    - 如果初始化器是数组或函数, 则退化为指针类型
- 使用 `auto` 返回值类型的函数, 仅靠前向声明无法推导返回类型, 导致编译错误
    - 最好别用
    - 或者使用尾置返回类型语法 `auto func(...) -> return_type` (返回类型依赖于参数 / lambda 表达式必用)

### 复合类型

- 分类
    - 函数 + 数组 + 指针 (对象 / 函数)
    - 指向成员的指针 (数据成员 / 成员函数)
    - 引用 (左值引用 / 右值引用)
    - 枚举 (无作用域枚举 / 作用域枚举)
    - 类 (结构体 / 联合体 / 类)

### 引用

- 引用遵循与普通变量相同的范围和持续时间规则
    - 会导致悬空引用
- 非 `const` 左值引用
    - 只绑定到与其被引用类型匹配的对象, 因为类型转换的结果是右值
- `const` 左值引用
    - 可以绑定到右值, 这时会创建一个临时对象, 并延长其生命周期至引用的生命周期结束
    - 类型也可以不匹配, 会进行隐式类型转换, 这时要注意, 引用的并不是原始对象, 其状态不会同步
    - 从函数返回的临时对象不符合生命周期延长的条件
- `constexpr` 左值引用
    - 只能绑定到静态存储期对象, 因为它们的地址是编译时可知的
    - `constexpr` 引用不是默认的 `const` 引用
- 按引用传递还是按值传递
    - 引用传递编译器会考虑指针别名, 导致无法内联优化
    - `sizeof(T) <= 2 * sizeof(void*)` 时按值传递通常更快 (忽略设置开销)

## 模板

- `auto` 函数参数的函数实际上是模板函数, 每个参数都是独立的模板参数

### 函数模板

- 函数模板实例化
    - 编译器在每次调用函数模板时根据实参类型生成对应的函数定义
    - 如果多个调用使用相同的模板参数类型, 则只实例化一次
- `foo<int>(1)` 显式指定模板参数类型
- `foo(1)` 或 `foo<>(1)` 隐式推导模板参数类型
    - 重载情况下, `foo(1)` 优先选择非模板函数
- `auto foo(T a, U b) -> std::common_type_t<T, U>` 使用 `std::common_type_t` 获取通用类型
- 函数模板也可以重载
    - 选最特化的

### 模板参数

- 非类型模板参数
    - 整型, 枚举类型, 对象 + 函数 + 成员函数指针与引用
    - 浮点类型和字面量类类型
    - 空指针
    - 可以使用 `auto`

## 语句与函数

### 语句

- 表达式
    - 操作符和操作数的组合, 除调用 `void` 函数外必有返回值, 可能有副作用
    - 三元运算符 `? :` 的返回类型是第二和第三操作数的共同可转换类型, 并且这两个操作数必须可以转换为同类型, 或者是个 `throw` 表达式
    - 重载的逻辑运算符 (`&&` 和 `||`) 不会短路求值
        - C++ 17 之前连结合性都是错的, 因为函数调用的参数不规定求值顺序
    - `if (!!a != !!b != !!c) // a XOR b XOR c`
- 基本语句
    - 声明语句
    - 表达式语句: 表达式后跟分号
    - 复合语句
    - 空语句
- 控制流语句
    - 跳转语句
    - 选择语句
    - 迭代语句
- try-catch 语句

### 表达式

- 表达式就是值
    - 一个求值为可识别对象或函数的表达式称为左值表达式 (可修改 / 不可修改)
    - 否则称为右值表达式

### Constexpr if 语句

- `if constexpr (condition) { ... } else { ... }`
    - `condition` 必须为常量表达式

### Switch 语句

- [[fallthrough]] 属性 + 空语句用于标记有意的贯穿行为, 避免编译器警告
- 可以在块中声明与定义变量, 作用域为该块, 但是不允许初始化
    - 解决方案: 使用复合语句

### 函数

- 无返回值函数无需在结尾使用 `return`
- 未命名参数
    - 用于向后兼容 `func(int /* 但是你应说明清楚 */);`
    - 用于在运算符重载时区分 `++` 和 `--` 的前置与后置版本
    - 需要模板参数的类型信息做决策, 但不需要参数值
- 编译器会自己决定内联优化, 部分情况下无法内联 (另一个翻译单元的函数)
- 现在的内联指允许在不同翻译单元中具有重复定义, 只要每个定义都相同 (否则未定义行为)
- 内联函数
    - 内联函数的定义必须出现在每个使用它们的翻译单元中
        - 因此内联函数的定义通常放在头文件中
    - 成员函数, `consteval` 函数和 `constexpr` 函数, 从函数模板隐式实例化的函数隐式为内联函数
- 内联变量
    - C++ 17 之前常在头文件中定义一个命名空间, 内部若干 `constexpr` 变量
        - 太多副本
    - 或者索性外部链接 + 前向声明, 但影响 `constexpr` 变量的使用
    - 内联变量的定义必须出现在每个使用它们的翻译单元中
        - 因此内联变量的定义通常放在头文件中
    - 内联变量默认具有外部链接
    - 静态 `constexpr` 数据成员隐式为内联变量
- 默认参数
    - 由编译器在函数调用点插入 (因此函数指针不包含默认参数信息)
    - 不能重复声明 (没错, 重复声明都不行) + 必须使用前给出 -> 只能在函数声明中指定默认参数
    - 调用时参数必须从左到右提供, 导致你不能使用靠前的默认参数而指定靠后的默认参数
        - 尽量把易被指定的默认参数放在前面

### 函数重载

- 区分参数类型与参数数量, 不区分返回类型
    - 忽略别名
    - 忽略值参数上的 `const`
    - 包括 `...` 参数
- 对于成员函数, 还区分 `const`, `volatile` 以及引用限定符
- 重载决议
    - 寻找最佳匹配
        - 精确匹配: 无转换, 左值转右值, 限定符转换, 非引用到引用
        - 数值提升
        - 数值转换: 例如对于 `char`, `double` 先于 `std::string`
        - 用户定义转换
        - 使用 `...` 参数
        - 不可转换
        - 对于多参数函数, 比较每个参数的转换等级, 要求所有参数都不劣于另一个函数的对应参数, 且至少有一个参数优于另一个函数的对应参数, 否则二义性错误
    - 如果多个函数同为最佳匹配, 则重载决议失败 (二义性错误)
    - 如果没有函数可调用, 则重载决议失败 (无匹配错误)
- 对于不想要的重载, 可以删除它们: `void func(int) = delete;`
    - 使用模板 `func(T) = delete;` 删除所有其他类型的重载

## 程序控制

- `std::abort()` 立即终止程序, 不进行清理
- `std::atexit(clean())` 注册程序终止时调用的清理函数
- `std::exit()` 终止程序, 调用已注册的清理函数 (最后注册的首先调用), 不调用局部对象的析构函数
- `std::quick_exit()` 与 `std::at_quick_exit()` 终止程序, 不清理静态对象
- `std::terminate()` 调用终止处理程序, 默认调用 `std::abort()`

### 断言

- `assert(condition)` 在调试模式下检查 `condition`, 失败时打印错误信息并调用 `std::abort()`
- `static_assert(condition, "message")` 在编译时检查 `condition`, 失败时打印 `message`

## 标准库

### 字符串

- `std::ssize()` 返回有符号整数类型, 用于表示容器大小
- 字面量后缀
    - `using namespace std::string_literals`, 导入 `std::string` 的字面量 (适用于类型推导)
    - `"hello"s` 是 `std::string` 类型, 注意这是创建了一个新的临时字符串对象
    - `"hello"sv` 是 `std::string_view` 类型
- `std::string_view`
    - 是不可变字符串视图, 不拥有字符串数据, 支持 `constexpr`
    - 适用于传递只读字符串参数, 避免不必要的字符串拷贝
    - 不会隐式转换为 `std::string`, 但可以显式转换
    - 相较于 `const std::string&`, 可以接受字符串字面量和 C 风格字符串而不需创建临时 `std::string` 对象, 并且不会延长临时对象的生命周期
    - 不要使用 `std::string` 字面量初始化 `std::string_view` 对象, 会创建临时 `std::string` 对象, 并立刻销毁, 导致悬空视图
    - 修改原有字符串会导致视图悬空
    - `std::string_view` 不一定以空字符结尾

```C++
std::string_view func(std::string_view sv) {
    sv.remove_prefix(1); // 删除第一个字符
    sv.remove_suffix(1); // 删除最后一个字符
    return sv;
}

std::string_view sv {func("hello"s)}; // 错误: 悬空视图

std::string s {func("hello"s)}; // 正确
```

### `std::bitset`

```C++
std::bitset<8> bits {}; // 8 位, 全部初始化为 0

bits.set(3); // 将第 3 位设置为 1
bits.reset(3); // 将第 3 位设置为 0
bits.flip(2); // 翻转第 2 位
bits.test(1); // 测试第 1 位是否为 1, 返回 bool
bits.count(); // 返回为 1 的位数
bits.size(); // 返回位数
bits.to_string(); // 返回字符串表示

constexpr std::uint8_t mask0{ 0b0000'0001 }; // 位掩码
```

### 随机数

- `std::random_device` 用于生成非确定性随机数种子
- `std::chrono::steady_clock` 亦可
- `std::mt19937` Mersenne Twister 算法, 速度快, 周期长, 适合大多数用途
- `std::uniform_int_distribution` 均匀整数分布

```C++
// 使用 steady_clock 为 Mersenne Twister 生成种子
std::mt19937 mt{ static_cast<std::mt19937::result_type>(
    std::chrono::steady_clock::now().time_since_epoch().count()
    // std::random_device{}() // 也可以使用随机设备, 但有些实现并非非确定性
    ) };

// 创建可复用的随机数分布, 生成 1 到 6 之间的均匀整数
std::uniform_int_distribution<int> die6{ 1, 6 }; // C++14 可写为 std::uniform_int_distribution<> die6{ 1, 6 };

// 打印一堆随机数
for (int count{ 1 }; count <= 40; ++count)
{
    std::cout << die6(mt) << '\t'; // 生成一次掷骰子结果

    // 每打印 10 个数字换行
    if (count % 10 == 0)
        std::cout << '\n';
}
```

- 考虑 `std::seed_seq` 用于生成更高质量的随机数序列

```C++
std::random_device rd{};
std::seed_seq ss{ rd(), rd(), rd(), rd(), rd(), rd(), rd(), rd() }; // 使用多个随机设备值初始化种子序列

std::mt19937 mt{ ss }; // 使用种子序列初始化 Mersenne Twister

std::uniform_int_distribution die6{ 1, 6 };

for (int count{ 1 }; count <= 40; ++count)
{
 std::cout << die6(mt) << '\t';
 if (count % 10 == 0)
  std::cout << '\n';
}
```

# 算法

## 参考资料

- 算法 (第四版) - 好书, 非常多插图, 可惜有点太 Java - 4

## 基础

- 讲了一下 Java 与面向对象
- 讲了一下线性表, 数组, 链表, 栈, 队列
- 斯特林公式 - 用于估计阶乘的近似值
    - $n! \approx \sqrt{2\pi n} \left(\frac{n}{e}\right)^n$
    - $lg(n)! \approx nlg(n) - n + \frac{1}{2}lg(2\pi n)$
- 为了解决对输入的依赖
    - 针对可能的最坏情况 -> 引入随机化 (快速排序)
    - 针对可能的高代价操作情况 -> 考虑代价均摊 (vector 倍增大小)

## 排序

### 简单排序

- 选择排序 $O(n)$ 的交换次数
- 插入排序找插入位置时顺手移位, 很快
- 希尔排序在大尺度下相对有序数组上显然快
    - 即使无该特征, 希尔排序也乐于制造该特征去优化接下来的子插入排序
    - 这使其时间负杂度稳定性极强

### 归并排序

- 略, 这本书有很多算法分析, 都略

### 快速排序

- 注意原地切分 + 边界条件 + 与切分相等时的处理
- 改进
    - 小数组时, 切换到插入排序
    - 三取样切分, 取子数组的首中尾三个元素, 取其中位数作为切分元素
    - 将切分值放在数组末尾, 作为哨兵, 避免对越界的判断
    - 对于有大量重复元素的数组
        - Dijkstra 想出三向切分, 切分元素为 v, 数组被切分为三部分, 小于 v, 等于 v, 大于 v
        - 但他的实现有点问题, 对于普通情况, 交换次数会多一些, 然后就被优化为将等于 v 的元素都交换到数组两侧, 最后归位
        - 三向切分在重复元素较多时, 可以将排序时间从 $O(nlg(n))$ 减少到 $O(n)$ (通过对输入的信息预设突破了理论下限)
        - 将输入的主键频率量化为信息熵, 可以求得该优化的理论时间复杂度

### 优先队列

- 用多叉堆平衡高度与常数
- 堆排序缓存命中率低
- 堆排序常用先沉后浮
    - 一方面下沉优于上浮
    - 另一方面下沉时, 隐式将较大的子节点上浮

## 查询

### 符号表

- 抽象了键值对的操作

### 二叉查找树

- 略

### 平衡查找树

- 2-3 查找树, 有一点容错, 表现优秀一点
- 红黑树, 换个方式的容错, 表现更好, 除 `put` 外不引入复杂机制

### 散列表

- hashCode 函数中可以直接缓存部分 K-V

## 图

### 无向图

- Floyd-Warshall 算法, 可用于求图可达性

### 有向图

- 求有向图的强连通分量
    - Kosaraju 算法
        - 深度优先搜索查找给定有向图的所有顶点
        - 根据由此得到的所有顶点的逆序, 再次用深度优先搜索处理有向图的转置图
        - 每次深度优先搜索遍历到的所有顶点, 就是一个强连通分量
    - Tarjan 算法
        - 深度优先搜索遍历图
        - 维护一个栈, 记录遍历的顶点
        - 对于每个顶点, 记录其发现时间, 可到达的最小发现时间
        - 当发现一个未访问的顶点时, 递归访问它的邻接, 更新低链接值
        - 当回溯到一个顶点时, 如果该顶点的低链接值等于发现时间, 则弹出栈中所有的顶点, 该顶点就是一个强连通分量的根
- 先求强连通分量, 将每个强连通分量看作一个顶点, 再用 Floyd-Warshall 算法求可达性

### 最小生成树

- 在一幅加权图中, 给定任意的切分, 它的横切边中的权重最小者必然属于图的最小生成树
- 经典算法无法应用于有向图, 那是另一个叫最小树形图的问题
- 针对 $V$ 个顶点 $E$ 条边, 最坏情况下的增长数量级:

| 算 法 | 空 间 | 时 间 |
| --- | --- | --- |
| 延时的 Prim 算法 | $O(E)$ | $O(ElogE)$ |
| 即时的 Prim 算法 | $O(V)$ | $O(ElogV)$ |
| Kruskal | $O(E)$ | $O(ElogE)$ |
| Fredman-Tarjan | $O(V)$ | $O(E+VlogV)$ |
| Chazelle | $O(V)$ | 非常接近但还没有达到 $O(E)$ |
| 理想情况 | $O(V)$ | $O(E)$? |

#### 延时的 Prim 算法

- 从任意节点开始
- 扫描该节点的所有邻接边加入优先队列
- 循环弹出权重最小的边 $(u, v)$
    - 如果 $u$ 和 $v$ 都已经被标记为 visited 说明这条边失效了
    - 如果 $v$ 没访问过则将 $v$ 加入 MST, 标记 $v$ 为 visited, 并将 $v$ 的所有邻接边加入优先队列

#### 即时的 Prim 算法

- 对延时 Prim 算法必须遍历边的改进
- 与其在队列里存边, 不如存节点, 我们只关心从当前生成树到某个非树节点 $v$ 的最短距离
- 一个索引优先队列不仅能排序, 还支持 `decrease-key` 操作, 维护当前到某点的最小权重
- PQ 中存储节点索引, Key 是当前到该节点的最小权重
    - 循环弹出 PQ 中权重最小的节点 $v$
    - 松弛操作遍历 $v$ 的邻居 $w$
        - 如果 $w$ 不在 MST 中, 且边 $(v, w)$ 的权重 < `distTo[w]`, 则更新 `distTo[w]`, 并更新 PQ 中 $w$ 的优先级)(`decrease-key`)

#### Kruskal 算法

- 永远先选全图中权重最小的边, 只要这条边不和已选的边构成环, 就要它
- 将所有 $E$ 条边按权重从小到大排序
- 遍历排序后的边 $(u, v)$, 用并查集查询 $u$ 和 $v$ 是否在同一个集合
    - 如果是跳过
    - 如果否将这条边加入 MST, 并将 $u$ 和 $v$ 所在的集合合并

#### Fredman-Tarjan 算法

- 其实就是 Eager Prim 算法的加强版, 用上了斐波那契堆
- 斐波那契堆 `decrease-key` 操作的摊还时间复杂度是 $O(1)$, 而不是 $\log V$
    - 但是 `extract-min`仍然是 $O(\log V)$

#### 其他

- Chazelle 算法使用了 Soft Heap 数据结构
    - 软堆允许在返回值上犯错, 即它可能会人为地提高某些键的值
    - Chazelle 设计了一个非常精妙的算法, 即使堆里的数据是不完全准确的, 也能通过特定的修补逻辑保证最终找出的 MST 是完全正确的
    - 时间 $O(E \cdot \alpha(E, V))$, $\alpha$ 是阿克曼函数的反函数, 这个函数增长极慢, 对于宇宙中所有实际规模的数据, $\alpha < 5$
- 随机化算法
    - 其期望时间复杂度确实是 $O(V+E)$, 通过随机采样部分边来剔除那些肯定不在 MST 中的重边, 从而达到线性速度
- 目前最接近的确定性算法是 Pettie 和 Ramachandran 提出的基于最优决策树的算法
    - 它的复杂度被证明是最优的, 但这个最优的具体表达式极其复杂, 目前尚无法证明它是否严格等于 $O(E)$

### 最短路径

- 边的松弛操作
    - 对于边 $(u, v)$ 权重为 $w$, 如果 $distTo[v] > distTo[u] + w$, 则更新 $distTo[v] = distTo[u] + w$
    - 就是尝试用改变修正最短路
- 点的松弛操作
    - 对于点的所有邻接边尝试松弛操作
- 最短路径的通用算法为对所有边对进行松弛操作 (不计顺序)

#### Dijkstra 算法

- 从源点开始, 对所有邻接点进行松弛操作 (这个顺序保证只松弛附近的)
- 无法解决负权重边的问题
- 算法太开放, 优化方案很多, 针对不同特点图有不同的优化

#### 无环图的优化

- 按拓扑排序进行松弛操作 (这个顺序保证只松弛接下来的)

#### Bellman-Ford 算法

- 对所有边进行松弛操作 (即使不邻接, DP 思想)
- 可以解决负权重边的问题, 但不能解决负权重环

## 字符串

### 字符串排序

#### 键索引计数法

- 
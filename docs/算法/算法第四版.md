# 算法

## 参考资料

- 算法 (第四版) - 好书, 非常多插图, 可惜有点太 Java - 4

## 基础

- 讲了一下 Java 与面向对象
- 讲了一下线性表, 数组, 链表, 栈, 队列
- 斯特林公式 - 用于估计阶乘的近似值
    - $n! \approx \sqrt{2\pi n} \left(\frac{n}{e}\right)^n$
    - $lg(n)! \approx nlg(n) - n + \frac{1}{2}lg(2\pi n)$
- 为了解决对输入的依赖
    - 针对可能的最坏情况 -> 引入随机化 (快速排序)
    - 针对可能的高代价操作情况 -> 考虑代价均摊 (vector 倍增大小)

## 排序

### 简单排序

- 选择排序 $O(n)$ 的交换次数
- 插入排序找插入位置时顺手移位, 很快
- 希尔排序在大尺度下相对有序数组上显然快
    - 即使无该特征, 希尔排序也乐于制造该特征去优化接下来的子插入排序
    - 这使其时间负杂度稳定性极强

### 归并排序

- 略, 这本书有很多算法分析, 都略

### 快速排序

- 注意原地切分 + 边界条件 + 与切分相等时的处理
- 改进
    - 小数组时, 切换到插入排序
    - 三取样切分, 取子数组的首中尾三个元素, 取其中位数作为切分元素
    - 将切分值放在数组末尾, 作为哨兵, 避免对越界的判断
    - 对于有大量重复元素的数组
        - Dijkstra 想出三向切分, 切分元素为 v, 数组被切分为三部分, 小于 v, 等于 v, 大于 v
        - 但他的实现有点问题, 对于普通情况, 交换次数会多一些, 然后就被优化为将等于 v 的元素都交换到数组两侧, 最后归位
        - 三向切分在重复元素较多时, 可以将排序时间从 $O(nlg(n))$ 减少到 $O(n)$ (通过对输入的信息预设突破了理论下限)
        - 将输入的主键频率量化为信息熵, 可以求得该优化的理论时间复杂度

### 优先队列

- 用多叉堆平衡高度与常数
- 堆排序缓存命中率低
- 堆排序常用先沉后浮
    - 一方面下沉优于上浮
    - 另一方面下沉时, 隐式将较大的子节点上浮

## 查询

### 符号表

- 抽象了键值对的操作

### 二叉查找树

- 略

### 平衡查找树

- 2-3 查找树, 有一点容错, 表现优秀一点
- 红黑树, 换个方式的容错, 表现更好, 除 `put` 外不引入复杂机制

### 散列表

- hashCode 函数中可以直接缓存部分 K-V

## 图

### 无向图

- Floyd-Warshall 算法, 可用于求图可达性

### 有向图

- 求有向图的强连通分量
    - Kosaraju 算法
        - 深度优先搜索查找给定有向图的所有顶点
        - 根据由此得到的所有顶点的逆序, 再次用深度优先搜索处理有向图的转置图
        - 每次深度优先搜索遍历到的所有顶点, 就是一个强连通分量
    - Tarjan 算法
        - 深度优先搜索遍历图
        - 维护一个栈, 记录遍历的顶点
        - 对于每个顶点, 记录其发现时间, 可到达的最小发现时间
        - 当发现一个未访问的顶点时, 递归访问它的邻接, 更新低链接值
        - 当回溯到一个顶点时, 如果该顶点的低链接值等于发现时间, 则弹出栈中所有的顶点, 该顶点就是一个强连通分量的根
- 先求强连通分量, 将每个强连通分量看作一个顶点, 再用 Floyd-Warshall 算法求可达性

### 最小生成树

- 在一幅加权图中, 给定任意的切分, 它的横切边中的权重最小者必然属于图的最小生成树
- 经典算法无法应用于有向图, 那是另一个叫最小树形图的问题

- 针对 $V$ 个顶点 $E$ 条边, 最坏情况下的增长数量级:

| 算 法 | 空 间 | 时 间 |
| --- | --- | --- |
| 延时的 Prim 算法 | $O(E)$ | $O(ElogE)$ |
| 即时的 Prim 算法 | $O(V)$ | $O(ElogV)$ |
| Kruskal | $O(E)$ | $O(ElogE)$ |
| Fredman-Tarjan | $O(V)$ | $O(E+VlogV)$ |
| Chazelle | $O(V)$ | 非常接近但还没有达到 $O(E)$ |
| 理想情况 | $O(V)$ | $O(E)$? |

### 最短路径
# 剑指 Offer

## 参考资料

- 剑指 Offer

## 面试的流程

略

## 面试需要的基础知识

### 面试题 1: 赋值运算符函数

- 返回类型为该类型的引用, 并返回 `*this`
- 传入参数为 `const T&`
- 先判断是否是自赋值, 如果是则直接返回 `*this`
- 否则先释放原有的内存, 再分配新的内存, 最后复制数据

```C++
// 这本书的标准答案
class T {
public:
    T& operator=(const T& other) {
        if(this != &other) {
            // 调用拷贝构造函数
            T temp(other); // 如果在这里失败, 则不会执行下面的代码
                           // 保证异常安全

            // 交换数据
            int* tempData = temp.data;
            temp.data = data;
            data = tempData;
        }
        return *this;
        // temp 是一个临时对象, 会在函数结束时自动析构
    }
private:
    int* data;
    int size;
};
```

### 面试题 2: 实现 Singleton 模式

- 需求: 全局唯一实例, 懒加载, 线程安全, 禁止拷贝
- 错误的实现
    - 将构造函数设为私有, 提供一个用于获取实例的静态方法, 一个静态指针指向唯一实例
        - 只适用单线程环境, 通过判断指针是否为空来判断是否需要创建实例, 可能会出现线程安全问题
    - 加一把同步锁, 可以但是效率低, 因为后续实例化的尝试也需要加锁才能判断是否需要创建实例
- 勉强的实现
    - 加锁,前后判断指针是否为空
- 最佳实现
    - 静态方法的静态局部变量 (进程生命周期)
    - C++ 11 保证静态局部变量的初始化是线程安全的, 且只会执行一次
    - 会自动调用析构函数, 不会内存泄漏

```cpp
#include <iostream>

class Singleton {
public:
    // 获取单例引用的静态方法
    static Singleton& getInstance() {
        // C++11 保证: 静态局部变量的初始化是线程安全的
        // 且只会执行一次
        static Singleton instance; 
        return instance;
    }

    // 禁止拷贝构造
    Singleton(const Singleton&) = delete;
    // 禁止赋值操作
    Singleton& operator=(const Singleton&) = delete;

    // 示例业务方法
    void doSomething() {
        std::cout << "Singleton is doing something." << std::endl;
    }

private:
    // 私有化构造函数
    Singleton() {
        std::cout << "Singleton Construct" << std::endl;
    }
    
    // 私有化析构函数 (可选, 根据需求)
    ~Singleton() {
        std::cout << "Singleton Destruct" << std::endl;
    }
};

int main() {
    // 调用时才会初始化
    Singleton::getInstance().doSomething();
    return 0;
}
```

### 面试题 3: 二维数组中的查找

在一个二维数组中, 每一行都按照从左到右递增的顺序排序, 一列都按照从上到下递增的顺序排序, 请完成一个函数, 输入这样的一个二维数组和一个整数, 判断数组中是否含有该整数

- 一看都想二分, 一次排除的倒是很多, 状态转移不好做
- 从二维数组的右上角开始查找
    - 如果当前元素等于目标值, 则返回 `true`
    - 如果当前元素大于目标值, 则说明目标值在当前元素的左边, 列索引减一
    - 如果当前元素小于目标值, 则说明目标值在当前元素的下边, 行索引加一
- 这样稳定将数组分成两部分

### 面试题 4: 替换空格

将字符串中的空格替换为 `%20`

- 非常简单, 先保证空间足够, 从后往前替换, 不会覆盖未处理的字符

### 面试题 5: 从尾到头打印链表

- 非常简单, 递归打印即可
- 也可以用栈来实现, 先入后出

### 面试题 6: 重建二叉树

根据前序遍历和中序遍历重建二叉树

- 根据前序遍历确定根节点
- 根据中序遍历将数组分成左右两部分
- 递归重建左子树和右子树

### 面试题 7: 用两个栈实现队列

- 一个栈用于入队, 一个栈用于出队
- 入队时直接入栈
- 出队时, 如果出队栈为空, 则将入队栈中的元素全部弹出并压入出队栈, 然后出队栈弹出栈顶元素

### 面试题 8: 旋转数组的最小数字

把一个数组最开始的若干个元素搬到数组的末尾, 我们称之为数组的旋转, 输入一个递增排序的数组的一个旋转, 输出旋转数组的最小元素

- 二分查找
    - 如果中间元素大于等于左边界, 则说明中间元素在左半部分, 最小元素在右半部分, 左边界移动到中间元素
    - 如果中间元素小于等于右边界, 则说明中间元素在右半部分, 最小元素在左半部分, 右边界移动到中间元素
    - 当左边界和右边界相邻时, 右边界就是最小值
- 完备一下
    - 考虑数组完全有序的情况, 先比较左边界和右边界, 如果左边界小于右边界, 则数组完全有序, 直接返回左边界
    - 考虑左边界和右边界和中间元素都相等的情况, 无法判断, 只能顺序查找 (本质是不能判断旋转左倾还是右倾)

### 面试题 9: 斐波那契数列

- 非常简单, 递归即可退出面试
- 可以用动态规划优化
- 正解矩阵快速幂

### 面试题 10: 二进制中 1 的个数

求汉明重量

- 错误的解法
    - 循环右移 (移 `n`) 检验最后一位是否为 $1$, 负数的右移会补 $1$, 会导致死循环
    - 循环左移 (移 `flag`) 检验最后一位是否为 $1$, 可以, 但是效率低
- 位运算
    - 每次将 $n$ 与 $n-1$ 做按位与操作, 会将 $n$ 的二进制表示中的最低位的 $1$ 变成 $0$
    - 重复操作直到 $n$ 变成 $0$
    - 操作次数就是 $1$ 的个数

## 高质量的代码

### 面试题 11: 数值的整数次方

实现 `double pow(x, n)` 函数, 计算 $x$ 的 $n$ 次方

- 非常简单, 循环即可退出面试
- 要考虑 $n$ 为负数的情况, 可以先将 $n$ 取相反数, 最后返回 `1 / res` (校验 `res < 0.0000001lf`)
- 再加一个快速幂的优化

### 面试题 12: 打印 1 到最大的 n 位数

输入数字 $n$, 按顺序打印出从 $1$ 到最大的 $n$ 位十进制数, 比如输入 $3$, 则打印出 $1$, $2$, $3$ 一直到最大的 $3$ 位数 $999$

- 非常简单, 开始打印, 退出面试即可
- 用字符串模拟
    - 模拟加一, $n+1$ 位不是 $0$ 时, 说明已经打印完了 $n$ 位的所有数
    - 打印时忽略前导 $0$
- $n$ 位全排列

### 面试题 13: 在 $O(1)$ 时间删除链表节点

- 非常简单, 用下一个节点的值覆盖当前节点, 然后删除下一个节点即可
- 要注意的是, 要删除的节点是否是尾节点或只有一个节点

### 面试题 14: 调整数组顺序使奇数位于偶数前面

- 非常简单, 用双指针, 一个指向头, 一个指向尾, 头指针遇到偶数, 尾指针遇到奇数, 就交换
- 拓展性
    - 可以将判断奇偶的条件抽象出来, 注入可调用对象

### 面试题 15: 链表中倒数第 k 个节点

- 非常简单, 用两个指针, 一个先走 $k-1$ 步, 然后两个指针一起走, 当快指针到达尾节点时, 慢指针就是倒数第 $k$ 个节点
- 要注意的是, 判断 $k$ 的语义是否正确
    - 正数
    - 小于等于链表长度

### 面试题 16: 反转链表

- 非常简单, 用三个指针, 一个指向前驱, 一个指向当前节点, 一个指向后继, 然后依次反转即可

### 面试题 17: 合并两个排序的链表

- 非常简单, 用两个指针, 一个指向头, 一个指向当前节点, 然后依次比较, 小的就接入当前节点, 然后指针后移

### 面试题 18: 树的子结构

- 先找相同的根节点, 然后递归判断左右子树是否相同

## 解决面试题的思路

### 面试题 19: 二叉树的镜像

- 非常简单, 递归交换左右子树即可

### 面试题 20: 顺时针打印矩阵

- 非常简单, 模拟

### 面试题 21: 包含 min 函数的栈

- 最小栈

### 面试题 22: 栈的压入, 弹出序列

- 模拟, 用一个栈模拟压入, 然后判断弹出序列是否正确
    - 弹出序列的每个元素, 都要和栈顶元素比较, 如果相等, 就弹出栈顶元素, 否则, 就继续压入栈

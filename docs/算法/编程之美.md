# 编程之美

## 参考

- 编程之美

## 游戏之乐

### 让 CPU 占用率曲线听你指挥

- 在任务管理器的一个刷新周期内, CPU 忙的时间和刷新周期总时间的比率, 就是 CPU 的占用率
- 解法 1
    - 拼接死循环与休眠
    - 提高切换频率使占用率平滑 ( $10ms$ , 不要太小, 会导致线程切换频率过快, 调度不稳定)
    - 估算 $10ms$ 对应的循环次数 (按照想要的占用率来估算)
    - 痛点: 每次都要重新估算
- 解法 2
    - 使用 `GetTickCount` 让循环进行目标时间
    - 休眠对应比例的时间
    - 痛点: 都假设其它进程不影响 CPU 占用率
- 解法 3
    - 通过 Perfmon.exe 监控 CPU 占用率
    - 小于目标占用率时, 死循环, 否则休眠对应比例的时间
    - 这样再套一个浮点数组, 就可以实现用 CPU 占用率画画了
- 优化
    - 多核情况下, 每个核心都运行一个线程, 每个线程都按照目标占用率来运行 (用 `SetThreadAffinityMask` 来设置线程运行在哪个核心上)
    - RDTSC 指令 (一个汇编, x64 才有库函数) 用于读取 CPU 运行周期, 再用 `CallNtPowerInformation` 获取 CPU 频率以计算时间 (更准)

### 中国象棋将帅问题

枚举所有可能将帅位置, 只可以用一个变量

- 用一个变量高低位 + 位运算表示
- 用结构体表示
- 用商与余表示

### 一摞烙饼的排序

通过翻转 $1$ 到 $m$ 个烙饼, 将 $n$ 个烙饼排序

- 比尔盖茨唯一一篇学术论文的主题
- 先用一下选择排序的思想, 最多 $2(n-1)$ 次翻转一定能排好 (每两次排好最下面)
- 思考一下, 本质就是将应该相邻的烙饼放到一起
- 分支限界法处理一下, 当前次数 + 预计最少次数应小于 $2(n-1)$
    - 有 $m$ 对相邻的烙饼它们的半径不相邻, 那么我们至少需要 $m$ 次才能排好序
- 也可以考虑记忆化搜索

### 买书问题

五卷书, 每卷买若干本, 其中一次购买不同卷数 $2 ~ 5$ 本打折, 求最小花费

- 咋一看贪心, 但是 `[2,2,2,1,1]` 时, 两次购买 $4$ 本比一次 $5$ 更便宜
- 贪心正解
    - 由于每卷价格一致, 买 $3, 5$ 一定贵于 $4, 4$
    - 先贪心出所有次购买, 形成 `[0,0,1,0,1]` 代表不同卷数的购买次数
    - 使用发现的规律进行优化 `[0,0,0,2,0]`
- 当然, DP 更显而易见
    - 由于每卷价格一致, 状态是一个组合而非排列 `[2,2,2,1,1]` (随意排序)
    - 五维 DP, 幸好是组合, 只需要遍历升序状态

### 快速找出故障机器

找出数组中唯一的落单数字

- 异或秒杀
- 现在问题进化, 有两个不相同落单数字
    - 先异或所有数字, 得到的结果是两个落单数字的异或
    - 找到异或结果中为 $1$ 的位, 说明这两个数字在这一位上不同
    - 按照这一位是否为 $1$ 将数组分成两部分, 每个部分分别异或, 就可以得到两个落单数字
- 现在问题进化, 有两个相同落单数字
    - 需要预先知道和就秒杀了

### 饮料供货

帮大家买饮料, 使得大家的满意度总和最大, 饮料总共有 $L$ 升, 第 $i$ 种饮料, 单瓶容量为 $V_i$, 且 $V_i$ 是 2 的幂次, 满意度为 $H_i$, 库存最多有 $C_i$ 瓶, 决定每种饮料买多少瓶 $B_i$, 在总容量不超过 $L$ 的前提下, 让总满意度 $\sum (H_i \times B_i)$ 最大

- 多重背包板子题

```C++
// 假设 opt[v][j] 表示: 剩余容量为 v, 面对第 j 种饮料时的最大满意度
// T 是饮料种类的总数
// V_total 是总容量上限

// 从最后一种饮料开始往前推, 或者从第一种开始都可以, 这里假设是填表法
for (int j = T-1; j >= 0; j--) {  // 遍历每种饮料
    for (int v = 0; v <= V_total; v++) { // 遍历每种可能的容量状态
        
        opt[v][j] = -INF; // 初始化为负无穷

        // 核心循环: 尝试拿 k 瓶第 j 种饮料
        // 限制: k 不能超过库存 C[j], 且 k*Volume[j] 不能撑爆当前容量 v
        for (int k = 0; k <= C[j] && k * Volume[j] <= v; k++) {
            
            // 剩下的容量给下一种饮料(j+1)去分
            int remain_vol = v - k * Volume[j];
            int current_satisfaction = k * Satisfaction[j];
            
            // 状态转移
            int total_val = current_satisfaction + opt[remain_vol][j+1];
            
            // 如果这种拿法更好，就更新记录
            if (total_val > opt[v][j]) {
                opt[v][j] = total_val;
            }
        }
    }
}
```

- 注意到条件,  $V_i$ 是 2 的幂次
    - 因为所有容量都是 $2$ 的倍数, 小的饮料一定能完美凑出大的容量
    - 把所有饮料按满意度比容量排序
    - 二进制分解
    - 先看最小单位, 如果我们要买奇数升的饮料, 必须至少买 1 瓶 1L 的 (前提是用满容量一定最优)
    - 从小位向上遍历, 考虑是自己填满 / 用更大的瓶子来覆盖
    - 我们可以比较两瓶小的满意度之和与一瓶大的满意度 (其实刚才排序了)

### 光影切割问题

一个平面与若干条直线, 求平面被切割成多少个部分

- 显然, 区域数 = 直线数 + + 交点数 + $1$


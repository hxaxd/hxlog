# 设计模式

## 参考资料

- 大话设计模式
- 设计模式: 可复用面向对象软件的基础
- 重构: 改善既有代码的设计

## 简单工厂模式

- 不是 GoF $23$ 种设计模式之一
- 一个描述接口的父类 + 多个实现接口的子类 + 一个根据条件决定实例化哪个子类的工厂类

```C++
Factory* factory = new Factory();
Product* product = factory->createProduct(type);
product->use();
```

## 策略模式

- 定义了算法家族, 分别封装起来, 让它们之间可以互相替换, 算法的变化不会影响使用算法的客户
    - 这里的父类子类就叫做抽象策略和具体算法
- 使用方法就是往上下文类当中注入一个具体算法的实例 (常注入匿名函数)
    - 上下文类负责和具体算法交互并返回结果
- 经常结合简单工厂模式使用
    - 直接在上下文类中使用简单工厂创建具体算法实例
- 策略模式封装了变化, 避免使用大量的条件判断语句
    - 先校验条件, 再选择具体算法, 这使得算法可以自然的建立在约定之上

```C++
// 结合简单工厂模式的策略模式
Context* context = new Context(strategy_type);
context->executeStrategy();

// 结合函数式编程的策略模式
Context* context = new Context([](int a, int b) { return a + b; });
context->executeStrategy();
```

## 面向对象的设计原则 (SOLID)

### 单一职责原则 (SRP)

- 一个类应该只有一个引起它变化的原因
- 一个模块应该只对一类行为者负责

### 开闭原则 (OCP)

- 软件实体 (类, 模块, 函数等等) 应该可以扩展, 但不可修改
- 如果拓展没有提前预想到, 应该立刻拓展对应抽象

### 里氏替换原则 (LSP)

- 子类必须能够替换掉它们的父类, 且不影响程序的正确性
- 是开闭原则和依赖倒置原则的基础

### 接口隔离原则 (ISP)

- 拒绝胖接口, 使用多个专门的接口

### 依赖倒置原则 (DIP)

- 高层模块不应该依赖低层模块, 二者都应该依赖抽象
    - 抽象不应该依赖细节, 细节应该依赖抽象
- 系统中总会有一些违反 DIP 的具体实现
    - 隐藏隔离起来

## 装饰模式

- 动态地给一个对象添加一些额外的职责, 就增加功能来说, 装饰模式比生成子类更为灵活
- 组件类: 抽象类, 定义操作的接口
- 具体组件类: 继承组件类, 实现具体操作
- 装饰抽象类: 继承组件类, 持有一个组件类的实例, 代理执行具体组件类的方法
- 具体装饰类: 继承装饰抽象类, 重写具体操作, 在调用父类方法前后添加额外职责
- 每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中
- 如果类的某些职责只是特定情况下的行为, 使用装饰模式简化类的实现

```C++
// 客户端代码
ConcreteComponent* concrete_component = new ConcreteComponent();
DecoratorA* decoratorA = new DecoratorA(concrete_component);
DecoratorB* decoratorB = new DecoratorB(decoratorA);
decoratorB->Operation();
```

## 代理模式

- 为其他对象提供一种代理以控制对这个对象的访问
- 接口: 声明真实主题和代理主题的共同接口
- 真实类: 实现接口, 定义了代理所代表的真实对象
- 代理类: 实现接口, 内部包含对真实主题的引用, 控制对真实主题的访问
- 用途 (存根 / 装饰)
    - 远程代理: 为一个对象在不同的地址空间提供局部代表
    - 虚拟代理: 针对需要创建开销很大的对象, 延迟其创建和初始化
    - 保护代理: 控制对原始对象的访问, 提供不同级别的使用权限
    - 智能指引: 在访问对象时执行一些附加操作

```C++
// 代理负责创建真实主题对象并控制对它的访问
Subject* proxy = new Proxy();
proxy->Request();

// 注入真实主题对象
RealSubject* real_subject = new RealSubject();
Subject* proxy1 = new Proxy(real_subject, option1);
Subject* proxy2 = new Proxy(real_subject, option2);
proxy1->Request();
proxy2->Request();
```

## 工厂方法模式

- 简单工厂模式违反了开闭原则
- 定义一个创建对象的接口, 让子类 (具体工厂) 决定实例化哪一个类 (产品), 使得一个类的实例化延迟到其子类
- 定义抽象工厂类与抽象产品类
- 具体工厂类继承抽象工厂类, 创建具体产品类, 具体产品类继承抽象产品类

```C++
// 客户端选择具体工厂类
Factory* factoryA = new ConcreteFactoryA();
Product* productA = factoryA->createProduct();
productA->use();
```

## 原型模式

- 用原型实例指定创建对象的种类, 并且通过拷贝这些原型创建新的对象 (基于对象)
- 包括抽象原型类和具体原型类
- 抽象原型类声明一个克隆自身的接口
- 具体原型类实现克隆方法, 返回一个自身的副本
- 注意深浅拷贝

```C++
Prototype* prototype1 = new ConcretePrototype1();
Prototype* clone1 = prototype1->clone();
clone1->setField(field_value);
prototype1->show();
clone1->show();
```

## 模版方法模式

- 定义一个操作中的算法骨架, 将一些步骤延迟到子类中, 使得子类可以不改变算法结构即可重定义该算法的某些特定步骤
- 父类定义模版方法, 由一系列基本方法组成
    - 一些基本方法在父类中实现
    - 抽象方法由子类实现
    - 钩子方法有默认实现, 子类可选择性重写

```C++
// 客户端用父类的引用调用模版方法
AbstractClass* subclass1 = new ConcreteClass1();
AbstractClass* subclass2 = new ConcreteClass2();
subclass1->templateMethod(); // 内部多态调用子类方法
subclass2->templateMethod();
```

## 迪米特法则

- 又称最少知识原则
- 如果两个类不直接通信, 则不应当发生相互作用, 如果需要调用另一个类的方法, 则通过第三方间接调用
- 每个类都应当尽量降低成员的访问权限

## 外观模式

- 为子系统中的一组接口提供一个一致的高层接口, 使得子系统更易使用

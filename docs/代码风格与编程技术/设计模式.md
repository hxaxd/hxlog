# 设计模式

## 参考资料

- 大话设计模式
- 设计模式: 可复用面向对象软件的基础
- 重构: 改善既有代码的设计

## 简单工厂模式

- 不是 GoF $23$ 种设计模式之一
- 一个描述接口的父类 + 多个实现接口的子类 + 一个根据条件决定实例化哪个子类的工厂类

```C++
Factory* factory = new Factory();
Product* product = factory->createProduct(type);
product->use();
```

## 策略模式

- 定义了算法家族, 分别封装起来, 让它们之间可以互相替换, 算法的变化不会影响使用算法的客户
    - 这里的父类子类就叫做抽象策略和具体算法
- 使用方法就是往上下文类当中注入一个具体算法的实例 (常注入匿名函数)
    - 上下文类负责和具体算法交互并返回结果
- 经常结合简单工厂模式使用
    - 直接在上下文类中使用简单工厂创建具体算法实例
- 策略模式封装了变化, 避免使用大量的条件判断语句
    - 先校验条件, 再选择具体算法, 这使得算法可以自然的建立在约定之上

```C++
// 结合简单工厂模式的策略模式
Context* context = new Context(strategy_type);
context->executeStrategy();

// 结合函数式编程的策略模式
Context* context = new Context([](int a, int b) { return a + b; });
context->executeStrategy();
```

## 面向对象的设计原则 (SOLID)

### 单一职责原则 (SRP)

- 一个类应该只有一个引起它变化的原因
- 一个模块应该只对一类行为者负责

### 开闭原则 (OCP)

- 软件实体 (类, 模块, 函数等等) 应该可以扩展, 但不可修改
- 如果拓展没有提前预想到, 应该立刻拓展对应抽象

### 里氏替换原则 (LSP)

- 子类必须能够替换掉它们的父类, 且不影响程序的正确性
- 是开闭原则和依赖倒置原则的基础

### 接口隔离原则 (ISP)

- 拒绝胖接口, 使用多个专门的接口

### 依赖倒置原则 (DIP)

- 高层模块不应该依赖低层模块, 二者都应该依赖抽象
    - 抽象不应该依赖细节, 细节应该依赖抽象
- 系统中总会有一些违反 DIP 的具体实现
    - 隐藏隔离起来

### 迪米特法则

- 又称最少知识原则
- 如果两个类不直接通信, 则不应当发生相互作用, 如果需要调用另一个类的方法, 则通过第三方间接调用
- 每个类都应当尽量降低成员的访问权限

## 装饰模式

- 动态地给一个对象添加一些额外的职责, 就增加功能来说, 装饰模式比生成子类更为灵活
- 组件类: 抽象类, 定义操作的接口
- 具体组件类: 继承组件类, 实现具体操作
- 装饰抽象类: 继承组件类, 持有一个组件类的实例, 代理执行具体组件类的方法
- 具体装饰类: 继承装饰抽象类, 重写具体操作, 在调用父类方法前后添加额外职责
- 每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中
- 如果类的某些职责只是特定情况下的行为, 使用装饰模式简化类的实现

```C++
// 客户端代码
ConcreteComponent* concrete_component = new ConcreteComponent();
DecoratorA* decoratorA = new DecoratorA(concrete_component);
DecoratorB* decoratorB = new DecoratorB(decoratorA);
decoratorB->Operation();
```

## 代理模式

- 为其他对象提供一种代理以控制对这个对象的访问
- 接口: 声明真实主题和代理主题的共同接口
- 真实类: 实现接口, 定义了代理所代表的真实对象
- 代理类: 实现接口, 内部包含对真实主题的引用, 控制对真实主题的访问
- 用途 (存根 / 装饰)
    - 远程代理: 为一个对象在不同的地址空间提供局部代表
    - 虚拟代理: 针对需要创建开销很大的对象, 延迟其创建和初始化
    - 保护代理: 控制对原始对象的访问, 提供不同级别的使用权限
    - 智能指引: 在访问对象时执行一些附加操作

```C++
// 代理负责创建真实主题对象并控制对它的访问
Subject* proxy = new Proxy();
proxy->Request();

// 注入真实主题对象
RealSubject* real_subject = new RealSubject();
Subject* proxy1 = new Proxy(real_subject, option1);
Subject* proxy2 = new Proxy(real_subject, option2);
proxy1->Request();
proxy2->Request();
```

## 工厂方法模式

- 简单工厂模式违反了开闭原则
- 定义一个创建对象的接口, 让子类 (具体工厂) 决定实例化哪一个类 (产品), 使得一个类的实例化延迟到其子类
- 定义抽象工厂类与抽象产品类
- 具体工厂类继承抽象工厂类, 创建具体产品类, 具体产品类继承抽象产品类

```C++
// 客户端选择具体工厂类
Factory* factoryA = new ConcreteFactoryA();
Product* productA = factoryA->createProduct();
productA->use();
```

## 原型模式

- 用原型实例指定创建对象的种类, 并且通过拷贝这些原型创建新的对象 (基于对象)
- 包括抽象原型类和具体原型类
- 抽象原型类声明一个克隆自身的接口
- 具体原型类实现克隆方法, 返回一个自身的副本
- 注意深浅拷贝

```C++
Prototype* prototype1 = new ConcretePrototype1();
Prototype* clone1 = prototype1->clone();
clone1->setField(field_value);
prototype1->show();
clone1->show();
```

## 模版方法模式

- 定义一个操作中的算法骨架, 将一些步骤延迟到子类中, 使得子类可以不改变算法结构即可重定义该算法的某些特定步骤
- 父类定义模版方法, 由一系列基本方法组成
    - 一些基本方法在父类中实现
    - 抽象方法由子类实现
    - 钩子方法有默认实现, 子类可选择性重写

```C++
// 客户端用父类的引用调用模版方法
AbstractClass* subclass1 = new ConcreteClass1();
AbstractClass* subclass2 = new ConcreteClass2();
subclass1->templateMethod(); // 内部多态调用子类方法
subclass2->templateMethod();
```

## 外观模式

- 为子系统中的一组接口提供一个一致的高层接口, 使得子系统更易使用
- 适合分层结构

```C++
Facade* facade = new Facade();
facade->operation1(options);
facade->operation2(options);
facade->operation3(options);
```

## 建造者模式

- 将一个复杂对象的构建与它的表示分离, 使得同样的构建过程可以创建不同的表示
- 用于创建复杂对象, 对象内部构造间的建造顺序是稳定的, 但各个部件的具体实现具有复杂变化
- 抽象建造者: 声明创建产品各个部件的抽象接口
- 具体建造者: 实现抽象建造者接口, 构造和装配各个部件
- 指挥者: 构造一个使用建造者接口的对象, 决定建造的顺序

```C++
// 指挥者
Director* director = new Director();

// 具体建造者
Builder* builderA = new ConcreteBuilderA();
Builder* builderB = new ConcreteBuilderB();

// 构造不同的产品
director->setBuilder(builderA);
Product* productA = director->construct();

director->setBuilder(builderB);
Product* productB = director->construct();
```

## 观察者模式 (发布 - 订阅模式)

- 定义对象间的一种一对多的依赖关系, 让多个观察者对象同时监听某一个主题对象, 该主题对象在状态发生变化时, 会通知所有观察者对象, 使它们能够自动更新自己
- 我们不希望为了一致性而让对象之间产生强耦合, 这时可以使用观察者模式
- 抽象主题类: 声明注册, 注销和通知观察者方法
- 具体主题类: 实现抽象主题类, 状态发生变化时通知
- 抽象观察者类: 声明更新接口
- 具体观察者类: 实现更新接口, 以便在得到主题状态变更通知时更新自身状态
- 可以结合函数式编程使用回调函数作为观察者

```C++
// 创建主题和观察者
Subject* subject = new ConcreteSubject();
Observer* observer1 = new ConcreteObserver();
Observer* observer2 = new ConcreteObserver();

// 注册观察者
subject->attach(observer1);
subject->attach(observer2);

// 改变主题状态, 通知观察者
subject->setState(new_state); // 内部调用观察者的 update 方法
subject->notify();
```

## 抽象工厂模式

- 提供一个创建一系列相关或相互依赖对象的接口, 而无需指定它们具体的类
- 若干个抽象产品类, 每个抽象产品类派生出多个具体产品类
- 抽象工厂类: 声明创建抽象产品对象的操作接口
- 具体工厂类: 实现创建一组具体产品对象的操作
- 不如简单工厂模式 + 依赖注入 + 配置文件

```C++
// 客户端选择具体工厂类
AbstractFactory* factory = new ConcreteFactory1();

// 创建一系列相关的产品对象
AbstractProductA* productA = factory->createProductA();
AbstractProductB* productB = factory->createProductB();
productA->use();
productB->use();

// 或者通过配置文件动态选择具体工厂类
AbstractFactory* factory = FactoryProducer::getFactory();
AbstractProductA* productA = factory->createProductA();
AbstractProductB* productB = factory->createProductB();
productA->use();
productB->use();
```

## 状态模式

- 允许一个对象在其内部状态改变时改变它的行为, 对象看起来似乎修改了它的类

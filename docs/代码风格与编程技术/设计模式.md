# 设计模式

## 参考资料

- 大话设计模式
- 设计模式: 可复用面向对象软件的基础
- 重构: 改善既有代码的设计

## 简单工厂模式

- 不是 GoF $23$ 种设计模式之一
- 工厂类: 负责创建产品类的实例
- 抽象产品类: 定义产品的接口
- 产品类: 定义具体产品的实现

```C++
Factory* factory = new Factory();
Product* product = factory->createProduct(type);
product->use();
```

## 策略模式

- 定义了算法家族, 分别封装起来, 让它们之间可以互相替换, 算法的变化不会影响使用算法的客户
- 抽象策略类: 声明一个公共接口, 所有支持的算法都以此接口进行编程
- 具体策略类: 实现抽象策略接口的具体算法
- 上下文类: 维护一个策略类的引用, 用于调用具体算法
    - 现代常注入匿名函数而非类
- 策略模式封装了变化, 避免使用大量的条件判断语句
- 也可以结合简单工厂模式使用
    - 直接在上下文类中使用简单工厂创建具体算法实例

```C++
// 结合简单工厂模式的策略模式
Context* context = new Context(strategy_type);
context->executeStrategy();

// 结合函数式编程的策略模式
Context* context = new Context([](int a, int b) { return a + b; });
context->executeStrategy();
```

## 面向对象的设计原则 (SOLID)

### 单一职责原则 (SRP)

- 一个类应该只有一个引起它变化的原因
- 一个模块应该只对一类行为者负责

### 开闭原则 (OCP)

- 软件实体 (类, 模块, 函数等等) 应该可以扩展, 但不可修改
- 如果拓展没有提前预想到, 应该立刻拓展对应抽象

### 里氏替换原则 (LSP)

- 子类必须能够替换掉它们的父类, 且不影响程序的正确性
- 是开闭原则和依赖倒置原则的基础

### 接口隔离原则 (ISP)

- 拒绝胖接口, 使用多个专门的接口

### 依赖倒置原则 (DIP)

- 高层模块不应该依赖低层模块, 二者都应该依赖抽象
    - 抽象不应该依赖细节, 细节应该依赖抽象
- 系统中总会有一些违反 DIP 的具体实现
    - 隐藏隔离起来

### 迪米特法则

- 又称最少知识原则
- 如果两个类不直接通信, 则不应当发生相互作用, 如果需要调用另一个类的方法, 则通过第三方间接调用
- 每个类都应当尽量降低成员的访问权限

## 装饰模式

- 动态地给一个对象添加一些额外的职责, 就增加功能来说, 装饰模式比生成子类更为灵活
- 组件类: 抽象类, 定义操作的接口
- 具体组件类: 继承组件类, 实现具体操作
- 装饰抽象类: 继承组件类, 持有一个组件类的实例, 代理执行具体组件类的方法
- 具体装饰类: 继承装饰抽象类, 重写具体操作, 在调用父类方法前后添加额外职责
- 每个装饰对象只关心自己的功能，不需要关心如何被添加到对象链当中
- 如果类的某些职责只是特定情况下的行为, 使用装饰模式简化类的实现

```C++
// 客户端代码
ConcreteComponent* concrete_component = new ConcreteComponent();
DecoratorA* decoratorA = new DecoratorA(concrete_component);
DecoratorB* decoratorB = new DecoratorB(decoratorA);
decoratorB->Operation();
```

## 代理模式

- 为其他对象提供一种代理以控制对这个对象的访问
- 接口: 声明真实主题和代理主题的共同接口
- 真实类: 实现接口, 定义了代理所代表的真实对象
- 代理类: 实现接口, 内部包含对真实主题的引用, 控制对真实主题的访问
- 用途 (存根 / 装饰)
    - 远程代理: 为一个对象在不同的地址空间提供局部代表
    - 虚拟代理: 针对需要创建开销很大的对象, 延迟其创建和初始化
    - 保护代理: 控制对原始对象的访问, 提供不同级别的使用权限
    - 智能指引: 在访问对象时执行一些附加操作

```C++
// 代理负责创建真实主题对象并控制对它的访问
Subject* proxy = new Proxy();
proxy->Request();

// 注入真实主题对象
RealSubject* real_subject = new RealSubject();
Subject* proxy1 = new Proxy(real_subject, option1);
Subject* proxy2 = new Proxy(real_subject, option2);
proxy1->Request();
proxy2->Request();
```

## 工厂方法模式

- 简单工厂模式违反了开闭原则
- 定义一个创建对象的接口, 让子类 (具体工厂) 决定实例化哪一个类 (产品), 使得一个类的实例化延迟到其子类
- 抽象工厂类: 声明创建产品对象的工厂方法
- 抽象产品类: 定义产品的接口
- 具体工厂类: 实现工厂方法, 创建具体产品类的实例
- 具体产品类: 实现抽象产品接口

```C++
// 客户端选择具体工厂类
Factory* factoryA = new ConcreteFactoryA();
Product* productA = factoryA->createProduct();
productA->use();
```

## 原型模式

- 用原型实例指定创建对象的种类, 并且通过拷贝这些原型创建新的对象 (基于对象)
- 抽象原型类: 声明一个克隆自身的接口
- 具体原型类: 实现克隆方法, 返回一个自身的副本
- 注意深浅拷贝

```C++
Prototype* prototype1 = new ConcretePrototype1();
Prototype* clone1 = prototype1->clone();
clone1->setField(field_value);
prototype1->show();
clone1->show();
```

## 模版方法模式

- 定义一个操作中的算法骨架, 将一些步骤延迟到子类中, 使得子类可以不改变算法结构即可重定义该算法的某些特定步骤
- 父类定义模版方法, 由一系列基本方法组成
    - 一些基本方法在父类中实现
    - 抽象方法由子类实现
    - 钩子方法有默认实现, 子类可选择性重写

```C++
// 客户端用父类的引用调用模版方法
AbstractClass* subclass1 = new ConcreteClass1();
AbstractClass* subclass2 = new ConcreteClass2();
subclass1->templateMethod(); // 内部多态调用子类方法
subclass2->templateMethod();
```

## 外观模式

- 为子系统中的一组接口提供一个一致的高层接口, 使得子系统更易使用
- 适合分层结构

```C++
Facade* facade = new Facade();
facade->operation1(options);
facade->operation2(options);
facade->operation3(options);
```

## 建造者模式

- 将一个复杂对象的构建与它的表示分离, 使得同样的构建过程可以创建不同的表示
- 用于创建复杂对象, 对象内部构造间的建造顺序是稳定的, 但各个部件的具体实现具有复杂变化
- 抽象建造者: 声明创建产品各个部件的抽象接口
- 具体建造者: 实现抽象建造者接口, 构造和装配各个部件
- 指挥者: 构造一个使用建造者接口的对象, 决定建造的顺序

```C++
// 指挥者
Director* director = new Director();

// 具体建造者
Builder* builderA = new ConcreteBuilderA();
Builder* builderB = new ConcreteBuilderB();

// 构造不同的产品
director->setBuilder(builderA);
Product* productA = director->construct();

director->setBuilder(builderB);
Product* productB = director->construct();
```

## 观察者模式 (发布 - 订阅模式)

- 定义对象间的一种一对多的依赖关系, 让多个观察者对象同时监听某一个主题对象, 该主题对象在状态发生变化时, 会通知所有观察者对象, 使它们能够自动更新自己
- 我们不希望为了一致性而让对象之间产生强耦合, 这时可以使用观察者模式
- 抽象主题类: 声明注册, 注销和通知观察者方法
- 具体主题类: 实现抽象主题类, 状态发生变化时通知
- 抽象观察者类: 声明更新接口
- 具体观察者类: 实现更新接口, 以便在得到主题状态变更通知时更新自身状态
- 可以结合函数式编程使用回调函数作为观察者

```C++
// 创建主题和观察者
Subject* subject = new ConcreteSubject();
Observer* observer1 = new ConcreteObserver();
Observer* observer2 = new ConcreteObserver();

// 注册观察者
subject->attach(observer1);
subject->attach(observer2);

// 改变主题状态, 通知观察者
subject->setState(new_state); // 内部调用观察者的 update 方法
subject->notify();
```

## 抽象工厂模式

- 提供一个创建一系列相关或相互依赖对象的接口, 而无需指定它们具体的类
- 若干个抽象产品类, 每个抽象产品类派生出多个具体产品类
- 抽象工厂类: 声明创建抽象产品对象的操作接口
- 具体工厂类: 实现创建一组具体产品对象的操作
- 不如简单工厂模式 + 依赖注入 + 配置文件

```C++
// 客户端选择具体工厂类
AbstractFactory* factory = new ConcreteFactory1();

// 创建一系列相关的产品对象
AbstractProductA* productA = factory->createProductA();
AbstractProductB* productB = factory->createProductB();
productA->use();
productB->use();

// 或者通过配置文件动态选择具体工厂类
AbstractFactory* factory = FactoryProducer::getFactory();
AbstractProductA* productA = factory->createProductA();
AbstractProductB* productB = factory->createProductB();
productA->use();
productB->use();
```

## 状态模式

- 允许一个对象在其内部状态改变时改变它的行为, 对象看起来似乎修改了它的类
- 如果一个对象的状态非常复杂, 并且依赖于它的状态进行不同的行为, 那么可以使用状态模式将不同状态的行为局部化到不同的类中
- 抽象状态类: 声明与上下文的一个接口以封装与特定状态相关的行为
- 具体状态类: 定义与特定状态相关的行为以及状态转换
- 上下文类: 维护一个具体状态类的实例, 定义客户端感兴趣的接口

```C++
Context* context = new Context(new ConcreteStateA());
context->request(); // 根据当前状态执行不同的行为
context->setState(option); // 切换状态
context->request(); // 实例已经变化
```

## 适配器模式

- 将一个类的接口转换成客户希望的另一个接口, 使得原本由于接口不兼容而不能一起工作的那些类可以一起工作
- 类适配器模式: 通过多重继承实现, 不展开
- 对象适配器模式
    - 适配器类: 实现目标接口, 内部持有一个需要适配的对象实例, 将客户端的请求转换为适配对象的调用
    - 目标接口: 定义客户端所期望的接口

```C++
Target* adapter = new Adapter(new Adaptee());
adapter->request(); // 内部调用适配者的方法
```

## 备忘录模式

- 在不破坏封装性的前提下, 捕获一个对象的内部状态, 并在该对象之外保存这个状态, 以便以后将对象恢复到原先保存的状态
- 发起人: 负责创建备忘录并存储自身状态, 也负责使用备忘录恢复自身状态
- 备忘录: 负责存储发起人的内部状态, 并防止除发起人以外的其他对象访问备忘录
- 管理者: 负责保存好备忘录, 并在需要时提供备忘录给发起人

```C++
// 发起人创建备忘录并保存状态
Originator* originator = new Originator();
originator->setState("State1");
Caretaker* caretaker = new Caretaker(originator->createMemento());

// 发起人恢复状态
originator->restoreMemento(caretaker->getMemento());
```

## 组合模式

- 将对象组合成树形结构以表示“部分-整体”的层次结构, 使得用户对单个对象和组合对象的使用具有一致性
- 组件抽象类: 声明叶子和容器的共同接口
- 叶子类: 叶子节点, 实现组件接口
- 容器类: 复合节点, 实现组件接口, 并包含子组件的相关操作
- 适用于树形结构

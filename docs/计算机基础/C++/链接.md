- 程序员的自我修养 神,因为全 5

>"计算机领域的任何问题都可以通过增加一个间接的中间层来解决"

## 简介

### 温故而知新
- 早期的计算机硬件结构就是CPU,内存,IO控制器连在总线上
- 由于CPU频率的提升产生了系统总线(PCI),而CPU频率数倍于系统总线频率
- 后多媒体的发展产生了北桥芯片,协调CPU内存与高速的图形设备, 而缓慢的设备则连接南桥,最初依赖ISA总线
- 随着时代的发展也逐有变化,诸如PCI代替ISA,PCIE代替PCI,USB连接外部设备
---

- SMP对称多处理器是最初为了解决性能增长缓慢的设想,但是由于CPU使用独立的缓存部件过于昂贵,因此多核心共用缓存部件,成为更成熟的方案,这也就是多核处理器

---
- 应用程序使用运行库提供的应用程序编程接口  
- 运行库则使用操作系统提供的系统调用接口,这往往是依赖中断来实现
---
- 操作系统调度CPU资源的方法最初是多道程序(当一个程序暂时没有使用,立刻调用下一个程序,缺点是没有优先级),经过改进,变成了分时系统(一段时间内,每个程序都运行一小段时间,并且有简单的优先级)
- 而更先进的操作系统模式,就是目前的多任务系统,所有应用程序都以进程的方式运行在比操作系统权限更低的级别,并且地址空间独立,CPU的分配方式为抢占式,根据优先级高低都有机会得到CPU,但是有使用的最长时间
---
- 操作系统的另外一个重要用处是驱动硬件,它把硬件原本的I/O端口抽象成软件层面的接口
- 甚至在硬件内部也有这样的一个中间层,比如机械硬盘从逻辑扇区到实际扇区
---
- 为满足隔离地址空间,充分利用内存以及固定程序运行的地址,我们在实际的内存地址上建立一个中间层,也就是虚拟地址
- 最初的设想是分段映射,这解决了第三和第一个问题,就是简单地直接映射
- 考虑到程序的大多数据在一个时间段内是不会用到的,我们使用更小粒度的内存分割和映射方法--分页
- 分页即把地址空间人为的分成固定大小的页, 把虚拟页映射到物理页和磁盘页(虚拟内存)当中, 当进程访问不在内存中的页,会产生页错误,经判断后,系统会把该页调入内存,然后再访问,对页的操作非常高效,因为有硬件级的支持,内存管理单元(MMU)负责页映射
---
- 一个进程由一个的多个线程(轻量级进程LWP)组成,线程之间共享内存空间以及进程级资源, 但拥有独立的线程ID,当前指令指针(PC),寄存器集合以及堆栈
- 线程的访问非常自由,虽然我们往往认为堆栈是其私有空间,但这并不是强制的,某些操作系统会为线程单独提供私有空间TLS
- 单处理器对应多线程时,多线程程序会轮流执行一小段时间称之为线程调度,线程往往拥有三种状态运行,就绪,等待
- 线程调度有非常多的方案与算法,但是基本留有优先级调度以及轮转法的思想,主流系统允许你自己设计优先级,但是系统也会自动调整
- 频繁等待的线程称为IO密集型线程,而长时间运行的线程称为计算密集型线程,显然IO密集型线程的优先级更容易被系统提高,另一种会引发优先级调整的情况是系统防止线程优先级过低,而饿死
- 线程调度分可抢占与不可抢占,不可抢占的调度方式中,只有线程主动放弃时间片,或者进入等待状态时才会被调度
---
- windows API教科书式的执行进程与线程,但Linux则是把进程和线程统一为任务,多个任务可以选择共享内存空间
- Linux有三种方式创建任务,fork(复制当前进程),clone(创建子进程),exec(用新映像替换当前进程映像)
```C++
pid_t pid = fork();
if(pid == 0)
{
    exec("程序路径", "参数1", "参数2",...);
}
else if(pid > 0)
{
    ....
}
//省略了其他代码,这是一个简单的子进程创建
//注意fork()函数会返回两次以区分父进程与子进程
```
- fork非常快,因为它不需要复制父进程的内存空间,而是在任务试图修改内存时,再复制一份(写时修改)
- clone()函数可以创建一个新的任务,并指定开始执行的位置,是否共享内存空间,因此实际产生一个线程
---
- 许多指令在运行时是由多个指令构成(涉及寄存器),并行的线程同时对一个内存位置操作会因此而不安全,不少体系结构提供原子性操作或系统提供原子性API,但这只对简单的操作有用,数据结构或操作复杂时,需要同步与锁
- 锁是实现同步的机制,在线程访问数据前,先获取锁,访问后释放锁,其他线程则等待,信号量是一种简单的锁,当线程访问时,信号量减一,当信号量为零时,线程阻塞,当线程释放时,信号量加一
- 互斥量在二元信号量的基础上,只允许获取锁的线程去释放,而不允许其他线程帮着释放
- 临界区则是一种特殊的互斥量,线程创建临界区后,只有本线程可以获取该锁
- 读写锁应对多读取少写入的场景,当其自由,它可以被线程以共享方式或独占方式获取,当线程以共享方式获取,其他线程以相同方式获取是可以的,但是不可被独占,当其被独占,那么任何其他线程都不可以再获取
- 条件变量也是一种同步手段,一个或多个线程可同时等待某一个条件变量,当条件变量被唤醒时,所有正在等待它的线程都会被同时唤醒并恢复执行
---

- 可重入函数在多线程环境中是安全的,其必要条件是不使用任何静态存储期变量,不返回任何静态存储期变量的指针,仅依赖调用方提供的参数,不依赖任何单个资源的锁,不调用不可重入函数

---
- 过度优化造成线程不安全,如寄存器不写回,调整无关语句顺序,c/c++ volatile能阻止编译器优化,但CPU还是会调整语句顺序
- 许多CPU会提供一个指令,用来阻止该指令之前的语句和之后的语句顺序交换
---
- win和linux都支持内核多线程,但用户线程不一定与内核线程一一对应,存在一对一,多对一,多对多的关系,其主要差别在于有无对线程数量的限制,与一个线程会不会堵塞多个线程以及线程的调度时切换上下文的开销

PS:没学过操作系统导致我边学边查,累死了

## 静态链接

### 编译与链接
- 编译有四个步骤,预处理,编译(前后端),汇编和链接
- 预处理除了我们老生常谈的展开宏插入文件删除注释之外,还要添加行号和文件名标识,以供编译器产生错误信息或者为调试器提供信息,并且会保留编辑器指令#pragma
- 编译经词法分析,语法分析,语义分析,优化产生汇编代码,gcc中由cc1程序负责这两部分,as负责汇编,ld负责链接,gcc只是它们的包装
---
- 编译过程,首先扫描器用一种类似有限状态机的算法,将代码的字符序列分割成一系列的记号(Token),记号分为关键字,标识符,常量,运算符等,其中标识符会存放到符号表,常量存放到文字表,lex是通用的词法分析器,可以按照用户描述的规则扫描
- 随后用上下文无关语法的手段进行复杂语句的语法分析,它对重用的符号加以区分,并建立语法树,yacc是通用的语法分析器可以按照用户指定的语法进行分析
- 随后是语义分析,语句在语法上合法不代表在语义上合法,例如指针进行乘法,声明与类型是否匹配,并且帮助进行自动类型转换,标识变量常量函数运算符的类型,但它只能检查静态语义,而像除0等动态语义错误无法检查
- 接下来是中间代码生成,生成诸如三地址码(b与c操作,结果置于a),p-code等,它们与平台无关,便于优化(可以被解释器执行)随后基于中间代码优化,例如编译时可确定语句,这就是编译器的前端,不依赖平台
- 最后代码生成器将中间代码编译为目标代码,随后再由目标代码优化器优化,诸如位移代替乘除法以及涉及平台的诸多优化
---
- 但此时变量等的绝对地址以及使用其他模块变量的问题悬而未解,让linker出手,现代软件开发离不开模块化,而连接每个模块(模块间符号的引用)就是链接
- 链接过程主要包括地址与空间分配,符号决议(对应符号与地址),重定位等,将目标文件与库(一组目标文件)等链接,最基本的工作就是给跨模块的变量与函数引用添上地址(修正重定位入口)
- 最常用的库--运行时库,支持程序运行的基本函数集合

### 目标文件有什么

- 目标文件本质就是未经链接的可执行文件,仅在结构上略有不同
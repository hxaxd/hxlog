### 开始

- istream类的对象`cin`,ostream类的对象`cout cerr clog`,用处顾名思义
- endl结束行,刷新缓冲区,在流中叫操纵符
- istream对象作为条件,流未错误时true,EOF或无效输入返回false,原理是重载bool转换
- 另外,遇见错误是cin对象会设置错误状态,后续输入无效

## C++基础

### 变量和基本类型

#### 算术类型

- C++规定算术类型的最小尺寸,大多与C一致,注意wchar_t,char16_t是16位_tchar32_t是32位(后两种应对unicode)
- 对浮点型仅要求最小精度,6/10/10(一般来说7/16,32bit/64bit),bool值未定义
- 字节是可寻址的最小内存块,存储的基本单元为字
- 除bool与拓展char外,其他**整数**类型都有符号和无符号版本,分别用signed/unsigned修饰
- 除char外,其他算术类型本身就是signed,但char有三种,而其本身到底是signed还是unsigned则取决于编译器
- 强制类型转换,赋signed一个区间外的值会产生未定义行为,而赋unsigned则会产生模运算,值为初始值对容量取模,-1对256取模为255
- 混用signed和unsigned,signed会自动转换为unsigned 
- 八进制与十六进制字面量,类型为可以容纳的最小类型(int/long/long long以及它们的无符号版本),注意没有short
- 但十进制字面量的类型都是有符号的,然而字面量本身不会为负数,-n本质是n的取反
- 浮点型字面量的类型为double,可用科学计数法表示
- 关于指定字面量类型,除后缀外,还可以用前缀,如L,u8,u,U分别是拓展char

#### 变量

- C的初始化器变成了C++的初始化列表,但`int a{0}; int a={0}`都可以
- 特殊的,初始化列表造成数据丢失编译器会报错,而=或者()则不会
- extern int a 强调这是一个声明(显示初始化会退化为定义),在函数体内显示初始化extern的变量会报错
- 作用域与C一致

#### 复合类型

- 左值引用即别名,它必须被初始化(绑在一个对象上)
- 指针与C基本一致
- nullptr是一种特殊类型的字面量,可以转换为任何指针类型,NULL是值为((void*)0)的宏
- 指针可以有引用

#### const

- const对象必须初始化
- const内部类型对象默认为内部链接,原因是有初始值的常量使用时会被直接替换,cpp为保证能找到它最好将它放在头文件中,为避免重复定义默认内部链接
- 但常量也有不知道初始值的,这时应该使用extern const,用初始化与否决定声明/定义
- 对const的引用也是不可修改值的(注意引用类型必须也是const)
- 但反之,const引用可以绑定到非const对象上,也不能通过引用修改对象的值
- 特殊的const引用可以绑定到其它类型上(可以转换就行),会产生一个临时对象
- 指针与const基本与C一致
- 顶层const与底层const
- 常量表达式(甚至常量函数)可以在编译期确定,但自动判断常量很困难,你可以声明一个constexpr(特殊的const)变量,它必须是被常量表达式初始化,否则会报错
- 其必须是字面值类型,constexpr指针也必须初始化为nullptr/0/某个固定地址

#### 处理类型

- using/typedef可以为类型起别名,再用声明符时,优先级小于别名内部的
- auto自动判断类型,忽略顶层const(引用不被认为是类型的一部分),但底层const则保留
- anto&时会保留顶层const(即使不显示const)
- `decltype()`可以得到表达式的类型,但不使用表达式的值,保留一切类型(包括引用,惟独这时引用会被当作类型的一部分,所以可以`a+0`的形式去掉引用)
- 注意`*p`的类型是是一种引用,(p)与p的类型是不同的,(p)是表达式,类型为引用,*** 原因是(p)是可以做左值的特殊表达式 ***

#### 自定义数据结构

- C++11规定类内数据成员可以指定初始值,否则会默认初始化
- 头文件保护符

### 字符串,向量和数组

#### 命名空间的using声明

- `using namespace::name;`就可以自由使用name,头文件显然不应使用

#### 标准库类型string

- 头文件`<string>`
- C++可直接初始化/拷贝初始化(只能提供一个值),可以构造临时对象强行拷贝初始化
- getline(is,s) 读取一整行,遇到换行符结束,返回is(直接cin>>是空白就停)
- 标准库类型大多有配套类型,如string::size_type是无符号类型
- 显然字符串字面值是C风格(字符数组)
- C标准库name.h依旧可用,但建议使用cname头文件,因为它们属于std命名空间
- cctype中有一堆判断字符的函数
- `for(type name:range)`  范围for循环,遍历range中的每个元素,并将其赋值给name
- 显然若想修改元素,则name必须为引用类型

#### 标准库类型vector

- 模版不是类或函数,是编译器生成类或函数的一份说明,需要实例化
- 
- C++ Primer 大而不全(CPP没法全),叙述顺序很棒 5

### 开始

- istream类的对象`cin`,ostream类的对象`cout cerr clog`,用处顾名思义
- endl结束行,刷新缓冲区,在流中叫操纵符
- istream对象作为条件,流未错误时true,EOF或无效输入返回false,原理是重载bool转换
- 另外,遇见错误时cin对象会设置错误状态(强转bool会返回这个值),后续输入无效

# C++基础

## 变量和基本类型

### 算术类型

- C++规定算术类型的最小尺寸,注意wchar_t,char16_t是16位_tchar32_t是32位(后两种应对unicode)
- 对浮点型仅要求最小精度,6/10/10(一般来说7/16,32bit/64bit),bool值未定义
- 字节是可寻址的最小内存块,存储的基本单元为字

#### 整数类型

- 除bool与拓展char外,其他**整数**类型都有符号和无符号版本,分别用signed/unsigned修饰
- 除char外,其他算术类型本身就是signed,但char有三种,而其本身到底是signed还是unsigned则取决于编译器
- 强制类型转换,赋signed一个区间外的值会产生未定义行为,而赋unsigned则会产生模运算,值为初始值对容量取模,-1对256取模为255
- 混用signed和unsigned,signed会自动转换为unsigned 
- 八进制与十六进制字面量,类型为可以容纳的最小类型(int/long/long long以及它们的无符号版本),注意没有short
- 但十进制字面量的类型都是有符号的,然而字面量本身不会为负数,-n本质是n的取反

#### 浮点类型

- 字符型字面量的类型为char,如'a'
- 浮点型字面量的类型为double,可用科学计数法表示
- 关于指定字面量类型,除后缀外,还可以用前缀,如L,u8,u,U分别是拓展char

### 变量

- C的初始化器变成了C++的初始化列表,但`int a{0}; int a={0};`都可以
- 特殊的,初始化列表造成数据丢失编译器会报错,而=或者()则不会
- extern int a 强调这是一个声明(显示初始化会退化为定义),在函数体内显示初始化extern的变量会报错
- 作用域与C一致

### 复合类型

- 左值引用即别名,它必须被初始化(绑在一个对象上)
- nullptr是一种特殊类型的字面量,可以转换为任何指针类型,NULL是值为((void*)0)的宏
- 指针可以有引用

### const

- const对象必须初始化
- const内部类型对象默认为内部链接,原因是有初始值的常量使用时会被直接替换,cpp为保证能找到它最好将它放在头文件中,为避免重复定义默认内部链接
- 但常量也有不知道初始值的,这时应该使用extern const,用初始化与否决定声明/定义

#### 特性

- 对const的引用也是不可修改值的(注意引用类型必须也是const)
- 但反之,const引用可以绑定到非const对象上,也不能通过引用修改对象的值
- 特殊的const引用可以绑定到其它类型上(可以转换就行),会产生一个临时对象
- 顶层const与底层const

#### constexpr

- 常量表达式(甚至常量函数)可以在编译期确定,但自动判断常量很困难,你可以声明一个constexpr(特殊的const)变量,它必须是被常量表达式初始化,否则会报错
- 其必须是字面值类型,constexpr指针也必须初始化为nullptr/0/某个固定地址

### 处理类型

- using/typedef可以为类型起别名,再用声明符时,优先级小于别名内部的
- auto自动判断类型,忽略顶层const(引用不被认为是类型的一部分),但底层const则保留
- anto&时会保留顶层const(即使不显示const)
- `decltype()`可以得到表达式的类型,但不使用表达式的值,保留一切类型(包括引用,惟独这时引用会被当作类型的一部分,所以可以`a+0`的形式去掉引用)
- 注意`*p`的类型是是一种引用,(p)与p的类型是不同的,(p)是表达式,类型为引用,*** 原因是(p)是可以做左值的特殊表达式 ***

### 自定义数据结构

- C++11规定类内数据成员可以指定初始值,否则会默认初始化
- 头文件保护符

## 字符串,向量和数组

### 命名空间的using声明

- `using namespace::name;`就可以自由使用name,头文件显然不应使用

### 标准库类型string

- 头文件`<string>`
- C++可直接初始化/拷贝初始化(只能提供一个值),可以构造临时对象强行拷贝初始化
- getline(is,s) 读取一整行,遇到换行符结束,返回is(直接cin>>是空白就停)
- 标准库类型大多有配套类型,如string::size_type是无符号类型

#### C风格字符串

- 显然字符串字面值是C风格(字符数组)
- C标准库name.h依旧可用,但建议使用cname头文件,因为它们属于std命名空间
- cctype中有一堆判断字符的函数

#### 范围for

- `for(type name:range)`  范围for循环,遍历range中的每个元素,并将其赋值给name,注意***元素本身过大是应使用引用***
- 显然若想修改元素,则name必须为引用类型

### 标准库类型vector

- 模版不是类或函数,是编译器生成类或函数的一份说明,需要实例化
- 在类的数据成员声明处进行初始化(类内初始值),不可使用()
- 大多标准库类都可以(n,v)构造一个含n个v的对象,注意可以省略v,会调用默认初始化(若没有,则必须给值)
- 空vector动态添加元素,`v.push_back(a)`,非常快,没必要预留空间
- ***for范围循环体内不应改变range的大小***
- 注意,标准库模板类的伴生类型,也是模板,`vector<int>::size_type`
- 下标操作必须在合法范围内,否则会产生未定义行为(尽可能使用范围for)

### 迭代器介绍

- 所有标准库容器都有迭代器,但只有少数容器支持下标操作
- begin和end返回迭代器,end指向尾元素的下一位置,当空时begin==end
- 迭代器支持`*`和`->`以及增/减/==/!=操作,因此for循环判断条件是`it!=vec.end()`
- 迭代器的类型有两种,可修改元素以及不可修改元素,如`vector<int>::iterator`和`vector<int>::const_iterator`
- begin和end返回的迭代器类型由容器是否是const决定,cbegin和cend强制返回的是const_iterator
- 任何可能改变vector对象容量的操作都会使迭代器失效
- 迭代器的距离的类型是difference_type,是带符号的

### 数组

- 数组维度必须是常量表达式,且类型不能用auto
- 数组的元素必须是对象,故不可是引用
- 数组下标通常声明为size_t类型,cstddef中定义了size_t类型,是无符号与机器相关的类型
- 数组与指针的关系基本与C一致,auto推导为指针,但decltype推导为数组
- begin和end函数可以返回数组首/尾后指针(利用模板与类型推导)
- 指针的距离是ptrdif_t类型,机器相关的有符号类型
- 同一容器对象内的迭代器比较大小/运算才是有意义的
- 数组下标运算的索引可以是有符号的
- string有一个c_str成员函数,返回指向c风格字符串的指针(当string对象发生改变时,指针可能会失效,想用时最好拷贝一份)
- vector可以用数组初始化,`vector<int> v(begin(arr),end(arr));`

### 多维数组

- 二维数组用范围for,外层必须是引用(避免退化为指针)
- 用typedef简化多维数组的类型

## 表达式

### 基础

- 重载的运算符无法改变优先级和结合律,操作数个数,求值顺序
- 左值与右值,基本与C一致,但也有许多区别,如decltype等
- 求值顺序是不确定的,不要在表达式使用副作用(修改对象)同时再次使用该对象,只有`&& || ?: ,`的求值顺序是定义的

### 算术运算符

- 所有运算对象会被转换为同一类型
- C++11规定,除法运算一律趋零截断
- 同时m%n的符号与m一致

### 逻辑与关系运算符

- 不要`if(a==true)`(提升)类型转换导致错误

### 赋值运算符

- 列表初始化时,花括号内可以为空,自动构造值初始化(内置类型为0,类类型为默认初始化)
- 列表初始化匹配不到构造函数时,会尽力执行类似C初始化器的行为

### 递增与递减运算符

- 前置版本返回对象(左值),后置版本返回对象原始值的副本(右值)
- 所以多用前置版本
- `*p++`是个好习惯

### 成员访问运算符

- `->`返回的是左值,而`.`返回与对象本身一致(左值/右值)

### 条件运算符

- 注意其优先级很低

### 位运算符

- 位运算符的短整型运算对象会被提升为int,位运算符号位是未定义的(最好只用在无符号类型上)

### sizeof运算符

- `sizeof obj.name`在C++11中可以用`sizeof class::name`代替
- 注意sizeof一个表达式并不会计算表达式的值

### 逗号运算符

- 与C一致

### 类型转换

- 两类型可以互相转换,即关联
- 大多情况,短整型运算对象会被提升为int(包括大char)
- 条件中非bool类型的运算对象会被转换为bool类型
- 初始化与赋值中,初始值/右值会被转换为变量的类型
- 算术运算(按最大的,因为补码的原因,无需考虑负数)与关系运算中,运算对象会被转换为同类型
- 函数调用中,参数会被转换
- 数组会自动转换为首元素的指针(但有许多例外,如取数组的引用)
- 0/nullptr可被转换为任意指针类型,任意指针类型可被转换为(const) void*
- 非常量可被转换为常量,但反过来不行(底层const同理)

```c++
// 显示转换
cast-name<type>(expression); // 若type是引用,则结果是左值

static_cast<type>(expression); // 只要不包含底层const即可

const_cast<type>(expression); // 只能改变运算对象的底层const

reinterpret_cast<type>(expression); // 通常为运算对象的位模式提供较低层次上的重新解释
// 如将int*转换为char*

// 关于类的按下不表
// 旧的c风格转换依旧可以用,但语义不明确
```

## 语句

### 简单语句

- 空语句`;`记的写注释
- 表达式语句(没副作用的话没意义)
- 复合语句

### 语句作用域

- 一些语句定义的变量只在语句内作用

### 条件语句

- switch语句内部定义一个被初始化(显示/隐式)变量,在其作用域内,不可被使用
- 反之,不初始化可以,或者用块分离

### 迭代语句

- 范围for语句要求range类有begin和end方法返回迭代器
- `for(declaration:expression) statement`==`for(begin=d.begin(),end=d.end();begin!=end;begin++) statement`

### 跳转语句

- 与switch语句类似,goto不可同作用域跳过变量定义
- 其它与C一致,包括标签的函数作用域

### try语句块和异常处理

- throw表达式引发异常
- try catch处理异常
- 异常类传递信息
- 异常类都有一个what成员函数,返回const char*
- 嵌套的try块中,异常如果没有对应catch则会继续向外层try块查找,全没有则转到terminate函数(终止程序)
- throw后的语句不会被执行,因此要考虑保证异常安全(如释放资源)

```c++
try {
    // 程序代码
    if(err){
        throw errClass(info); // 抛出匿名异常对象
    }
} catch (errClass e1) {
    // 处理e1的代码
} catch (errClass e2) {
    // 处理e2的代码
} catch (errClass e3) {
    // 处理e3的代码

// exception头文件
throw exception(); // 无信息

// stdexcept头文件
throw runtime_error("info"); // 只有运行时才能检查的错误
throw logic_error("info"); // 程序逻辑错误
throw domain_error("info"); // 参数对应的结果值不存在
throw invalid_argument("info"); // 无效参数
throw length_error("info"); // 试图创建一个超出该类型最大长度的对象
throw out_of_range("info"); // 使用一个超出有效范围的值
throw range_error("info"); // 结果超出合理范围
throw overflow_error("info"); // 算术运算上溢
throw underflow_error("info"); // 算术运算下溢
```

## 函数

### 函数基础

- 实参的求值顺序未定义
- 形参可以匿名,但这意味它无法被使用
- 块的自动生命周期
- 自动对象会默认初始化
- 全局对象会值初始化(包括成员)
- C++支持分离式编译

### 参数传递

- 本质是实参初始化形参,值传递,引用传递
- 尽可能使用常量引用,可以不拷贝,不修改,传递常量实参
- 引用参数可以当返回值用
- 对于传递数组退化为指针,可以判断'\0'(仅char),传递首尾指针,传递size
- 形参为数组的引用是可选项,但会固定数组大小(等着学模版)
- 若参数的类型一致,可以传递initializer_list类型实现可变参数列表(模版亦可)
- initializer_list类型的列表元素是const的,并且拷贝构造是浅拷贝,有begin,end
- 拥有这些特性的目的是传递`{"123",1,1.0}`这样的参数,使用范围for
- C语言的可变参数列表可用(便于C++访问C代码),但仅可用C++/C共同类型

### 返回类型与return语句

- void返回值函数可以隐式return(int main也行)
- 或`return;`亦可`return return_void_fun()`
- C++要求函数必能return,return的对象可以转换为返回类型即可
- 返回值初始化主调函数的一个临时对象(返回引用无需,但不应返回局部变量的引用/指针)
- 返回引用的函数可以作为左值
- 可以返回列表初始化,相当于列表初始化返回类型的临时变量
- main函数可以返回cstdlib头文件中的EXIT_SUCCESS与EXIT_FAILURE宏
- `type fun()==auto fun()->type`

### 函数重载

- 在同一作用域内,函数名相同但参数列表不同
- 注意顶层const与否依旧属于同一参数,底层const反之
- 使用常量引用的函数可以const_cast转换,作为非常量引用函数重载的返回值
- 函数匹配/重载确定时可能发生最佳匹配,无匹配错误,二义性调用错误(多个可匹配,但都不完美)
- 注意局部函数声明/变量定义覆盖***所有***同名全局函数(C++总是先查找名字)

### 特殊用途语言特性

- 默认实参(注意参数排布顺序)
- 默认实参可以分开写在声明/定义中(但是不可以覆盖)
- 非局部变量的任意表达式可以作为默认实参
- 内联函数(inline),注意许多编译器不支持内敛递归,且编译器不一定响应inline请求
- constexpr函数是特殊的inline(编译期求值),所有参数与返回值都是字面值类型,函数体中有且只有一条return语句
- 但是,我们可以在constexpr函数返回一个非常量(此时显然不可再用于需常量位置)
- inline函数和constexpr函数应定义在头文件中
- cassert头文件assert宏,断言表达式真值为1
- NDEBUG宏用于要求不调试(可禁止assert),我们可以借用定义自己的debug行为

```C++
// 存放名字的const char数组
__FILE__ // 文件名
__LINE__ // 行号
__TIME__ // 编译时间
__DATE__ // 编译日期
__func__ // 函数名
```

### 函数匹配

- 首先确定候选函数
- 然后进行可行函数(数量够,类型可转换),否则无匹配错误
- 之后依次检查参数匹配,其中有每个参数不劣于其他可行函数且至少一个好于其他可行函数的唯一可行函数为最佳匹配,否则二义性错误

```C++
// 1 类型相同,数组转换指针
// 1.5 顶层const           // 都是精确匹配
// 2 底层const转换 //只能用于非const转换为const
// 3 类型提升
// 4 算术类型转换(除了提升)与指针转换(0/nullptr/void*)
// 5 类类型转换
```

- 注意提升会直接到int

### 函数指针

- decltype(fun)得到函数类型

## 类

### 定义抽象数据类型

- 成员函数必须在类内声明,但可以在类内定义(隐式inline),也可以在类外定义
- this是一个隐式的const指针,指向调用该成员函数的对象(不可自定义this)
- 将const放在参数列表后,声明常量成员函数,本质上是声明隐式的this指针的底层const
- 编译器处理类会先编译成员变量,再编译成员函数(无所谓顺序,一律可以使用)
- 类外定义的成员函数需要加上classname::
- this可以返回,` *this `是引用
- 把非成员函数的接口与类置于同一头文件中
- 构造函数显然没有返回值,且不可为const
- 合成的默认构造函数,类内初始值+默认初始化,`classnsme()=default;`即可
- `classnsme(...):name(...),name2(...){}`初始值列表
- 合成的拷贝,赋值与析构函数会对每个成员进行拷贝,赋值与销毁

### 访问控制与封装

- class的默认访问权限是private,struct是public,这是唯一区别
- 类内可以声明友元,使其访问类的private成员(这不是函数声明,函数需要再声明)

### 类的其它特性

- 类内可以定义类型别名
- 类内可以声明mutatic成员,无论对象/函数是const,它都可被修改
- 显然const函数return *this是常量引用
- 类可前向声明,为定义前是不完全类型,以供类内加入自己指针类型的成员等情况
- 类可以声明类友元,友元函数可以声明在类内(隐式内联)
- 注意,声明友元的其它类的成员函数,必须在类内前向声明友元函数,声明类,声明友元,定义函数

### 类的作用域

- 在类外定义函数,加上类名::后,其它参数不需要再加,但返回类型在它前面,需要加(如果是类内类型)
- 先处理成员变量的声明,后函数体
- 类内类型名应在开始处,否则可能与外界类型名冲突
- 成员变量不怕冲突,与其它位置的规则类似(当然我们不建议)
- `::name`代表全局的(反遮蔽)

### 构造函数再探

- 构造函数初始化或者赋值,影响取决于成员的默认初始化
- const,引用,无默认初始化的成员必须通过构造函数初始化列表进行初始化
- 若构造函数的每个形参都有默认实参,则构成了默认构造函数
- 委托构造函数`classname(...):classname(调用另一个构造){}`

```
默认构造:
块作用域内定义无初始值的非静态变量
类使用构造函数时,没初始化该成员,会对其进行默认初始化
注意默认构造的定义应为
classname name;
而非
classname name();// 函数声明

值初始化:
数组初始化时,提供的值比成员少,则剩余成员进行值初始化
无初始值局部静态变量
classname name();
```

- 能仅使用一个实参的构造函数定义了隐式转换
- 这种转换只能隐式进行一次(不可连续)
- 使用explicit关键字修饰函数阻止隐式转换,同时也阻止了拷贝初始化(使用=)
- 但可以使用强制类型转换
- 聚合类即为没有构造函数,成员都是public,无类内初始值,无基类,无虚函数的类
- 聚合类大抵只能{}初始化,它显然有许多的缺陷
- 但聚合类是字面值类型
- 非聚合类的字面值常量类应满足,有constexpr构造函数,所有成员为字面值类型,若有初始值应为字面值常量/constexpr构造,必须使用析构函数的默认定义
- constexpr构造函数是constexpr的,构造函数的,显然对成员递归的

### 类的静态成员

- 静态成员函数不可使用this,定义与其它成员函数一致(类外定义不可有static)
- `type classname::name = ...(可以是成员函数)`
- 静态成员变量可以有类内初始值,但必须是常量表达式且type是字面值类型(还是得定义一下)
- 静态成员可以作默认实参
- 静态成员可以是不完全类型(前向声明)
- 静态成员的类型可以是其类类型

# C++标准库

## IO库

### 
# Shell 文本处理

## 参考资料

* [命令行的艺术](https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md) - 指导向 - 4

## 文本基本操作

```shell
sort file/stdio # 排序 -n/r/f/k 按数字大小 / 反向排 / 忽略大小写 / 排每行的第 n 个字段
uniq file # 去重复打印 -d/c 只显示重复 / 显示行重复次数
command | tee filename # 重定向加打印 -af add / 覆盖
* cut -f n -d 'c' file # 按 c 为分割提取每行第 n 个字段
* paste file1 file2 # 按行拼接
* join f1 f2 # 若第一个字段相同, 拼接这行 -a1/2 不匹配的按谁来
```

* [diff 输出的格式](https://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html)

```shell
diff fromfile tofile # 文本对比-bBi 忽略连续空格/忽略空白行/忽略大小写 

cmp -l file1 file2 # 对比二进制 返回第一个不同

patch -pn # 根据diff输出文件来更改
patch -R -pn # 还原
```

## 正则

* `^` 指定后一个模式匹配字符串的开始
* `$` 指定前一个模式匹配字符串的结束
* `*` 匹配任意长度的字符
* `+` 匹配至少一个字符
* `?` 匹配零或一个字符
* `{n}` 匹配 n 个 `{n}` 前面的模式
* `{n,}` 匹配至少 n 个 `{n,}` 前面的模式
* `{n,m}` 匹配 n 到 m 个 `{n,m}` 前面的模式
* `[]` 匹配任意字符中的一个
* `[^]` 匹配任意字符中的一个 (取反)
* `|` 逻辑或, 连接两个模式
* `()` 分组
* `\\` 转义
* `模式一(?=模式二)` 正向前瞻, 匹配模式二前的模式一, 但不获取匹配结果
* `模式一(?!模式二)` 负向前瞻
* `(?<=模式二)模式一` 正向后顾
* `(?<!模式二)模式一` 负向后顾
* `[:classname:]` 匹配字符类
    * `[:alnum:]` 字母和数字
    * `[:alpha:]` 字母
    * `[:blank:]` 空格和制表符
    * `[:cntrl:]` 控制字符
    * `[:digit:]` 数字
    * `[:graph:]` 可打印字符
    * `[:lower:]` 小写字母

## `grep`

```shell
grep [option] pattern file # 查找文件中匹配的行

# -A<显示行数>:除了显示符合范本样式的那一列之外,并显示该行之后的内容 
# -B<显示行数>:除了显示符合样式的那一行之外,并显示该行之前的内容 
# -C<显示行数>:除了显示符合样式的那一行之外,并显示该行之前后的内容 
# -v:显示不被 pattern 匹配到的行,相当于 [^] 反向匹配
# -i:忽略大小写
# -n:显示行号
```

## `sed`

```shell
sed [options] 'command' file(s) # 逐行编辑
sed [options] -f scriptfile file(s) # 从文件中读取命令

# -n:不输出模式空间内容到屏幕,即不自动打印,只打印匹配到的行
# -i:直接将处理的结果写入文件

# command : 地址操作内容

# 不给地址:对全文进行处理
# n 指定的行
# 1,n 指定的行范围

sed -n '1~2p'  # 只打印奇数行  (1~2 从第1行,一次加2行)
sed -n '2~2p'  # 只打印偶数行

# d:删除模式空间匹配的行,并立即启用下一轮循环
# p:打印当前模式空间内容,追加到默认输出之后
# a:在指定行后面追加文本,支持使用 \n 实现多行追加
# i:在行前面插入文本,支持使用 \n 实现多行追加
# c:替换行为单行或多行文本,支持使用 \n 实现多行追加
# !:模式空间中匹配行取反处理
# s///:查找替换,支持使用其它分隔符, s@@@ , s### ,加 g 表示行内全局替换
```

## `awk`

* awk 使用 AWK 语言, 我实在不喜欢

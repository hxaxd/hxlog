### 文本基本操作
- sort file/stdio 排序 -n/r/f/k 按数字大小/反向排/忽略大小写/排每行的第n个字段
- uniq file 去重复打印 -d/c 只显示重复/显示行重复次数
- command | tee filename 重定向加打印 -af add/覆盖
- cut -f n -d 'c' file 按c为分割提取每行第n个字段
- paste file1 file2 按行拼接
- join f1 f2 若第一个字段相同,拼接这行 -a1/2 不匹配的按谁来

关于[diff输出的格式](https://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html)
```bash
diff文本对比
-bBi 忽略连续空格/忽略空白行/忽略大小写 
fromfile 
tofile

cmp -l file1 file2 对比二进制 返回第一个不同

patch -pn 根据diff输出文件来更改
patch -R -pn还原
```

### 正则
```
.匹配任意单个字符,不能匹配空行
[] 匹配指定范围内的任意单个字符
[^] 取反
[:alnum:] 或 [0-9a-zA-Z]
[:alpha:] 或 [a-zA-Z]
[:upper:] 或 [A-Z]
[:lower:] 或 [a-z]
[:blank:] 空白字符 (空格和制表符)
[:digit:] 十进制数字 或[0-9]
[:xdigit:]十六进制数字
*  匹配前面的字符任意次,包括0次
.*  任意长度的任意字符,不包括0次
\?  匹配其前面的字符0 或 1次
\+  匹配其前面的字符至少1次
\{n\}  匹配前面的字符n次
\{m,n\}  匹配前面的字符至少m 次,至多n次
^  行首锚定,用于模式的最左侧
$  行尾锚定,用于模式的最右侧 
```
```bash
grep [option] pattern file
-A<显示行数>:除了显示符合范本样式的那一列之外,并显示该行之后的内容 
-B<显示行数>:除了显示符合样式的那一行之外,并显示该行之前的内容 
-C<显示行数>:除了显示符合样式的那一行之外,并显示该行之前后的内容 
-c:统计匹配的行数
-e :实现多个选项间的逻辑or 关系
-E:扩展的正则表达式 
-v:显示不被pattern 匹配到的行,相当于[^] 反向匹配
'c'  
filename  
```
```bash
sed [options] '[地址定界] command' file(s)

-n:不输出模式空间内容到屏幕,即不自动打印,只打印匹配到的行
-e:多点编辑,对每行处理时,可以有多个Script
-f:把Script写到文件当中,在执行sed时-f 指定文件路径,如果是多个Script,换行写
-r:支持扩展的正则表达式
-i:直接将处理的结果写入文件


不给地址:对全文进行处理
n 指定的行
n1,n2
sed -n '1~2p'  只打印奇数行  (1~2 从第1行,一次加2行)
sed -n '2~2p'  只打印偶数行

d:删除模式空间匹配的行,并立即启用下一轮循环
p:打印当前模式空间内容,追加到默认输出之后
a:在指定行后面追加文本,支持使用\n实现多行追加
i:在行前面插入文本,支持使用\n实现多行追加
c:替换行为单行或多行文本,支持使用\n实现多行追加
!:模式空间中匹配行取反处理
s///:查找替换,支持使用其它分隔符,如:s@@@,s###,加g表示行内全局替换
```

awk使用AWK语言,我实在不喜欢,处理文本不如自己拿py写一个,或者简单的用choose啥的

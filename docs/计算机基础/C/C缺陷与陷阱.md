# C

- c 缺陷与陷阱 内容古老但不会过时 (就是以现代教育资源与编程经验来看, 有点浅显) 4

## 词法陷阱

- 注意 `==` 与 `=`, 如果判断条件用 `=` 请使用 `()` 如 `(ch=getchar())`
- 注意位运算与逻辑运算
- 词法分析中的贪心法 (尽可能使一个 token 长) 如 `a---b` 等效 `(a--)-b`

## 语法陷阱

- c 语言的声明 (在 c 的几乎所有经典当中都有对复杂声明的探讨, 不赘述)
- 注意运算符的优先级 (你也许可以找到一些规律记住它们)
- 注意;的错误会改变 if else 的行为
- 灵活使用 switch 语句当中不会自动 break 的特性
- 注意 else 的配对

## 语义陷阱

- C 语言只有一维数组, 并且我们只能获得长度以及首元素的地址, 所有数组的其他操作本质上都是对于指针的操作
- 想清楚内存空间, 合理的 free, 防止内存泄漏, 是否分配成功, 字符串多一个字节
- 数组传进函数的信息缺失
- 不要解引用 NULL, 相应的也可以推广到垃圾值以及已经 free 的地址
- 注意边界, 写成 x >= begin && x < end, 这有不少理解与计算的好处
- 求值顺序/序列点
- a>INT_MAX-b 可以验证 a+b 是否溢出
- 返回整型的函数没有 return, 会返回垃圾值

## 链接

- 善用 lint 检查链接时错误
- extern 仅是引用
- static 避免命名冲突
- 没 include 也可以用库函数, 只是缺少声明而已
- 在头文件中 extern 全局变量, 在任何地方 include 它是优秀的方法

## 库函数

不记录

## 预处理器

该部分的内容上面或多或少有所提及, 包括把参数以及最外(), 以及不要让参数中有副作用, 不要在宏中使用 if, 不要用宏替换指针类型

## 可移植性缺陷

- 权衡兼容与新特性的便利
- 标识符的限制
- 逻辑移位与物理移位
- 整型的符号与大小 (使用 unsigned char)
- 在新的实现当中, realloc 可以把已经 free 的内存块重新分配大小

很多过时内容没有记录

不多探究8086特性
## 基础知识
1. 汇编语言有三类指令：汇编指令，对应机器码；伪指令，编译器执行，不对应机器码；其他符号，如+/-等，有编译器识别，不对应机器码
2. cpu通过总线传递地址信息，控制信息（读写，器件），数据信息
3. 这三种总线的宽度决定cpu单次传递信息的量
4. 存储器分RAM（随机存储器）和ROM（只读存储器）
5. CPU在操作它们的时候将其总的看作一个内存地址空间

## 寄存器
1. CPU中有运算器，控制器，寄存器，内部总线

指令： 
```8086
reg指代寄存器，n指代数值

mov reg,reg/n ;相当于reg=reg/n 称为传送指令
add reg,reg/n ;相当于reg+=reg/n

两个部分的位数必须一致，超过CPU位数将被舍去
```
2. 8086依赖段地址与偏移地址实现20位寻址能力
3. CS寄存器：代码段寄存器，存放代码段的段地址;IP寄存器：指令指针寄存器，存放当前指令的偏移地址,CS:IP指向的地址即当前指令的地址
4. CPU仅将CS:IP指向的地址的内容看作指令，执行过后，IP自动加指令的长度，CPU运作伊始，CS:IP指向的地址为FFFF0h

指令
```8086
jmp n1:n2 ;相当于 CS=n1,IP=n2
jmp reg ;相当于 IP=reg
```

## 寄存器（内存访问）

指令
```8086
mov reg,[n] ;相当于reg=DS:[n] 
mov [n],reg ;相当于 DS:[n]=reg
mov ds,reg ;相当于 DS=reg
;以此类推，DS，通用寄存器，内存单元，三者可互相mov
;但是不可将数值直接送入DS

;sub 减法与add指令类似
;要求左是存储器/寄存器，右是存储器/寄存器或数值，但不可是段寄存器
```
1. DS存储数据段的段地址
指令
```8086
push reg 相当于 SP-=2,SS:SP=reg
pop reg 相当于 reg=SS:SP,SP+=2
这解释了堆栈向下生长
```
2. SS存储堆栈段的段地址（mov时同DS），SP存储偏移量
3. 没人帮你防止堆栈超界

## 第一个程序
伪指令
```8086
assume cs:name ;使cs存储name段地址
name segment ;段开始
...
name ends ;段结束
end ;编译结束
```
1. 某个command将cpu的控制权交给程序后，运行结束必须返回，利用mov与int实现，后文详叙
2. cx存储程序的长度
3. 程序加载后ds=程序位置，前256字节是PSP（进行DOS与程序通信）

## [BX]和loop指令
指令
```8086
;[bx] 就是将bx的值作为偏移值

inc reg ;相当于 reg++

name:.... ;这里已经执行一次了
loop name ;相当于if(--cx) goto name，注意这里跳回去了cx减一次
;s编译后回变成标记指令的地址
```
1. 汇编源程序中字面量不能以字母开头，16进制是0aaaah的形式
2. 编译器认为[值]（debug里这么写入）等效值，ds:[值]才正确，这就是段前缀


## 包含多个段的程序
```8086
dw 0aaaah,09999h....
name:
end name;end指示CS:IP的值
;定义字型数据，物理位置考虑在代码段中的相对位置，我们往往选择开头
```
1. 代码段开头存储在可执行文件的描述信息当中
2. 定义左右段就正常定义就行，完全是我们自己安排，真自由，真他妈的爽
3. 定义的段名在程序当中引用会被认为是段的地址

## 更灵活的定位内存地址的方法
```8086
and reg,n;按位与
or reg,n;按位或

db 'aaaa'
db 61h,61h,61h,61h
;db定义字节型数据

;[bx+n]内存单元的新表示方式，也可以写成n[bx]
```
1. ASCII值 大小写字母的区别是二进制第五位为0/1
2. 寄存器si，di往往作为偏移量
3. 往往在内存当中使用栈段暂时保存寄存器的值

## 数据处理的两个基本问题
```8086
[command] word/byte ptr [bx],... ;指定内存单元长度 

[bx+n+si]->[bx].n[si]

div reg/内存单元;这是除数，被除数的位数是其两倍，在reg存前16位，dx不存/后16位，结果与除数位数一致，al/reg为商，ah或dx为余数

dd 值,... ;定义双字型数据


db/dw/dd n dup (1,2,3,) ;定义n个重复123->1,2,3,1,2,3,1,2,3
```
1. 只有bx，bp，si，di四个寄存器可以做偏移量，且bx，bp或者si，di互不能相加，bp的默认段地址是ss
2. 数据读取的位置只能是内存，寄存器或者端口（后详叙）
3. 指令中的数据叫立即数
4. 有些指令默认长度，如push，pop

## 转移指令的原理
```8086
command reg,offset name;取得name的偏移地址(IP)

nop 空指令

jmp short name ;短转移 依赖在IP上加减（补码表示）来实现
jmp near name ;近转移 同理 上面8位，这个16位

jmp far ptr name ;远转移 在机器码中是IPCS的顺序，低地址->高地址

jmp reg;前已叙

jmp word ptr 16位内存; IP=
jmp dword ptr 32位内存; 按IPCS赋值

jcxz name; 相当于if(!cx) jmp short name
;前面的loop 实际上也是短转移

dec reg; reg--
```
1. 改变CS:IP（段间转移）/IP（段内转移）的指令叫转移指令
2. 段内转移分短转移/近转移，-128~127/-32768~32767
3. 亦分无条件转移/条件转移/循环/过程/中断
4. 段内位移的意义是不会对程序段在内存中的偏移地址有严格的限制（没理解，我觉得偏移地址不会变化呀）

## CALL和RET指令
```8086
ret ; pop IP
retf ; pop IP,pop CS

call name; push IP，jmp near name
call far ptr name; push CS,push IP,jmp far ptr name

call reg; push IP,IP=reg(jmp reg)

call word ptr 内存; push IP,IP=16位内存(jmp word ptr 内存)
call dword ptr 内存; push IP,IP=内存(jmp dword ptr 内存)

mul reg/内存 ;8位另一个乘数在al，16位则在ax，结果在ax或ax+dx
```
1. 高级语言的函数显然就是这么实现的，在汇编当中参数较少情况下，我们可以使用寄存器传递参数与结果，但是我们都知道用栈来传递是不错的选择
2. 显然在子程序的开始的时候，我们要把它使用的寄存器的值保存起来，以防止影响主程序的运行，这个过程往往也是用栈实现的
3. 小心除法的溢出，当然我们可以用数学方法将一个会溢出的除法拆分成多个不会溢出的除法

## 标志寄存器
1. 标志寄存器有下三种作用：存储相关指令的执行结果；为CPU执行相关指令提供行为依据；用来控制CPU的相关工作方式，它们存储的叫PSW（程序状态字）例如flag
2. flag寄存器是按位起作用的，16位使用了0 2 4 6 7 8 9 10 11
3. 第六位，ZF，记录相关指令执行后的结果是否为0，如果为0，那么它为1，反之为0，相关指令往往是运算指令，包括逻辑与算术(下同)
4. 第二位，PF，记录相关指令执行后的结果汉明重量是否为偶数，如果为偶数，那么为1，反之为0
5. 第七位，SF，记录相关指令执行后的结果是否为负数，如果为负数，那么为1，反之为0（其实就是结果最高位）
6. 第零位，CF，记录进位与借位，对无符号运算有效
7. 第十一位，OF，记录相关指令执行后的结果是否溢出，对有符号运算有效

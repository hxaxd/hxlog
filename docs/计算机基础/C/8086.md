不多探究8086特性,讲的有点难受,因为掌握的信息不全,很多东西都没解释,不过因为总体难度不是很大,所以这个位置学我觉得还是很好的

总结:  
- 围绕CPU的硬件模型的基础如CPU如何执行指令,与其他硬件如何通信,内存地址空间,中断的实现等 
- 主要使用的寄存器以及相对应的汇编指令, 这帮助我们了解高级语言实际是如何实现的  (什么指令才是真正的1时间)
- 堆栈,地址偏移等程序设计当中常用的思想的底层实现

## 基础知识
- 汇编语言有三类指令:汇编指令,对应机器码;伪指令,编译器执行,不对应机器码;其他符号,如+/-等,有编译器识别,不对应机器码
- cpu通过总线传递地址信息,控制信息 (读写,器件),数据信息
- 这三种总线的宽度决定cpu单次传递信息的量
- 存储器分RAM (随机存储器)和ROM (只读存储器)
- CPU在操作它们的时候将其总的看作一个内存地址空间

## 寄存器
- CPU中有运算器,控制器,寄存器,内部总线

指令: 
```8086
reg指代寄存器,n指代数值

mov reg,reg/n ;相当于reg=reg/n 称为传送指令
add reg,reg/n ;相当于reg+=reg/n

两个部分的位数必须一致,超过CPU位数将被舍去
```
- 8086依赖段地址与偏移地址实现20位寻址能力
- CS寄存器:代码段寄存器,存放代码段的段地址;IP寄存器:指令指针寄存器,存放当前指令的偏移地址,CS:IP指向的地址即当前指令的地址
- CPU仅将CS:IP指向的地址的内容看作指令,执行过后,IP自动加指令的长度,CPU运作伊始,CS:IP指向的地址为FFFF0h

指令
```8086
jmp n1:n2 ;相当于 CS=n1,IP=n2
jmp reg ;相当于 IP=reg
```

## 寄存器 (内存访问)

指令
```8086
mov reg,[n] ;相当于reg=DS:[n] 
mov [n],reg ;相当于 DS:[n]=reg
mov ds,reg ;相当于 DS=reg
;以此类推,DS,通用寄存器,内存单元,三者可互相mov
;但是不可将数值直接送入DS

;sub 减法与add指令类似
;要求左是存储器/寄存器,右是存储器/寄存器或数值,但不可是段寄存器
```
- DS存储数据段的段地址
指令
```8086
push reg 相当于 SP-=2,SS:SP=reg
pop reg 相当于 reg=SS:SP,SP+=2
这解释了堆栈向下生长
```
- SS存储堆栈段的段地址 (mov时同DS),SP存储偏移量
- 没人帮你防止堆栈超界

## 第一个程序
伪指令
```8086
assume cs:name ;使cs存储name段地址
name segment ;段开始
...
name ends ;段结束
end ;编译结束
```
- 某个command将cpu的控制权交给程序后,运行结束必须返回,利用mov与int实现,后文详叙
- cx存储程序的长度
- 程序加载后ds=程序位置,前256字节是PSP (进行DOS与程序通信)

## [BX]和loop指令
指令
```8086
;[bx] 就是将bx的值作为偏移值

inc reg ;相当于 reg++

name:.... ;这里已经执行一次了
loop name ;相当于if(--cx) goto name,注意这里跳回去了cx减一次
;s编译后回变成标记指令的地址
```
- 汇编源程序中字面量不能以字母开头,16进制是0aaaah的形式
- 编译器认为[值] (debug里这么写入)等效值,ds:[值]才正确,这就是段前缀


## 包含多个段的程序
```8086
dw 0aaaah,09999h....
name:
end name;end指示CS:IP的值
;定义字型数据,物理位置考虑在代码段中的相对位置,我们往往选择开头
```
- 代码段开头存储在可执行文件的描述信息当中
- 定义左右段就正常定义就行,完全是我们自己安排,真自由,真他妈的爽
- 定义的段名在程序当中引用会被认为是段的地址

## 更灵活的定位内存地址的方法
```8086
and reg,n;按位与
or reg,n;按位或

db 'aaaa'
db 61h,61h,61h,61h
;db定义字节型数据

;[bx+n]内存单元的新表示方式,也可以写成n[bx]
```
- ASCII值 大小写字母的区别是二进制第五位为0/1
- 寄存器si,di往往作为偏移量
- 往往在内存当中使用栈段暂时保存寄存器的值

## 数据处理的两个基本问题
```8086
[command] word/byte ptr [bx],... ;指定内存单元长度 

[bx+n+si]->[bx].n[si]

div reg/内存单元;这是除数,被除数的位数是其两倍,在reg存前16位,dx不存/后16位,结果与除数位数一致,al/reg为商,ah或dx为余数

dd 值,... ;定义双字型数据


db/dw/dd n dup (1,2,3,) ;定义n个重复123->1,2,3,1,2,3,1,2,3
```
- 只有bx,bp,si,di四个寄存器可以做偏移量,且bx,bp或者si,di互不能相加,bp的默认段地址是ss
- 数据读取的位置只能是内存,寄存器或者端口 (后详叙)
- 指令中的数据叫立即数
- 有些指令默认长度,如push,pop

## 转移指令的原理
```8086
command reg,offset name;取得name的偏移地址(IP)

nop 空指令

jmp short name ;短转移 依赖在IP上加减 (补码表示)来实现
jmp near name ;近转移 同理 上面8位,这个16位

jmp far ptr name ;远转移 在机器码中是IPCS的顺序,低地址->高地址

jmp reg;前已叙

jmp word ptr 16位内存; IP=
jmp dword ptr 32位内存; 按IPCS赋值

jcxz name; 相当于if(!cx) jmp short name
;前面的loop 实际上也是短转移

dec reg; reg--
```
- 改变CS:IP (段间转移)/IP (段内转移)的指令叫转移指令
- 段内转移分短转移/近转移,-128~127/-32768~32767
- 亦分无条件转移/条件转移/循环/过程/中断
- 段内位移的意义是不会对程序段在内存中的偏移地址有严格的限制 (没理解,我觉得偏移地址不会变化呀)

## CALL和RET指令
```8086
ret ; pop IP
retf ; pop IP,pop CS

call name; push IP,jmp near name
call far ptr name; push CS,push IP,jmp far ptr name

call reg; push IP,IP=reg(jmp reg)

call word ptr 内存; push IP,IP=16位内存(jmp word ptr 内存)
call dword ptr 内存; push IP,IP=内存(jmp dword ptr 内存)

mul reg/内存 ;8位另一个乘数在al,16位则在ax,结果在ax或ax+dx
```
- 高级语言的函数显然就是这么实现的,在汇编当中参数较少情况下,我们可以使用寄存器传递参数与结果,但是我们都知道用栈来传递是不错的选择
- 显然在子程序的开始的时候,我们要把它使用的寄存器的值保存起来,以防止影响主程序的运行,这个过程往往也是用栈实现的
- 小心除法的溢出,当然我们可以用数学方法将一个会溢出的除法拆分成多个不会溢出的除法

## 标志寄存器
- 标志寄存器有下三种作用:存储相关指令的执行结果;为CPU执行相关指令提供行为依据;用来控制CPU的相关工作方式,它们存储的叫PSW (程序状态字)例如flag
- flag寄存器是按位起作用的,16位使用了0 2 4 6 7 8 9 10 11
- 第六位,ZF,记录相关指令执行后的结果是否为0,如果为0,那么它为1,反之为0,相关指令往往是运算指令,包括逻辑与算术(下同)
- 第二位,PF,记录相关指令执行后的结果汉明重量是否为偶数,如果为偶数,那么为1,反之为0
- 第七位,SF,记录相关指令执行后的结果是否为负数,如果为负数,那么为1,反之为0 (其实就是结果最高位)
- 第零位,CF,记录进位与借位,对无符号运算有效
- 第十一位,OF,记录相关指令执行后的结果是否溢出,对有符号运算有效
- inc,loop,不会影响CF,将它们替换成add要小心
```8086
adc reg,reg;相当于add reg,reg 的结果加CF
;实现两步相加,使用一个Add进行低位加法,再一个ADC进行高位加法
;最后存在两个16位当中就能实现32位的加法运算

sbb reg ;同理

cmp reg,reg; 相当于sub reg,reg 但不存在reg中,影响以上5个位
; 可以反映两个寄存器中值的大小关系

; 根据比较结果进行转移是常见的,根据无符号数和有符号数检查不同的位

; 无符号数检查zf,cf
je      zf          等于
jne     !zf         不等于
jb      cf          小于
jnb     !cf         小于等于
ja      !cf&&!zf    大于
jna     cf||zf      大于等于

; 有符号数检查sf,of,zf 不举例

movsb; mov es:[di],byte ptr ds:[si],if(!df) si++,di++,else si--,di--
movsw; mov es:[di],word ptr ds:[si],if(!df) si+=2,di+=2,else si-=2,di-=2

rep movsb;name:movsb,loop name

cld/std;df=0/df=1

pushf/popf; push/pop flag
```
- 第十位,DF,控制相关操作后si/di的增减

## 内中断
- 中断是CPU的一种异常处理机制,放下手中的事直接去处理中断信息
- 中断类型码记录了中断信息来源,大概有四种内中断,0除法错误,1单步执行,4into,n int n
- 对终中断信息的处理是需要编写的程序,但是CPU怎么找到这个程序的位置呢?
- 内存当中有一个中断向量表对应256的中断源每一个的处理程序入口
- 8086的在内存从零开始的位置,每个表项显然占两个字节 (CS:IP)
- 获取类型码之后,要把标志寄存器和当前指令位置压入栈中,以便在中断处理结束后恢复现场,不过flag压入之后要将其第八位和第九位分别是TF和IF置0,原因后详叙  
`iret; 以上过程的逆过程也就是中断程序的返回指令`
- 王爽看那个向量表里有空位就把自己写的那个中断程序往那里塞太邪恶了啊,注意这种程序不仅要保护代码段,固定的数据段也得保护哦
- 编译器可以计算常数的加减乘除,当然也包括offset
- 执行完事一条指令一旦TF为0,就是单步执行中断
- CPU有的时候也不响应中断,就比如说我要设置一下SSSP的位置,不管你是啥都等等我,因为你还不知道那个现场信息往哪保存呢

PS:不同的CPU,这个现场信息的位置不一样,有的是专门有系统堆栈,但是8086就是压入目前程序堆栈,所以程序必须要有堆栈,且中断必须发生在设置完sssp之后

## int指令
```
int n; 中断过程同上,就是调用N号中断程序

mov ax,4c00h
int 21h
; 4c表示这是该中断的程序返回功能,然后零是返回值
```
- BIOS和DOS提供一些中断例程,开机后,CPU初始化执行BIOS中的硬件检测和初始化程序将入口地址登记在中断向量表,因为程序都固化在ROM当中,然后调用int 19H进行操作系统的引导,操作系统也会放一些中断例程
- 其提供的程序往往还包含多个子程序,根据中断时候寄存器中保存的值而决定运行哪些程序

## 端口
- 在上面我们使用CPU读写寄存器与内存单元,但事实上CPU还可以读写各种非存储器的芯片中的寄存器,端口
- 端头地址和内存地址一样,通过地址总线来传送,8086端口地址范围是0～65535
```
in ax/al,nh ;从n号端口读,严格8位用AL,16位AX
out nh,ax,al ;同理

;cmos arm有两个端口,70h/71h
; 分别存放地址和数据
; 使用方法就是将要读取的地址,放入70H,然后从71H中读出

shl ax,1; 相当于ax<<1, 移除的最后位会写入CF,最低位补0
shr ax,1; 相当于ax>>1, 移除的最后位会写入CF,最高位补0
```

## 外中断
- 相关芯片将外设的输入对应的中断信息发给CPU,CPU执行完当前指令后检测到中断信息,引发中断过程
- 可屏蔽终端是CPU可以不响应的外中断,如果IF等于1,CPU执行完当前指令之后响应中断,否则不响应,这就是中断过程中将IF置零的原因
```
sti; 开中断
cli; 关中断
; 当然你也可以写一个响应中断的中断例程
```
- 反之则是不可屏蔽中断,8086不可屏蔽中断的类型码固定为2 (稀少)
- 8086cpu键盘的输入,按下键和松开键,产生一个扫描码到达相应端口,引发中断产生相对应的字符码或者是状态字节 (对应控制键和切换键写入内存当中相应单元)字符码会送入BIOS键盘缓冲区,在缓冲区当中可以存储15个键盘输入,一个键盘输入用一个字存放,高位字节存放扫描码,低位字节存放字符码

## 直接定址表
```
seg name;name的段地址

a db 1,2,3,4,5,6,7,8,9,10
b dw 1,2,3,4,5,6,7,8,9,10; 这么声明内存空间,标号将带有长度信息
;b->word prt CS:8
```
- 所谓直接定值表,就是将数据对应地址的偏移 (哈希)

## 使用BIOS进行键盘输入和磁盘读写

介绍了这两个功能的实现
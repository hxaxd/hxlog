1. c缺陷与陷阱  
2. c专家编程  
4. 汇编语言

# 个人汇总
## 指针  
   
就c语言的数组与函数，我有一定理解，总结如下  
a[i]==i[a]==*(a+i)  
()为根据地址执行指令

|type&action|object|function|array|
|:----:|:----:|:----:|:----:|
|值/name|值|函数地址|首元素地址|
|&|变量地址|函数地址|数组地址|
|*|值所代表的地址上的值|函数地址|首元素|
|sizeof|type'size|no|type'size*length|

## c与c++
1. C++认为int fun()==int fun(void),C认为只是省略了
2. C的char常量'a'是int类型，因此'ABCD'不会报错
3. C++的const变量默认是内部链接，可以用extern改为外部链接
4. C++const变量可以初始化const，C不行
5. C++严格使用枚举，C将之认定为整型
6. C++原生宽字符，C原生复数
7. C++内联函数不可重复定义
8. C++11没有初始化器，restric，VLA，伸缩型数组成员，可变数量参数的宏
9. c标记名与变量名可以重复，c++不行
10. molloc在C++中必须强制类型转换
11. C警告将const指针赋给普通指针，C++error/C++可以用const整型声明数组大小
12. C++可以type(name)强制类型转换
13. C++不可调用main()现在C也不行了
14. C可以char[3]="asd"

以上受时间影响，仅供参考

## 声明

构成：type name+修饰符
不讨论const extern等

修饰符有三种：
1. 后置有[]与()，优先级相同，自左向右结合  
当然，这是对规律的总结，实际上它们不是运算符，没有优先级与结合律
2. 前置* 优先级小于后置，因此我们声明数组与函数的指针必须使用()

将修饰符与name结合，理解它的类型  
最后你会发现，如果你将以上三种符号认为是运算符形式，那么你得到的是一个表达式，而前面的type就是表达式值的类型

## 链接数组

 这是一个值得被单独拿出来说的事情  
 在链接阶段跨文件使用一个全局数组的时候  
 不能extern一个指针（反之函数形参可以）  
 因为链接变量是指出a的地址（由另一个文件定义），当你把一个数组声明为对应元素的指针，会认为数组地址存储的那个值是指针的值，本质原因是数组的值虽然是首元素的指针，但没有使用额外的空间存储，程序会访问未知的内存

# C缺陷与陷阱

内容如标题所示，值得任何人去看的一本书，内容古老但绝不会过时  
精华集中在前四章，之后的章节受限于时代因素  

## 词法陷阱
1. 注意==与=，如果判断条件用=请使用()如(ch=getchar())
2. 注意位运算与逻辑运算
3. 词法分析中的贪心法（尽可能使一个token长）如a---b等效(a--)-b

## 语法陷阱
1. c语言的声明（在c的几乎所有经典当中都有对复杂声明的探讨，不赘述）
2. 注意运算符的优先级（你也许可以找到一些规律记住它们）
3. 注意;的错误会改变if else的行为
4. 灵活使用switch语句当中不会自动break的特性
5. 注意else的配对

## 语义陷阱
1. C语言只有一维数组，并且我们只能获得长度以及首元素的地址，所有数组的其他操作本质上都是对于指针的操作
2. 想清楚内存空间，合理的free，防止内存泄漏，是否分配成功，字符串多一个字节
3. 指针传进函数的信息缺失
4. 不要解引用NULL（在写下这段文字的前两天因为这个极其常见的错误全世界瘫痪相当一部分win电脑）  
相应的也可以推广到垃圾值以及已经free的地址
5. 注意边界，写成 x >= begin && x < end,这有不少理解与计算的好处
6. 作者讨论了一个叫求值顺序的东西，但也许它有一个名字叫序列点
7. a>INT_MAX-b可以验证a+b是否溢出
8. 返回整型的函数没有return，会返回垃圾值

## 链接
1. 善用lint检查链接时错误
2. extern仅是引用
3. static避免命名冲突
4. 没include也可以用库函数，只是缺少声明而已
5. 在头文件中extern全局变量，在任何地方include它是优秀的方法

## 库函数
不记录

## 预处理器
该部分的内容上面或多或少有所提及，包括把参数以及最外()，以及不要让参数中有副作用,不要在宏中使用if，不要用宏替换指针类型

## 可移植性缺陷

1. 权衡兼容与新特性的便利
2. 标识符的限制
3. 逻辑移位与物理移位
4. 整型的符号与大小（使用unsigned char）
5. 在新的实现当中，realloc可以把已经free的内存块重新分配大小

很多过时内容没有记录

# c专家编程
这本书非常有趣，讲了许多故事  
我整体记录的比较少，恰恰证明内容非常重要，我全部总结放在上面
## C：穿越时空的迷雾

1. C语言的发展与历史
2. 函数最少支持31个参数  
一条代码行里至少可以有509个字符  
表达式中，至少支持32层嵌套()  
至少257个case  
等作者介绍一堆C标准
3. 除了位段与掩码，不要使用无符号整型

## 这不是BUG，而是语言特性

PS：重复内容比较多
Switch标签打错了，编译器也不一定会发现，因为还有goto

## 分析c语言的声明

不重复

## 令人震惊的事实：数组与指针并不相同
不重复

## 对链接的思考

PS：深入内容在工具

1. 驱动器统筹 预处理器->前端（语法与语义分析）->后端（代码生成器）->汇编程序->链接-载入器，并在任意时优化，大多在前后端之间
2. 静态链接与动态链接（更具优势）静态库（archive .a）与动态库（ld .so）
3. ABI（应用程序二进制接口）是动态链接的优势之一，减少更新库函数后对程序的维护
4. 多个进程使用同一个函数在内存空间当中只会有一个副本
5. 因为每个使用共享库的进程，一般会把它映射到不同的虚拟地址，所以使用与位置无关的代码，对于共享库来讲要更快
6. -l选项永远在最后（linker要先看到未定义的符号然后再去库里找，否则不知道要找啥）
7. interpositioning会覆盖库函数，不仅仅是在你的程序里，所以若无必须，请像C++默认的一样声明static

## 运动的诗章：运行时数据结构

1. a.out assembler output 但事实是链接器的输出
2. UNIX系统常见ELF文件格式，其中以segment（段）划分，一个segment包含多个section（把UNIX的段与x86架构的段区分开）
3. a.out包含text，data，bss段（记录没初始化的变量）  
gcc编译的程序运行时，就是这三部分  
text（指令与字符串常量）  
data（初始化的全局变量）  
bss（未初始化，如果你尝试初始化为0，会优化为不初始化）  
加上运行时分配的  
heap（动态内存分配的堆内存，与同名数据结构没有任何关系）  
stack （函数参数与局部变量，与同名数据结构有一些关系）  
但有时，共享库与链接器也在该进程的内存中  
4. stack中，sp指针维护栈顶，栈中保存函数参数，局部变量，堆栈结构/过程活动记录（返回地址，函数调用地址，不适合装入寄存器的参数以及寄存器原有值的保存）alloca函数可以申请到栈的空间
5. stack为递归而独立存在，绝大多数cpu，stack往低内存生长
6. setjump与longjump，在C++变成了异常
7. unix的栈会生长，dos需要固定好（8086中最大64kb）

## 对内存的思考
1. 8086选择重叠两个16位（偏移量与段）变成20位以访问1gb内存的同时兼容原本的16位程序，8086有4个段寄存器，CS，DS，SS，ES（附加）
2. 虚拟模式/保护模式将内存控制器移到芯片外，段寄存器不与偏移量相加，而为存放实际段地址的表提供索引
3. 虚拟内存以页的形式组织，进程尝试操纵不在物理内存当中的页会发生页错误，经过判定是否有效而选择将页载入或者返回段违规
4. 当数据从内存读入，整块被装入cache的行的数据部分，该行的标签记录物理地址，以加速连续读取
5. 堆内存的末端由break指针维护
6. 未对奇的读写会引发总线错误

## 为什么程序员无法分清万圣节和圣诞节
1. 031==25 10==012
2. 所有长度不到int和double的变量，在表达式中会自动类型提升，以保证在运算过程中不会溢出，但是如果编译器确定提升与否不影响结果，可以不提升（适当的函数原形能阻止该过程）
3. (float)3与(float)3.0的行为是不一样的

PS：这部分以实际程序经验为主

## 再论数组

已经让我们玩透了不是吗？

## 再论指针

同上

## 你懂得C，所以C++不在话下

不记录

#### _真正的大师之作_

# 汇编语言（王爽）
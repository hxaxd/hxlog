>“计算机领域的任何问题都可以通过增加一个间接的中间层来解决”

## 简介

### 温故而知新
1. 早期的计算机硬件结构就是CPU,内存，IO控制器连在总线上
2. 由于CPU频率的提升产生了系统总线(PCI)，而CPU频率数倍于系统总线频率
3. 后多媒体的发展产生了北桥芯片，协调CPU内存与高速的图形设备, 而缓慢的设备则连接南桥,最初依赖ISA总线
4. 随着时代的发展也逐有变化，诸如PCI代替ISA,PCIE代替PCI,USB连接外部设备
---
5. SMP对称多处理器是最初为了解决性能增长缓慢的设想，但是由于CPU使用独立的缓存部件过于昂贵，因此多核心共用缓存部件，成为更成熟的方案，这也就是多核处理器
---
6. 应用程序使用运行库提供的应用程序编程接口  
7. 运行库则使用操作系统提供的系统调用接口，这往往是依赖中断来实现
---
8. 操作系统调度CPU资源的方法最初是多道程序(当一个程序暂时没有使用，立刻调用下一个程序,缺点是没有优先级),经过改进，变成了分时系统(一段时间内，每个程序都运行一小段时间,并且有简单的优先级)
9.  而更先进的操作系统模式，就是目前的多任务系统,所有应用程序都以进程的方式运行在比操作系统权限更低的级别，并且地址空间独立，CPU的分配方式为抢占式，根据优先级高低都有机会得到CPU，但是有使用的最长时间
---
10. 操作系统的另外一个重要用处是驱动硬件，它把硬件原本的I/O端口抽象成软件层面的接口
11. 甚至在硬件内部也有这样的一个中间层，比如机械硬盘从逻辑扇区到实际扇区
---
12. 为满足隔离地址空间,充分利用内存以及固定程序运行的地址，我们在实际的内存地址上建立一个中间层，也就是虚拟地址
13. 最初的设想是分段映射,这解决了第三和第一个问题，就是简单地直接映射
14. 考虑到程序的大多数据在一个时间段内是不会用到的，我们使用更小粒度的内存分割和映射方法--分页
15. 分页即把地址空间人为的分成固定大小的页, 把虚拟页映射到物理页和磁盘页(虚拟内存)当中, 当进程访问不在内存中的页，会产生页错误，经判断后,系统会把该页调入内存,然后再访问,对页的操作非常高效，因为有硬件级的支持,内存管理单元(MMU)负责页映射
---
16. 一个进程由一个的多个线程(轻量级进程LWP)组成,线程之间共享内存空间以及进程级资源, 但拥有独立的线程ID,当前指令指针(PC),寄存器集合以及堆栈
17. 线程的访问非常自由，虽然我们往往认为堆栈是其私有空间，但这并不是强制的，某些操作系统会为线程单独提供私有空间TLS
18. 单处理器对应多线程时,多线程程序会轮流执行一小段时间称之为线程调度,线程往往拥有三种状态运行,就绪,等待
19. 线程调度有非常多的方案与算法，但是基本留有优先级调度以及轮转法的思想,主流系统允许你自己设计优先级，但是系统也会自动调整
20. 频繁等待的线程称为IO密集型线程,而长时间运行的线程称为计算密集型线程,显然IO密集型线程的优先级更容易被系统提高,另一种会引发优先级调整的情况是系统防止线程优先级过低,而饿死
21. 线程调度分可抢占与不可抢占,不可抢占的调度方式中,只有线程主动放弃时间片,或者进入等待状态时才会被调度
---
22. windows API教科书式的执行进程与线程,但Linux则是把进程和线程统一为任务,多个任务可以选择共享内存空间
23. Linux有三种方式创建任务,fork(复制当前进程),clone(创建子进程)，exec(用新映像替换当前进程映像)
```C++
pid_t pid = fork();
if(pid == 0)
{
    exec("程序路径", "参数1", "参数2",...);
}
else if(pid > 0)
{
    ....
}
//省略了其他代码,这是一个简单的子进程创建
//注意fork()函数会返回两次以区分父进程与子进程
```
24. fork非常快,因为它不需要复制父进程的内存空间,而是在任务试图修改内存时,再复制一份(写时修改)
25. clone()函数可以创建一个新的任务,并指定开始执行的位置,是否共享内存空间,因此实际产生一个线程
---
26. 许多指令在运行时是由多个指令构成(涉及寄存器),并行的线程同时对一个内存位置操作会因此而不安全,不少体系结构提供原子性操作或系统提供原子性API,但这只对简单的操作有用,数据结构或操作复杂时,需要同步与锁
27. 
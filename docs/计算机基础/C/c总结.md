


## 指针  
   
就c语言的数组与函数,我有一定理解,总结如下  
a[i]==i[a]==*(a+i)  
()为根据地址执行指令

|type&action|object|function|array|
|:----:|:----:|:----:|:----:|
|值/name|值|函数地址|首元素地址|
|&|变量地址|函数地址|数组地址|
|*|值所代表的地址上的值|函数地址|首元素|
|sizeof|type'size|no|type'size*length|

## c与c++
- C++认为int fun()==int fun(void),C认为只是省略了
- C的char常量'a'是int类型,因此'ABCD'不会报错
- C++的const变量默认是内部链接,可以用extern改为外部链接
- C++const变量可以初始化const,C不行
- C++严格使用枚举,C将之认定为整型
- C++原生宽字符,C原生复数
- C++内联函数不可重复定义
- C++11没有初始化器,restric,VLA,伸缩型数组成员,可变数量参数的宏
- c标记名与变量名可以重复,c++不行
- molloc在C++中必须强制类型转换
1- C警告将const指针赋给普通指针,C++error/C++可以用const整型声明数组大小
1- C++可以type(name)强制类型转换
1- C++不可调用main()现在C也不行了
1- C可以char[3]="asd"

以上受时间影响,仅供参考

## 声明

构成:type name+修饰符
不讨论const extern等

修饰符有三种:
- 后置有[]与(),优先级相同,自左向右结合  
当然,这是对规律的总结,实际上它们不是运算符,没有优先级与结合律
- 前置* 优先级小于后置,因此我们声明数组与函数的指针必须使用()

将修饰符与name结合,理解它的类型  
最后你会发现,如果你将以上三种符号认为是运算符形式,那么你得到的是一个表达式,而前面的type就是表达式值的类型

## 链接数组

 这是一个值得被单独拿出来说的事情  
 在链接阶段跨文件使用一个全局数组的时候  
 不能extern一个指针 (反之函数形参可以)  
 因为链接变量是指出a的地址 (由另一个文件定义),当你把一个数组声明为对应元素的指针,会认为数组地址存储的那个值是指针的值,本质原因是数组的值虽然是首元素的指针,但没有使用额外的空间存储,程序会访问未知的内存


 ## 增补


- sizeof(void)=1 (gcc)    
sizeof("hello")=6  
sizeof('a')=sizeof(int)  
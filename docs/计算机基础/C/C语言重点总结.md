## 指针

就c语言的数组与函数,我有一定理解,总结如下
a[i]==i[a]==*(a+i)
()为根据地址执行指令

|type&action|object|function|array|
|:----:|:----:|:----:|:----:|
|值/name|值|函数地址|首元素地址|
|&|变量地址|函数地址|数组地址|
|*|值所代表的地址上的值|函数地址|首元素|
|sizeof|type'size|no|(sizeof type)*length|

## c与c++

- C++认为int fun()==int fun(void),C认为只是省略了
- C的char常量'a'是int类型,因此'ABCD'不会报错
- C++的const变量默认是内部链接,可以用extern改为外部链接
- C++const变量可以初始化const,C不行
- C++严格使用枚举,C将之认定为整型
- C++原生宽字符,C原生复数
- C++11没有初始化器,restric,VLA,伸缩型数组成员,可变数量参数的宏
- c标记名与变量名可以重复,c++不行
- molloc在C++中必须强制类型转换
- C警告将const指针赋给普通指针,C++error
- C++可以用const整型声明数组大小
- C++可以type(name)强制类型转换
- C++不可调用main()现在C也不行了
- C可以char[3]="asd"

以上受时间影响,仅供参考

## 声明

构成:type name+修饰符
不讨论const extern等

修饰符有三种:

- 后置有[]与(),优先级相同,自左向右结合
当然,这是对规律的总结,实际上它们不是运算符,没有优先级与结合律
- 前置* 优先级小于后置,因此我们声明数组与函数的指针必须使用()

将修饰符与name结合,理解它的类型
最后你会发现,如果你将以上三种符号认为是运算符形式,那么你得到的是一个表达式,而前面的type就是表达式值的类型

## 链接数组

这是一个值得被单独拿出来说的事情
在链接阶段跨文件使用一个全局数组的时候
不能extern一个指针 (反之函数形参可以)
因为链接变量是指出a的地址 (由另一个文件定义),当你把一个数组声明为对应元素的指针,会认为数组地址存储的那个值是指针的值,本质原因是数组的值虽然是首元素的指针,但没有使用额外的空间存储,程序会访问未知的内存

## 增补

```C
sizeof(void)=1 (gcc)
sizeof("hello")=6
sizeof('a')=sizeof(int)
```

## C标准中的概念

- 1byte **>=** 8bit
- 函数最少支持31个参数
- 一条代码行里至少可以有509个字符
- 表达式中,至少支持32层嵌套()
- 至少257个case
- 对象指一个或多个字节,这些字节的二进制值为对象表示,对象表示中可能含有填充

### 对象类型

- 大小与对齐要求
- 算术类型,标准有符号整数类型大概率没有填充
- _BitInt(n) 类似n位有符号整数类型,但可能有填充
- 无符号去掉符号位
- 派生类型:数组/函数(不是对象类型)/指针/结构/联合/原子
- 数组类型,T[n],要求T是完全对象类型,T[]为不完全对象类型,若N为整数常量/整数常量表达式,则T[n]为普通数组类型,否则为变长度数组类型
- 指针类型
- 限定类型,const/volatile/restrict(只能修饰指针/指针多维数组,含义仅我所有)/_Atomic
- 算术类型与指针类型(包括nullptr_t)及其限定类型为标量类型
- 初始化: name={};name=值;name=除`,`表达式外的任何16种表达式
- 具名对象与匿名对象
- 对象属性:地址/类型/对齐要求/大小/表示值/表示类型/对象名称
- 分配对象的方式:声明/字符串/内存管理/复合字面量

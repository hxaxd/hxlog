内容如标题所示,值得任何人去看的一本书,内容古老但绝不会过时  
精华集中在前四章,之后的章节受限于时代因素  

## 词法陷阱
1. 注意==与=,如果判断条件用=请使用()如(ch=getchar())
2. 注意位运算与逻辑运算
3. 词法分析中的贪心法 (尽可能使一个token长)如a---b等效(a--)-b

## 语法陷阱
1. c语言的声明 (在c的几乎所有经典当中都有对复杂声明的探讨,不赘述)
2. 注意运算符的优先级 (你也许可以找到一些规律记住它们)
3. 注意;的错误会改变if else的行为
4. 灵活使用switch语句当中不会自动break的特性
5. 注意else的配对

## 语义陷阱
1. C语言只有一维数组,并且我们只能获得长度以及首元素的地址,所有数组的其他操作本质上都是对于指针的操作
2. 想清楚内存空间,合理的free,防止内存泄漏,是否分配成功,字符串多一个字节
3. 指针传进函数的信息缺失
4. 不要解引用NULL (在写下这段文字的前两天因为这个极其常见的错误全世界瘫痪相当一部分win电脑)  
相应的也可以推广到垃圾值以及已经free的地址
5. 注意边界,写成 x >= begin && x < end,这有不少理解与计算的好处
6. 作者讨论了一个叫求值顺序的东西,但也许它有一个名字叫序列点
7. a>INT_MAX-b可以验证a+b是否溢出
8. 返回整型的函数没有return,会返回垃圾值

## 链接
1. 善用lint检查链接时错误
2. extern仅是引用
3. static避免命名冲突
4. 没include也可以用库函数,只是缺少声明而已
5. 在头文件中extern全局变量,在任何地方include它是优秀的方法

## 库函数
不记录

## 预处理器
该部分的内容上面或多或少有所提及,包括把参数以及最外(),以及不要让参数中有副作用,不要在宏中使用if,不要用宏替换指针类型

## 可移植性缺陷

1. 权衡兼容与新特性的便利
2. 标识符的限制
3. 逻辑移位与物理移位
4. 整型的符号与大小 (使用unsigned char)
5. 在新的实现当中,realloc可以把已经free的内存块重新分配大小

很多过时内容没有记录

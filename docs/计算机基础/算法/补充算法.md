## 补充的算法
- 文件中随机拿出一个字符串,O(N)的时间O(1)的空间,每拿出一个,就在两个之间以(n-1):1的概率选一个,综合概率相同(线性等概率采样)
- 摩尔投票  
随便抓一个数和不同的数对对碰,相同的数累加  
我的朴素理解就是集合当中一半以上的数都是同一个,对对碰的最坏情况就是完全是该数与其他数对碰,还会剩下该数 其他情况更是  
- SWAR算法计算汉明重量
- 分治颠倒整数二进制位-----redis设计与实现中提到了不少二进制统计算法,包括SWAR
- 牛顿迭代法利用泰勒级数快速逼近目标值,选择较为接近的初始值, 然后用泰勒极数的第一层展开近似整个函数,二维函数上也就是画函数的切线, 然后求这个近似函数与X轴的交点,选择这个交点,作为下一个初始值,在收敛的情况下,能够极快的接近准确值
- morris遍历二叉树O(1)空间复杂度
- 最长公共前缀,横向,分治,二分搜索,纵向
- 袖珍计算器法(a的n次幂等于e的n*lna次幂)
- 第k小算法,分组排序(快速找到接近中位数,并划分集合),如此分治找k小
- 锦标赛算法找最大最小
- 位运算可以模拟加减,但是进位退位得单独计算保存

## 想法

- 考虑双指针两头接近
- 不重复枚举(组合而非排列),j以i为开头而不用0
- 确定区间用二分查找
- 翻转代替轮转/旋转(解决位置冲突)(不冲突可以环状替换)
- hash表结合线性表
- 验证回文整数,逐步反转整数,直到反转数不大于剩余数,等于回文,小于不回
- 判断子串可以预处理对于每一个字母,下一个可能字母x出现的位置
- 判断是否循环,就考虑快慢指针
- 用多个数模拟高进制,以用位运算模拟取模加减(见力扣137)
- 偶数次相同数异或为零
- 贪心的维护
- 哈希双射,一一对应
- 初始化前缀和后缀,快速算出去除中间的值(前提初始化过程能转移)
- 进位考虑最长9序列
- 链表问题head会改变考虑创建哑节点
- 链表random指针的深拷贝,先复制节点,再拆分
- 二叉树层序遍历记录每层节点数
- 二进制位表达二叉树节点
- 矩阵可以从外向里考虑
- int数组标记状态时,多分几类
- 动态变化的矩阵考虑能否标记变化
- 两栈并行,天下我有
- 链式结构移动,考虑能否一步到位,不暂存
- 当数据仅在一定范围有效,可以考虑该区间上的计数排序
- 双指针判断链表交点,指针走完后交换到另一个链表的头节点,就能同时到达交点
- 试图缓存某过程(层序遍历),考虑利用已经缓存的结果优化空间

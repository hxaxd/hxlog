- [oiwiki](https://oi-wiki.org/) 算竞圣经,但讲的不好,wiki不是书 3
- [左程云](https://space.bilibili.com/8888480) 大佬,比oiwiki还全,人太墨迹 4

## 补充的算法

- 文件中随机拿出一个字符串,O(N)的时间O(1)的空间,每拿出一个,就在两个之间以(n-1):1的概率选一
个,综合概率相同(线性等概率采样)

---

- 摩尔投票  
随便抓一个数和不同的数对对碰,相同的数累加  
我的朴素理解就是集合当中一半以上的数都是同一个,对对碰的最坏情况就是完全是该数与其他数对碰,还会剩下该数 其他情况更是  

---

- SWAR算法计算汉明重量

```C
// SWAR算法统计1的个数
int swar_popcount(uint32_t x) {
    x = x - ((x >> 1) & 0x55555555); // 每2位统计1的个数
    x = (x & 0x33333333) + ((x >> 2) & 0x33333333); // 每4位统计1的个数
    x = (x + (x >> 4)) & 0x0F0F0F0F; // 每8位统计1的个数
    x = x + (x >> 8); // 每16位统计1的个数
    x = x + (x >> 16); // 每32位统计1的个数
    return x & 0x3F; // 返回最终结果
}
```

---

- 分治颠倒整数二进制位-----redis设计与实现中提到了不少二进制统计算法,包括SWAR

```C
// 分治法颠倒二进制位
int reverseBits(int n) {
    // 交换16位
    n = (n >> 16) | (n << 16);
    // 交换8位
    n = ((n & 0xFF00FF00) >> 8) | ((n & 0x00FF00FF) << 8);
    // 交换4位
    n = ((n & 0xF0F0F0F0) >> 4) | ((n & 0x0F0F0F0F) << 4);
    // 交换2位
    n = ((n & 0xCCCCCCCC) >> 2) | ((n & 0x33333333) << 2);
    // 交换1位
    n = ((n & 0xAAAAAAAA) >> 1) | ((n & 0x55555555) << 1);
    return n;
}
```

---

- 延迟接受算法(Deferred Acceptance Algorithm,也称为 Gale-Shapley 算法)时间O(n^2)  
将所有人标记为"free"  
- 每个free的求婚者按照自己的偏好列表,向自己最偏好的被求婚者提出求婚  
- 每个被求婚者收到求婚请求后如果被求婚者更喜欢新求婚者,则接受  
- 被拒绝的求婚者从自己的偏好列表中移除被拒绝的被求婚者,并继续向下一个偏好的被求婚者求婚  
- 直到所有求婚者都匹配成功或无法继续匹配  
- 稳定的匹配:使得不存在任何一对参与者愿意离开当前的匹配对象而选择彼此  
- 匹配结果是求婚者可能获得的最优结果,是被求婚者可能获得的最差结果(在所有稳定匹配中)

#### 一句话算法

- 牛顿迭代法利用泰勒级数快速逼近目标值,选择较为接近的初始值, 然后用泰勒极数的第一层展开近似整个函数,二维函数上也就是画函数的切线, 然后求这个近似函数与X轴的交点,选择这个交点,作为下一个初始值,在收敛的情况下,能够极快的接近准确值
- morris遍历二叉树O(1)空间复杂度,利用叶子的孩子空间放另一半子树
- 最长公共前缀,横向,分治,二分搜索,纵向
- 袖珍计算器法(a的n次幂等于e的n*lna次幂)
- 第k小算法,分组排序(快速找到接近中位数,并划分集合),如此分治找k小
- 锦标赛算法找第二大(直接输给第一大)
- 分组找最大最小
- 位运算可以模拟加减,但是进位退位得单独计算保存
- 中缀转后缀,双栈遍历,数输出,左括号(最低优先级)入栈,右括号出栈(直到上一个左括号出栈),操作符先出栈(直到栈顶优先级低于该操作符)再入栈,遍历结束后全出栈
- Brian Kernighan 算法 n&n-1 去掉最右边1
- Manacher算法计算回文子串的最大长度,利用回文中心对称的特点跳过中心拓展的大部分计算O(n)时间
- 贝叶斯定理用于垃圾邮件分类,利用贝叶斯公式计算后验概率
- 验证回文整数,逐步反转整数,直到反转数不大于剩余数,等于回文,小于不回

## 想法

- 双指针
- 不重复枚举(组合而非排列),j以i为开头而不用0
- 确定区间用二分查找
- 翻转代替轮转/旋转(解决位置冲突)(不冲突可以环状替换)
- hash表结合线性表
- 判断子串可以预处理对于每一个字母,下一个可能字母x出现的位置
- 判断是否循环,就考虑快慢指针
- 用多个数模拟高进制,以用位运算模拟取模加减(见力扣137)
- 偶数次相同数异或为零
- 哈希双射,一一对应
- 初始化前缀和后缀,快速算出去除中间的值(前提初始化过程能转移)
- 进位考虑最长9序列
- 链表问题head会改变考虑创建哑节点
- 链表random指针的深拷贝,先复制节点,再拆分
- 二叉树层序遍历记录每层节点数
- 二进制位表达二叉树节点
- 矩阵可以从外向里考虑
- int数组标记状态时,多分几类
- 动态变化的矩阵考虑能否标记变化
- 两栈并行,天下我有
- 链式结构移动,考虑能否一步到位,不暂存
- 当数据仅在一定范围有效,可以考虑该区间上的计数排序
- 双指针判断链表交点,指针走完后交换到另一个链表的头节点,就能同时到达交点
- 试图缓存某过程(层序遍历),考虑利用已经缓存的结果优化空间
- 二叉搜索树中序遍历是有序序列
- 二分搜索解决两个有序数组中位数
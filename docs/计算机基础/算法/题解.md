力扣no.88  
给你两个按 非递减顺序 排列的整数数组 nums1 和 nums2,另有两个整数 m 和 n ,分别表示 nums1 和 nums2 中的元素数目   
请你 合并 nums2 到 nums1 中,使合并后的数组同样按 非递减顺序 排列 
```C++
class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int m1(0),n1(0);
        int num[m+n];
        for(int i=0;i<m+n;){
        if(m1==m){
            while(i<m+n) num[i++]=nums2[n1++];
            break;
        }
        if(n1==n){
            while(i<m+n) num[i++]=nums1[m1++];
            break;
        }
        if(nums1[m1]<=nums2[n1]) num[i++]=nums1[m1++];
        else num[i++]=nums2[n1++];
        }
        for(int i=0;i<m+n;i++) nums1[i]=num[i];
    }
};
```
非常简单,两个有序数组归并
但是我没有从后归浪费了空间


力扣no.27  
给你一个数组 nums 和一个值 val,你需要 原地 移除所有数值等于 val 的元素 元素的顺序可能发生改变 然后返回 nums 中与 val 不同的元素的数量 
```C++
class Solution {
public:
    int removeElement(vector<int>& nums, int val) {
        int r=nums.size(),l(0);
        for(l;l<r;l++){
            if(nums[l]==val){
                while(r--){
                    if(r==l) return l;
                    if(nums[r]!=val) break;
                }
                nums[l]=nums[r];
            }
        }
        return l;
    }
};
```
双指针去除数
调了好久,思路是对的

力扣no.26  
给你一个 非严格递增排列 的数组 nums ,请你 原地 删除重复出现的元素,使每个元素 只出现一次 ,返回删除后数组的新长度 元素的 相对顺序 应该保持 一致  然后返回 nums 中唯一元素的个数 
```C++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int s(1),mn=nums.size();
        for(int q=1;q<mn;q++){
            if(nums[q]==nums[q-1]) continue;
            else nums[s++]=nums[q];
        }
        return s;
    }
};
```
去除重复数,双指针一样简单

力扣no.80  
给你一个有序数组 nums ,请你 原地 删除重复出现的元素,使得出现次数超过两次的元素只出现两次 ,返回删除后数组的新长度   
不要使用额外的数组空间,你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成 
```C++
class Solution {
public:
    int removeDuplicates(vector<int>& nums) {
        int i(1),j(1),cnt(0);
        for(j;j<nums.size();j++){
            if(nums[j]==nums[j-1]) cnt++;
            else cnt=0;
            if(cnt<2) nums[i++]=nums[j];
        }
        return i;
    }
};
```
一样的简单双指针

力扣no.169  
给定一个大小为 n 的数组 nums ,返回其中的多数元素 多数元素是指在数组中出现次数 大于 ⌊ n/2 ⌋ 的元素   
你可以假设数组是非空的,并且给定的数组总是存在多数元素   
只想到一个哈希表
太差了,附一个官方正解
```C++
class Solution {
public:
    int majorityElement(vector<int>& nums) {
        int candidate = -1;
        int count = 0;
        for (int num : nums) {
            if (num == candidate)
                ++count;
            else if (--count < 0) {
                candidate = num;
                count = 1;
            }
        }
        return candidate;
    }
};
```
排序法(n\2),分治(求众数)
随机化
摩尔投票(超半数可用,去除不同数对)

力扣no.189  
给定一个整数数组 nums,将数组中的元素向右轮转 k 个位置,其中 k 是非负数   
只想到了额外空间   
```C++
class Solution {
public:
    void rotate(vector<int>& nums, int k) {
        k=k%nums.size();
        if(!k) return;
        int a[k];
        for(int i=nums.size()-k,j=0;i<nums.size();i++) a[j++]=nums[i];
        for(int i=nums.size()-1;i>=k;i--) nums[i]=nums[i-k];
        for(int i=0;i<k;i++) nums[i]=a[i];
    }
};
```
看了题解,之前以为多玄妙  
翻转就是简单的三次翻转
还有一个环状替换,都是O(1)空间

力扣no.121  
给定一个数组 prices ,它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格   
你只能选择 某一天 买入这只股票,并选择在 未来的某一个不同的日子 卖出该股票 设计一个算法来计算你所能获取的最大利润   
返回你可以从这笔交易中获取的最大利润 如果你不能获取任何利润,返回 0    
维护此前最小值
```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int min(0),max(0);
        for(int i=1;i<prices.size();i++){
            if(prices[i]-prices[min]>max) max=prices[i]-prices[min];
            if(prices[i]<prices[min]) min=i;
        }
        return max;
    }
};
```
正解

力扣no.122  
给你一个整数数组 prices ,其中 prices[i] 表示某支股票第 i 天的价格   
在每一天,你可以决定是否购买和/或出售股票 你在任何时候 最多 只能持有 一股 股票 你也可以先购买,然后在 同一天 出售   
返回 你能获得的 最大 利润    
递增累加,递减不计
秒杀
```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int sum(0);
        for(int i=1;i<prices.size();i++)
            if(prices[i]>prices[i-1]) sum+=prices[i]-prices[i-1];
        return sum;
    }
};
```
正解
动态规划也可以,空间稍微多点

力扣no.55  
给你一个非负整数数组 nums ,你最初位于数组的 第一个下标  数组中的每个元素代表你在该位置可以跳跃的最大长度 
判断你是否能够到达最后一个下标,如果可以,返回 true ；否则,返回 false  
```
class Solution {
public:
    bool canJump(vector<int>& nums) {
        int m(0);
        for(int i=0;i<nums.size();i++){
            if(i>m) return 0;
            if(nums[i]+i>m) m=nums[i]+i;
        }
        return 1;
    }
};
```
维护可到达区域

力扣no.45  
给定一个长度为 n 的 0 索引整数数组 nums 初始位置为 nums[0]   
每个元素 nums[i] 表示从索引 i 向前跳转的最大长度   
返回到达 nums[n - 1] 的最小跳跃次数 生成的测试用例可以到达 nums[n - 1] 
```C++
class Solution {
public:
    int jump(vector<int>& nums) {
        int m=nums[0]+1,cnt(1);
        if(nums.size()==1) return 0;
        while(m<nums.size()){
            int j=m;
            for(int i=0;i<j;i++){
                m=max(m,nums[i]+i+1);
            }
            cnt++;
        }
        return cnt;
    }
};
```
思路没错,嘎嘎调试,忘记保存m的值     

力扣no.274  
给你一个整数数组 citations ,其中 citations[i] 表示研究者的第 i 篇论文被引用的次数 计算并返回该研究者的 h 指数   
根据维基百科上 h 指数的定义：h 代表"高引用次数" ,一名科研人员的 h 指数 是指他 (她)至少发表了 h 篇论文,并且 至少 有 h 篇论文被引用次数大于等于 h  如果 h 有多种可能的值,h 指数 是其中最大的那个   
```C++
class Solution {
public:
    int hIndex(vector<int>& citations) {
        sort(citations.rbegin(),citations.rend());
        for(int i=0;i<citations.size();i++){
            if(i+1>citations[i]) return i;
        }
        return citations.size();
    }
};
```
排序秒杀  
研究了一下题解,由于h在[0,n]中分布的特性
引出二分,计数排序O(n),差分,等方法

力扣no.380
实现RandomizedSet 类：
RandomizedSet() 初始化 RandomizedSet 对象
bool insert(int val) 当元素 val 不存在时,向集合中插入该项,并返回 true ；否则,返回 false  
bool remove(int val) 当元素 val 存在时,从集合中移除该项,并返回 true ；否则,返回 false  
int getRandom() 随机返回现有集合中的一项 (测试用例保证调用此方法时集合中至少存在一个元素) 每个元素应该有 相同的概率 被返回 
你必须实现类的所有函数,并满足每个函数的 平均 时间复杂度为 O(1)  
```C++
class RandomizedSet {
public:
    RandomizedSet() {
        srand((unsigned)time(NULL));
    }
	
    bool insert(int val) {
        if (indices.count(val)) {
            return false;
        }
        int index = nums.size();
        nums.emplace_back(val);
        indices[val] = index;
        return true;
    }
	
    bool remove(int val) {
        if (!indices.count(val)) {
            return false;
        }
        int index = indices[val];
        int last = nums.back();
        nums[index] = last;
        indices[last] = index;
        nums.pop_back();
        indices.erase(val);
        return true;
    }
	
    int getRandom() {
        int randomIndex = rand()%nums.size();
        return nums[randomIndex];
    }
	
private:
    vector<int> nums;
    unordered_map<int, int> indices;
};
```
没做出来,附一个官方解
我用bitset存元素状态,数组来存数以随机
但是样本有针对检验的,使退化到O(n)

力扣no.9
给你一个整数 x ,如果 x 是一个回文整数,返回 true ；否则,返回 false  
```C++
class Solution {
public:
    bool isPalindrome(int x) {
        std::string s=to_string(x);
        for(int i=0;i<s.size()/2;i++){
            if(s[i]==s[s.size()-1-i]);
            else return 0;
        }
        return 1;
    }
};
```
被题解羞辱了
反转一半数字,直到剩下的小于等于反转的

力扣no.13
罗马数字转整数
```C++
class Solution {
public:
    int romanToInt(string s) {
        int sum(0);
        int cnt[s.size()];
        for(int i=s.size()-1;i>-1;i--){
            switch(s[i]){
                case 'I':cnt[i]=1;break;
                case 'V':cnt[i]=5;break;
                case 'X':cnt[i]=10;break;
                case 'L':cnt[i]=50;break;
                case 'C':cnt[i]=100;break;
                case 'D':cnt[i]=500;break;
                case 'M':cnt[i]=1000;
            }
            if((i==s.size()-1)||cnt[i]>=cnt[i+1]) sum+=cnt[i];
            else sum-=cnt[i];
        }
        return sum;
    }
};
```
简单

力扣no.14  
编写一个函数来查找字符串数组中的最长公共前缀   
如果不存在公共前缀,返回空字符串 "" 
```C++
class Solution {
public:
    string longestCommonPrefix(vector<string>& strs) {
        string s;
        for(int i(0);strs[0][i];i++){
            for(int j(1);j<strs.size();j++){
                if(strs[j][i]==strs[0][i]) continue;
                else return s;
            }
            s+=strs[0][i];
        }
        return s;
    }
};
```
用的横向查找
可以分治,二分搜索,纵向

力扣no.28
给你两个字符串 haystack 和 needle ,请你在 haystack 字符串中找出 needle 字符串的第一个匹配项的下标 (下标从 0 开始) 如果 needle 不是 haystack 的一部分,则返回  -1  
```C++
class Solution {
public:
    int strStr(string haystack, string needle) {
        for(int i(0);i<haystack.size();i++){
            if(haystack[i]==needle[0]){
                int a(i),j(0);
                for(j;j<needle.size();j++) if(haystack[a++]!=needle[j]) goto a;
                return i;
            }
            a:
        }
        return -1;
    }
};
```
顺手写一个暴力O(mn)
正解KMP
已经写不出来了,学一下

力扣no.58  
给你一个字符串 s,由若干单词组成,单词前后用一些空格字符隔开 返回字符串中最后一个单词的长度   
单词 是指仅由字母组成、不包含任何空格字符的最大子字符串  
 
```C++
class Solution {
public:
    int lengthOfLastWord(string s) {
        int ans(0),i(s.size()-1);
        for(i;s[i]==' ';i--);
        for(i;i>=0&&s[i]!=' ';i--) ans++;
        return ans;
    }
};
```
今天打牛客,水一道简单

力扣no.125  
如果在将所有大写字符转换为小写字符、并移除所有非字母数字字符之后,短语正着读和反着读都一样 则可以认为该短语是一个 回文串    
字母和数字都属于字母数字字符   
给你一个字符串 s,如果它是 回文串 ,返回 true ；否则,返回 false    
```C++
class Solution {
public:
    bool isPalindrome(string s) {
        int r(s.size()-1),l(0);
        while(r>l){
            if(s[r]<'0'||(s[r]>'9'&&s[r]<'A')||(s[r]>'Z'&&s[r]<'a')||s[r]>'z'){
                r--;continue;
            }
            if(s[l]<'0'||(s[l]>'9'&&s[l]<'A')||(s[l]>'Z'&&s[l]<'a')||s[l]>'z'){
                l++;continue;
            }
            if(s[l]==s[r]||(s[r]>='a'&&s[l]+32==s[r])||(s[l]>='a'&&s[l]==s[r]+32)){
                r--;l++;continue;
            }
            else return 0;
        }
        return 1;
    }
};
```
双指针秒杀

力扣no.392  
给定字符串 s 和 t ,判断 s 是否为 t 的子序列   
字符串的一个子序列是原始字符串删除一些 (也可以不删除)字符而不改变剩余字符相对位置形成的新字符串  (例如,"ace"是"abcde"的一个子序列,而"aec"不是)   
如果有大量输入的 S,称作 S1, S2, ... , Sk 其中 k >= 10亿,你需要依次检查它们是否为 T 的子序列 在这种情况下,你会怎样改变代码?  
```C++
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int m(0);
        for(int i(0);i<s.size();i++){
            while(m<=t.size()) if(t[m++]==s[i]) break;
            if(m==t.size()+1) return 0;
        }
        return 1;
    }
};
```
双指针  
动态规划
```C++
class Solution {
public:
    bool isSubsequence(string s, string t) {
        int n = s.size(), m = t.size();

        vector<vector<int> > f(m + 1, vector<int>(26, 0));
        for (int i = 0; i < 26; i++) {
            f[m][i] = m;
        }

        for (int i = m - 1; i >= 0; i--) {
            for (int j = 0; j < 26; j++) {
                if (t[i] == j + 'a')
                    f[i][j] = i;
                else
                    f[i][j] = f[i + 1][j];
            }
        }
        int add = 0;
        for (int i = 0; i < n; i++) {
            if (f[add][s[i] - 'a'] == m) {
                return false;
            }
            add = f[add][s[i] - 'a'] + 1;
        }
        return true;
    }
};
```

力扣no.383  
给你两个字符串：ransomNote 和 magazine ,判断 ransomNote 能不能由 magazine 里面的字符构成   
如果可以,返回 true ；否则返回 false    
magazine 中的每个字符只能在 ransomNote 中使用一次   
```C++
class Solution {
public:
    bool canConstruct(string ransomNote, string magazine) {
        int a[256]={0};
        for(int i(0);i<magazine.size();i++) a[magazine[i]]++;
        for(int i(0);i<ransomNote.size();i++) if(--a[ransomNote[i]]==-1) return 0;
        return 1; 
    }
};
```

力扣no.205  
给定两个字符串 s 和 t ,判断它们是否是同构的   
如果 s 中的字符可以按某种映射关系替换得到 t ,那么这两个字符串是同构的   
每个出现的字符都应当映射到另一个字符,同时不改变字符的顺序 不同字符不能映射到同一个字符上,相同字符只能映射到同一个字符上,字符可以映射到自己本身   
```C++
class Solution {
public:
    bool isIsomorphic(string s, string t) {
        int c1[256]={0},c2[256]={0};
        for(int i(0);i<s.size();i++){
            if(!c1[s[i]]&&!c2[t[i]]){
                c1[s[i]]=t[i];
                c2[t[i]]=s[i];
            }
            else if(c1[s[i]]!=t[i]||c2[t[i]]!=s[i]) return 0;
        }
        return 1;
    }
};
```
哈希双射

力扣no.1  
给定一个整数数组 nums 和一个整数目标值 target,请你在该数组中找出 和为目标值 target  的那 两个 整数,并返回它们的数组下标   
```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> hashtable;
        for (int i = 0; i < nums.size(); ++i) {
            auto it = hashtable.find(target - nums[i]);
            if (it != hashtable.end()) {
                return {it->second, i};
            }
            hashtable[nums[i]] = i;
        }
        return {};
    }
};
```
力扣no.202  
编写一个算法来判断一个数 n 是不是快乐数   
对于一个正整数,每一次将该数替换为它每个位置上的数字的平方和   
然后重复这个过程直到这个数变为 1,也可能是 无限循环 但始终变不到 1   
如果这个过程 结果为 1,那么这个数就是快乐数   
如果 n 是 快乐数 就返回 true ；不是,则返回 false    


```C++
class Solution {
    int happy(int n){
        int sum;
        for(sum=0;n>0;n/=10) sum+=(n%10)*(n%10);
        return sum;
    }
public:
    bool isHappy(int n) {
        map<int,bool> m;
        while(n!=1){
            n=happy(n);
            if(m[n]) return 0;
            m[n]=1;
        }
        return 1;
    }
};
```
快慢指针判断链表环更好！！！  
数学角度,这道题其实只能存在一个环,找到那个环,然后只要到达某一个数字就返回0

力扣no.238  
给你一个整数数组 nums,返回 数组 answer ,其中 answer[i] 等于 nums 中除 nums[i] 之外其余各元素的乘积    
题目数据 保证 数组 nums之中任意元素的全部前缀元素和后缀的乘积都在  32 位 整数范围内   
请 不要使用除法,且在 O(n) 时间复杂度内完成此题   
```C++
class Solution {
public:
    vector<int> productExceptSelf(vector<int>& nums) {
        int len=nums.size();
        vector<int> l(len),r(len),v(len);
        l[0]=r[len-1]=1;
        for(int i(1);i<len;i++) l[i]=l[i-1]*nums[i-1];
        for(int i(len-2);i>=0;i--) r[i]=r[i+1]*nums[i+1];
        for(int i(0);i<len;i++) v[i]=l[i]*r[i];
        return v;
    }
};
```
前缀积与后缀积  
可以省去两个数组,初始化一个前缀数组在动态计算后缀积的同时将前数组改变

力扣no.167  
给你一个下标从 1 开始的整数数组 numbers ,该数组已按 非递减顺序排列  ,请你从数组中找出满足相加之和等于目标数 target 的两个数   
你可以假设每个输入 只对应唯一的答案 ,而且你 不可以 重复使用相同的元素   
你所设计的解决方案必须只使用常量级的额外空间   
```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& numbers, int target) {
        int len(numbers.size());
        vector<int> ans(2);
        ans[0]=0;ans[1]=len-1;
        while(numbers[ans[0]]+numbers[ans[1]]!=target){
            if(numbers[ans[0]]+numbers[ans[1]]>target) ans[1]--;
            if(numbers[ans[0]]+numbers[ans[1]]<target) ans[0]++;
        }
        ans[0]++;
        ans[1]++;
        return ans;
    }
};
```
第一次中等题一遍出正解

力扣no.151
给你一个字符串 s ,请你反转字符串中 单词 的顺序   
```C++
class Solution {
public:
    string reverseWords(string s) {
        string ans;
        int i(s.size()-1);
        for(;i>=0;i--) if(s[i]!=' ') break;
        for(;i>=0;i--){
            if(s[i]==' '&&s[i+1]!=' '){
                for(int k=i+1;k<s.size()&&s[k]!=' ';k++) ans+=s[k];
                ans+=' ';
            }
        }
        if(s[0]!=' ')
            for(int k=0;k<s.size()&&s[k]!=' ';k++) ans+=s[k];
            else ans.erase(ans.size()-1);
        return ans;
    }
};
```
双端队列也可以

力扣no.141
环形链表
```C++
class Solution {
public:
    bool hasCycle(ListNode *head) {
        if(!head||!head->next) return 0;
        ListNode *q(head->next->next),*s(head->next);
        for(;;q=q->next->next,s=s->next){
            if(!q||!q->next||!s) return 0;
            if(q==s) return 1;
        }
        return 0;
    }
};
```
快慢指针！

力扣no.21
将两个升序链表合并为一个新的 升序 链表并返回 新链表是通过拼接给定的两个链表的所有节点组成的 
```C++
class Solution {
public:
    ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode a(0);
        ListNode *ans=&a;
        while(list1&&list2){
            if(list1->val<=list2->val){
                ans->next=list1;
                list1=list1->next;
            }
            else{
                ans->next=list2;
                list2=list2->next;
            }
            ans=ans->next;
        }
        if(list1) ans->next=list1;
        else ans->next=list2;
        return a.next;
    }
};
```
美丽的递归,何时我能与她心有灵犀

力扣no.12

```C++
class Solution {
public:
    string intToRoman(int num) {
        string s;
        for(num;num>=1000;num-=1000) s+='M';
        if(num>=900){
            num-=900;
            s+="CM";
        }
        if(num>=500){
            num-=500;
            s+='D';
        }
        if(num>=400){
            num-=400;
            s+="CD";
        }
        for(num;num>=100;num-=100) s+='C';
        if(num>=90){
            num-=90;
            s+="XC";
        }
        if(num>=50){
            num-=50;
            s+='L';
        }
        if(num>=40){
            num-=40;
            s+="XL";
        }
        for(num;num>=10;num-=10) s+='X';
        if(num>=9){
            num-=9;
            s+="IX";
        }
        if(num>=5){
            num-=5;
            s+='V';
        }
        if(num>=4){
            num-=4;
            s+="IV";
        }
        for(num;num;num--) s+='I';
        return s;
    }
};
```
模拟或者硬解码

明显硬解码好看

力扣no.2
链表模拟加法
```C++
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        int tmp(0);
        ListNode* ans=l1;
        while(l1->next&&l2->next){
            if((l1->val=l1->val+l2->val+tmp)>9){
                l1->val-=10;tmp=1;
            }
            else tmp=0;
            l1=l1->next;
            l2=l2->next;
        }
        if((l1->val=l1->val+l2->val+tmp)>9){
            l1->val-=10;tmp=1;
            }
        else tmp=0;
        if(!l1->next&&!l2->next);
        else if(l1->next){
            while(l1->next){
                l1=l1->next;
                if((l1->val+=tmp)>9){
                    l1->val-=10;tmp=1;
                }
                else tmp=0;
            }
        }
        else 
            while(l2->next){
                l1->next=new ListNode;
                l1=l1->next;
                l2=l2->next;
                if((l1->val=l2->val+tmp)>9){
                    l1->val-=10;tmp=1;
                }
                else tmp=0;
            }
        if(tmp){
            l1->next=new ListNode;
            l1=l1->next;
            l1->val=1;
            l1->next=0;
        }
        return ans;
    }
};
```

力扣no.11
给定一个长度为 n 的整数数组 height  有 n 条垂线,第 i 条线的两个端点是 (i, 0) 和 (i, height[i])  
找出其中的两条线,使得它们与 x 轴共同构成的容器可以容纳最多的水  
返回容器可以储存的最大水量  
```C++
class Solution {
public:
    int maxArea(vector<int>& h) {
        int l(0),r(h.size()-1);
        int ans(0);
        while(l<r){
            ans=ans>min(h[l],h[r])*(r-l)?ans:min(h[l],h[r])*(r-l);
            if(h[l]<=h[r]) l++;
            else r--;
        }
        return ans;
    }
};
```
非常简单,重点在算法可行性

力扣no.70
假设你正在爬楼梯 需要 n 阶你才能到达楼顶   
每次你可以爬 1 或 2 个台阶 你有多少种不同的方法可以爬到楼顶呢?  
```C++
class Solution {
public:
    int climbStairs(int n) {
        vector<int> ans(n+1);
        ans[0]=1;ans[1]=1;
        for(int i=2;i<n+1;i++) ans[i]=ans[i-2]+ans[i-1];
        return ans[n];
    }
};
```
动态规划秒了,有知道可以算通项我还美呢  
正解矩阵快速幂

力扣no.35  
给定一个排序数组和一个目标值,在数组中找到目标值,并返回其索引 如果目标值不存在于数组中,返回它将会被按顺序插入的位置     
```C++  
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int left=0,right=nums.size()-1;
        while(left<=right){
            mid=(left+right)/2;
            if(nums[mid]<target){
                left=mid+1;
            }
            else{
                right=mid-1;
            }
        }
        return left;
    }
};
```
二分查找

力扣no.191  
编写一个函数,输入是一个无符号整数 (以二进制串的形式),返回其二进制表达式中数字位数为 '1' 的个数 (也被称为汉明重量)  
```C++
基于n&(n-1)恰为把n的二进制位中的最低位的 1 变为 0
class Solution {
public:
    int hammingWeight(uint32_t n) {
        int ret = 0;
        while (n) {
            n &= n - 1;
            ret++;
        }
        return ret;
    }
};

SWAP算法,O(1),分治思想
public class Solution {
    public int hammingWeight(int n) {
        n = n - ((n >>> 1) & 0x55555555);
        n = (n & 0x33333333) + ((n >>> 2) & 0x33333333);
        n = (n + (n >>> 4)) & 0x0f0f0f0f;
        n = n + (n >>> 8);
        n = n + (n >>> 16);
        return n & 0x3f;
    }
}
```

力扣no.136
给定一个非空整数数组,除了某个元素只出现一次以外,其余每个元素均出现两次 找出那个只出现了一次的元素 
```C++
class Solution {
public:
    int singleNumber(vector<int>& nums) {
        int ans(0);
        for(int i(0);i<nums.size();i++) ans^=nums[i];
        return ans;
    }
};
```
异或秒杀

力扣no.134  
给定一个整数数组 gas ,其中 gas[i] 表示在第 i 个加油站有多少汽油  
给定一个整数数组 cost ,其中 cost[i] 表示从第 i 个加油站开往第 i+1 个加油站需要消耗的汽油  
如果你可以按顺序绕环路行驶一周,则返回出发时加油站的编号,否则返回 -1  

```C++
class Solution {
public:
    int canCompleteCircuit(vector<int>& gas, vector<int>& cost) {
        int l(gas.size()),a[gas.size()];
        for(int i(0);i<l;i++) a[i]=gas[i]-cost[i];
        int e(-1),f(l),sum(0);
        while(1){
            if(sum>=0){
                if(e+1<l) e++;
                else return 0;
                sum+=a[e];
                if(e==f) break;
            }
            else{
                sum+=a[--f];
                if(f==e) return -1;
            }
        }
        return f;
    }
};
```
顺序遍历即可,我双指针复杂了

力扣no.42  
给定 n 个非负整数表示每个宽度为 1 的柱子的高度图,计算按此排列的柱子,下雨之后能接多少雨水   
```C++
class Solution {
public:
    int trap(vector<int>& height) {
        int l(0),r(height.size()-1),m(0),ans(0);
        while(l<r){
            m=max(m,min(height[l],height[r]));
            if(height[l]<m) ans+=m-height[l];
            if(height[r]<m) ans+=m-height[r];
            if(height[l]<=height[r]) l++;
            else r--;
        }
        return ans;
    }
};
```
hard出正解,好！

力扣no.754  
在一根无限长的数轴上,你站在0的位置 终点在target的位置   
每次你可以选择向左或向右移动 第 n 次移动 (从 1 开始),可以走 n 步   
返回到达终点需要的最小移动次数   
```C++
class Solution {
public:
    int reachNumber(int target) {
        target = abs(target);
        int n = (-1 + sqrt(1 + 8.0 * target)) / 2;
        int d = target - n * (n + 1) / 2;
        if (!d) return n;
        d -= ++n;
        return (d & 1 ? n + 1 + n % 2 : n);
    }   
};
```
数学+贪心O(1)秒杀,sqrt现代CPU有指令

力扣no.20  
给定一个只包括 '(',')','{','}','[',']' 的字符串 s ,判断字符串是否有效  
```C++
class Solution {
public:
    bool isValid(string s) {
      stack<int> st;
      for (int i = 0; i < s.size(); i++) {
        if (s[i] == '(' || s[i] == '[' || s[i] == '{') st.push(i);
        else {
          if (st.empty()) return false;
          if (s[i] == ')' && s[st.top()] != '(') return false;
          if (s[i] == '}' && s[st.top()] != '{') return false;
          if (s[i] == ']' && s[st.top()] != '[') return false;
          st.pop();
        }
      }
      return st.empty();
    }
};
```
堆栈秒杀

力扣no.190  
颠倒给定的 32 位无符号整数的二进制位  
```C++
uint32_t reverseBits(uint32_t n) {
    uint32_t result = 0;
    for (int i = 0; i < 32; ++i) {
        result <<= 1;
        result |= (n & 1);
        n >>= 1;
    }
    return result;
}
```
正解是分治

力扣no.66  
给定一个由整数组成的非空数组所表示的非负整数,在该数的基础上加一  
最高位数字存放在数组的首位,数组中每个元素只存储单个数字  
```C++
class Solution {
public:
    vector<int> plusOne(vector<int>& digits) {
        int l(digits.size());
        while(l--){
            if(digits[l]==9){
                digits[l]=0;
                continue;
            }
            else{
                digits[l]++;
                return digits;
            }
        }
        vector<int> ans(digits.size()+1);
        ans[0]=1;
        return ans;
    }
};
```
考虑最长9后缀

力扣no.69  
实现 int sqrt(int x) 函数  
```C++
class Solution {
public:
    int mySqrt(int x) {
        int l = 0, r = x, ans = -1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if ((long long)mid * mid <= x) {
                ans = mid;
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return ans;
    }
};
```
附一个二分法  
还有袖珍计算器法(a的n次幂等于e的n*lna次幂)和牛顿迭代法

力扣no.50  
实现 pow(x, n) 函数  
```C++
class Solution {
public:
    double myPow(double x, int n) {
        if (x == 0) return 0; // 如果底数x为0，则结果为0
        if (x == 1 || n == 0) return 1; // 如果底数x为1或者指数n为0，则结果为1
        if (x == -1) return n % 2 == 1 ? -1 : 1; // 如果底数x为-1，指数n为奇数时结果为-1，为偶数时结果为1
        if (n < 0) { // 如果指数n为负数
            if (n == INT_MIN) { // 如果n为INT_MIN，直接取相反数会有溢出风险
                // 需要特殊处理，先计算x的INT_MAX次幂，再乘以x
                return 1 / (myPow(x, static_cast<int>(INT_MAX)) * x);
            }
            // 对于其他负指数情况，计算其倒数的正指数次幂
            return 1 / myPow(x, -n);
        }
        // 对于正指数情况，调用递归函数计算x的n次幂
        return pow_(x, n);
    }

private:
    double pow_(double x, int n) {
            double result = 1.0;
        double current_product = x;
        while (n > 0) {
            if (n % 2 == 1) {
                result *= current_product;
            }
            current_product *= current_product;
            n /= 2;
        }
        return result;
    }
};
```
附一个正解  
还有递归  

力扣no.172  
给定一个整数 n, 返回 n! 结果尾数中零的数量  
```C++
class Solution {
public:
    int trailingZeroes(int n) {
        int ans(0);
        int a[6]={1,5,25,125,625,3125};
        for(int i(1);i<6;i++){
            ans+=n/a[i];
        }
        return ans;
    }
};

//正解
class Solution {
public:
    int trailingZeroes(int n) {
        int ans = 0;
        while (n) {
            n /= 5;
            ans += n;
        }
        return ans;
    }
};
```
我是小丑

力扣no.198  
你是一个专业的小偷，计划偷窃沿街的房屋 每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警  
给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额  
```C++
class Solution {
public:
    int rob(vector<int>& nums) {
        vector<int> m(nums.size()+1);
        m[1]=nums[0]; //手动进行前两步,就不用预留m[0],也不用size+1
        for(int i(2);i<nums.size()+1;i++) m[i]=max(m[i-1],m[i-2]+nums[i-1]);
        return m[nums.size()];
    }
};
```
使用滚动数组,存前两位,O(1)空间

力扣no.162  
给你一个整数数组 nums，找到峰值元素并返回其索引 数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可   
```C++
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        if(nums.size()==1) return 0;
        if(nums.size()==2) return nums[0]<nums[1];
        int i(nums.size()/2);
        while(i>0&&i<nums.size()-1){
            if(nums[i]>nums[i+1]){
                if(nums[i]>nums[i-1]) return i;
                else i--;
            }
            else i++;
        }
        if(!i) return 0;
        return nums.size()-1;
    }
};
//写成一坨
class Solution {
public:
    int findPeakElement(vector<int>& nums) {
        int n = nums.size();

        // 辅助函数，输入下标 i，返回一个二元组 (0/1, nums[i])
        // 方便处理 nums[-1] 以及 nums[n] 的边界情况
        auto get = [&](int i) -> pair<int, int> {
            if (i == -1 || i == n) {
                return {0, 0};
            }
            return {1, nums[i]};
        };

        int left = 0, right = n - 1, ans = -1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (get(mid - 1) < get(mid) && get(mid) > get(mid + 1)) {
                ans = mid;
                break;
            }
            if (get(mid) < get(mid + 1)) {
                left = mid + 1;
            }
            else {
                right = mid - 1;
            }
        }
        return ans;
    }
};
//正解
```
二分查找O(logn)

力扣no.64  
给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小  
```C++
class Solution {
public:
    int minPathSum(vector<vector<int>>& grid) {
        int m(grid.size()),n(grid[0].size());
        for(int i(1);i<m;i++) grid[i][0]+=grid[i-1][0];
        for(int i(1);i<n;i++) grid[0][i]+=grid[0][i-1];
        for(int i(1);i<m;i++)
            for(int j(1);j<n;j++) grid[i][j]+=min(grid[i-1][j],grid[i][j-1]);
        return grid[m-1][n-1];
    }
};
```
简简单单二维动态规划  

力扣no.82  
给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次  返回 已排序的链表  
```C++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head||!head->next) return head;
        int tmp(0);
        while(head->next->val==head->val){
                tmp=head->val;
                while(head->val==tmp) 
                    if(head->next)head=head->next;
                    else return 0;
                if(!head->next) return head;
            }
        ListNode *h(head),*l(head);
        while(l->next){
            l=l->next;
            if(!l->next) break;
            while(l->next->val==l->val){
                tmp=l->val;
                while(l->val==tmp)
                    if(l->next) l=l->next;
                    else{
                        h->next=0;
                        goto ans;
                    }
                h->next=l;
                if(!l->next) break;
            }
            h=l;
        }
    ans:
        return head;
    }
};
```
我写的太丑陋了  
链表问题head会改变考虑创建哑节点

力扣no.104  
给定一个二叉树，找出其最大深度  
```C++
class Solution {
    int d(TreeNode* root){
        if(!root->left&&!root->right) return 1;
        int l(1),r(1);
        if(root->left) l+=d(root->left);
        if(root->right) r+=d(root->right);
        return max(l,r);
    }
public:
    int maxDepth(TreeNode* root) {
        if(!root) return 0;
        return d(root);
    }
};
//撒子这么写
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == nullptr) return 0;
        return max(maxDepth(root->left), maxDepth(root->right)) + 1;
    }
};
//正解
class Solution {
public:
    int maxDepth(TreeNode* root) {
        if (root == nullptr) return 0;
        queue<TreeNode*> Q;
        Q.push(root);
        int ans = 0;
        while (!Q.empty()) {
            int sz = Q.size();
            while (sz > 0) {
                TreeNode* node = Q.front();Q.pop();
                if (node->left) Q.push(node->left);
                if (node->right) Q.push(node->right);
                sz -= 1;
            }
            ans += 1;
        } 
        return ans;
    }
};
广度优先
```

力扣no.34  
给定一个按照升序排列的整数数组 nums，和一个目标值 target 找出给定目标值在数组中的开始位置和结束位置 如果数组中不存在目标值 target，返回 [-1, -1]  
```C++
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {
        if(!nums.size()) return (vector<int>){-1,-1};
        int l(0),r(nums.size()),m(nums.size()/2);
        vector<int> ans(2);
        while(nums[m]!=target){
            if(r-l<=1) return (vector<int>){-1,-1};
            if(nums[m]>target) r=m;
            else l=m;
            m=l+(r-l)/2;
        }
        l=r=m;
        while(l>-1&&nums[l]==target) l--;
        while(r<nums.size()&&nums[r]==target) r++;
        ans[0]=l+1;ans[1]=r-1;
        return ans;
    }
};
```
简单二分

力扣no.19  
给定一个链表，删除链表的倒数第 n 个结点，并且返回链表的头结点  
```C++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        head=new ListNode(0,head);
        ListNode *s(head),*q(head);
        for(;n>-1;n--) q=q->next;
        while(q){
            q=q->next;
            s=s->next;
        }
        s->next=s->next->next;
        return head->next;
    }
};
```
双指针加哑节点  

力扣no.92  
给你单链表的头指针 head 和两个整数 left 和 right ，其中 left <= right  请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表    
```C++
class Solution {
public:
    ListNode* reverseBetween(ListNode* h, int l, int r) {
        if(l==r) return h;
        r=r-l+1;
        ListNode* y=new ListNode(0,h);
        stack<ListNode*> s;
        ListNode *p(y);
        while(--l) p=p->next;
        h=p;
        while(r--){
            p=p->next;
            s.push(p);
        }
        p=p->next;
        while(!s.empty()){
            h->next=s.top();
            s.pop();
            h=h->next;
        }
        h->next=p;
        return y->next;
    }
};
//脑子抽了
//正常反转就行
```

力扣no.83  
给定一个已排序的链表的头 head ， 删除所有重复的元素，使每个元素只出现一次  返回 已排序的链表  
```C++
class Solution {
public:
    ListNode* deleteDuplicates(ListNode* head) {
        if(!head) return head;
        ListNode* d=new ListNode(0,head);
        ListNode* y(head);
        while(y){
            if(y->val!=head->val){
                head->next=y;
                head=y;
            }
            y=y->next;
        }
        head->next=0;
        return d->next;
    }
};
```
超级简单,懒一天  

力扣no.67  
给定两个二进制字符串 a 和 b，返回它们的和（用二进制表示）  
```C++
class Solution {
public:
    string addBinary(string a, string b) {
        int l1(a.size()),l2(b.size()),t(0);
        if(l1>l2) b.insert(0,l1-l2,'0');
        else a.insert(0,l2-l1,'0');
        int l(a.size());
        while(l--){
            t=a[l]-'0'+b[l]-'0'+t;
            if(t>1){
                t-=2;
                a[l]='0'+t;
                t=1;
            }
            else{
                a[l]='0'+t;
                t=0;
            }
        }
        if(t) return a.insert(0,1,'1');
        return a;
    }
};
//考虑用位运算优化
class Solution:
    def addBinary(self, a, b) -> str:
        x, y = int(a, 2), int(b, 2)
        while y:
            answer = x ^ y
            carry = (x & y) << 1
            x, y = answer, carry
        return bin(x)[2:]

```

力扣no.138  
给你一个长度为 n 的链表，每个节点包含一个额外增加的随机指针 random ，该指针可以指向链表中的任何节点或空节点  
构造这个链表的 深拷贝  
```C++
class Solution {
public:
    Node* copyRandomList(Node* head) {
        if(!head) return 0;
        unordered_map<Node*,Node*> m;
        Node* h(head);
        Node* s=new Node(h->val);
        m[h]=s;
        h=h->next;
        while(h){
            Node* q=new Node(h->val);
            m[h]=q;
            s->next=q;
            s=q;
            h=h->next;
        }
        h=head;
        while(h){
            if(h->random)
                m[h]->random=m[h->random];
            else m[h]->random=0;
            h=h->next;
        }
        return m[head];
    }
};
```
本方法可以在第二个循环中链接链表,更简洁  
可以同时建立后继与随机,哈希记录,复杂度一样  
正解建立新节点插在后面(哈希关系就是后继),再拆分  

力扣no.290  
给定一种规律 pattern 和一个字符串 s ，判断 s 是否遵循相同的规律    
这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 s 中的每个非空单词之间存在着双向连接的对应规律    
```C++
class Solution {
public:
    bool wordPattern(string pattern, string s) {
        unordered_map<char, string> p2s;    // pattern中的字符到s中的字符子串的映射表
        unordered_map<string, char> s2p;    // s中的字符字串到pattern中的字符的映射表
        int n = pattern.size();
        int m = s.size();
        int wordStart = 0;  // 单词的起点索引
        int wordEnd = 0;    // 单词的终点索引（边界或指向空格），不包含
        char ch;            
        string word;
        for(int i = 0; i < n; i++){
            if(wordStart >= m)return false;     // 单词起点已经到达边界，说明s中的单词遍历完了；而pattern的字符还有，字符数量多余单词数，不匹配
            while(wordEnd < m && s[wordEnd] != ' ')wordEnd++;   // wordEnd右移直到到达s边界或者分割的空格
            word = s.substr(wordStart, wordEnd - wordStart);    // 截取单词
            ch = pattern[i];    // 获取当前字符
            if((p2s.count(ch) && p2s[ch] != word) || (s2p.count(word) && s2p[word] != ch)){
                // 字符与单词没有一一映射：即字符记录的映射不是当前单词或单词记录的映射不是当前字符
                return false;
            }
            // 更新映射，已存在的映射更新后仍然是不变的；不存在的映射将被加入
            p2s[ch] = word; 
            s2p[word] = ch;
            // 更新单词区间，起点为当前终点的下一个位置；终点初始与起点相同
            wordStart = wordEnd + 1;
            wordEnd = wordStart; 
        }
        // 如果pattern遍历结束后，字符串s也遍历结束（即单词起点到达了边界），则二者匹配；
        // 否则s还有单词没有匹配，字符数与单词数不匹配
        return wordStart == m + 1;  
    }
};
```
就是双射  
对stl不熟太难受了,如substr,count这些方法  

力扣no.242  
给定两个字符串 s 和 t ，编写一个函数来判断 t 是否是 s 的字母异位词  
```C++
class Solution {
public:
    bool isAnagram(string s, string t) {
        int m[26]={0},l(0);
        if(s.size()==t.size()) l=s.size();
        else return 0;
        for(int i(0);i<l;i++){
            m[s[i]-'a']++;m[t[i]-'a']--;
        }
        for(int i(0);i<26;i++){
            if(m[i]) return 0;
        }
        return 1;
    }
};
```
unicode考虑hashmap  

力扣no.219  
给你一个整数数组 nums 和一个整数 k ，判断数组中是否存在两个 不同索引 i 和 j ，满足 nums[i] == nums[j] 且 abs(i - j) <= k  
```C++
class Solution {
public:
    bool containsNearbyDuplicate(vector<int>& nums, int k) {
        unordered_map<int,int> m;
        int l(nums.size());
        int s(0),i(0);
        for(;i<l&&i<k;i++){
            if(m[nums[i]]) return 1;
            else m[nums[i]]=1;
        }
        for(;i<l;i++){
            if(m[nums[i]]) return 1;
            else m[nums[i]]=1;
            m[nums[s++]]=0;
        }
        return 0;
    }
};
```
滑动窗口  

力扣no.228  
给定一个  无重复元素 的 有序 整数数组 nums  
返回 恰好覆盖数组中所有数字 的 最小有序 区间范围列表  
nums 的每个元素都恰好被某个区间范围所覆盖，并且不存在属于某个范围但不属于 nums 的数字 x  
列表中的每个区间范围 [a,b] 应该按如下格式输出：  
"a->b" ，如果 a != b  
"a" ，如果 a == b  
```C++
class Solution {
public:
    vector<string> summaryRanges(vector<int>& nums) {
        string s;
        vector<string> v;
        int l(nums.size());
        for(int i(0);i<l;i++){
            int b(i);
            for(int j(nums[i]);i<l&&nums[i]==j;j++){
                i++;
                if(nums[i-1]==INT_MAX) break;
            }
            if(i-1!=b){
                s+=to_string(nums[b]);
                s+="->";
                s+=to_string(nums[i-1]);
                v.push_back(s);
            }
            else v.push_back(to_string(nums[b]));
            s.clear();
            i--;
        }
        return v;
    }
};
```
妈的,看见题解才意识到INT_MAX一定是数组最后一个元素,所以不用特判,改一下逻辑就好  

力扣no.61  
给定一个链表，旋转链表，将链表每个节点向右移动 k 个位置  
```C++
class Solution {
public:
    ListNode* rotateRight(ListNode* head, int k) {
        if(!head) return 0;
        int l(0);
        ListNode *h(head),*e(head);
        while(h){
            l++;
            h=h->next;
        }
        k%=l;
        h=head;
        while(k--) h=h->next;
        while(h->next){
            h=h->next;
            e=e->next;
        }
        h->next=head;
        head=e->next;
        e->next=0;
        return head;
    }
};
```

力扣no.15  
给你一个整数数组 nums ，判断是否存在三元组 [nums[i], nums[j], nums[k]] 满足 i != j、i != k 且 j != k ，同时还满足 nums[i] + nums[j] + nums[k] == 0 。请你返回所有和为 0 且**不重复**的三元组。  
```C++
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n = nums.size();
        sort(nums.begin(), nums.end());
        vector<vector<int>> ans;
        // 枚举 a
        for (int first = 0; first < n; ++first) {
            // 需要和上一次枚举的数不相同
            if (first > 0 && nums[first] == nums[first - 1]) {
                continue;
            }
            // c 对应的指针初始指向数组的最右端
            int third = n - 1;
            int target = -nums[first];
            // 枚举 b
            for (int second = first + 1; second < n; ++second) {
                // 需要和上一次枚举的数不相同
                if (second > first + 1 && nums[second] == nums[second - 1]) {
                    continue;
                }
                // 需要保证 b 的指针在 c 的指针的左侧
                while (second < third && nums[second] + nums[third] > target) {
                    --third;
                }
                // 如果指针重合，随着 b 后续的增加
                // 就不会有满足 a+b+c=0 并且 b<c 的 c 了，可以退出循环
                if (second == third) {
                    break;
                }
                if (nums[second] + nums[third] == target) {
                    ans.push_back({nums[first], nums[second], nums[third]});
                }
            }
        }
        return ans;
    }
};
```
排序加双指针  

力扣no.100 
给你两棵二叉树的根节点 p 和 q ，编写一个函数来检验这两棵树是否相同  
```C++
class Solution {
public:
    bool isSameTree(TreeNode* p, TreeNode* q) {
        if(!p||!q) return p==q;
        return isSameTree(p->left,q->left)&&isSameTree(p->right,q->right)&&p->val==q->val;
    }
};
```
递归实现DFS

力扣no.226  
给你一棵二叉树的根节点 root ，翻转这棵二叉树，并返回其根节点  
```C++
class Solution {
public:
    TreeNode* invertTree(TreeNode* root) {
        if(!root) return root;
        invertTree(root->left);
        invertTree(root->right);
        TreeNode *t=root->left;
        root->left=root->right;
        root->right=t;
        return root;
    }
};
```
递归实现DFS

力扣no.112  
给定一个二叉树和一个目标和，判断该树中是否存在根节点到叶子节点的路径，这条路径上所有节点值相加等于目标和  
```C++
class Solution {
public:
    bool hasPathSum(TreeNode* root, int targetSum) {
        if(!root) return 0;
        if(targetSum==root->val&&!root->left&&!root->right) return 1;
        return hasPathSum(root->left,targetSum-root->val)||hasPathSum(root->right,targetSum-root->val);
    }
};
```
递归实现DFS

力扣no.101  
给定一个二叉树，检查它是否是镜像对称的  
```C++
class Solution {
public:
    bool isSymmetric(TreeNode* l,TreeNode* r=(TreeNode*)6) {
        if(r==(TreeNode*)6) return(isSymmetric(l->left,l->right));
        if(!l&&!r) return 1;
        else if(!l||!r) return 0;
        else if(l->val!=r->val) return 0;
        return isSymmetric(l->left,r->right)&&isSymmetric(l->right,r->left);
    }
};
```
递归实现DFS

力扣no.102  
给定一个二叉树，返回其按 层序遍历 得到的节点值
```C++
class Solution {
public:
    vector<vector<int>> levelOrder(TreeNode* root) {
        vector<vector<int>> ans;
        queue<TreeNode*> q;
        q.push(root);
        short i[2000]={0},x(0);
        i[0]++;
        vector<int> t;
        while(!q.empty()){
            i[x]--;
            TreeNode* r(q.front());q.pop();
            if(!r) continue;
            t.push_back(r->val);
            if(r->left){
                q.push(r->left);
                i[x+1]++;
            }
            if(r->right){
                q.push(r->right);
                i[x+1]++;
            }
            if(!i[x]){
                ans.push_back(t);
                t.clear();
                x++;
            }
        }
        return ans;
    }
};
```
这是我写的,与正解的差距主要在我考虑确定每层节点数量的方法是动态调整不同位置的值,但既然不同层不相干,就可以差时用同一个变量

力扣no.637  
给定一个非空二叉树,返回一个由每层节点平均值组成的数组  
```C++
class Solution {
public:
    vector<double> averageOfLevels(TreeNode* root) {
        vector<double> ans;
        double a(0);
        queue<TreeNode*> q;
        q.push(root);
        while(!q.empty()){
            int t=q.size();
            for(int i(t);i>0;i--){
                TreeNode* r(q.front());q.pop();
                if(!r){
                    t--;
                    continue;
                }
                q.push(r->left);q.push(r->right);
                a+=r->val;
            }
            ans.push_back(a/t);
            a=0;
            }
        ans.pop_back();
        return ans;
    }
};
```
此即上题同思路正解

力扣no.6  
将一个给定字符串 s 根据给定的行数 numRows ，以从上往下、从左到右进行 Z 字形排列  
```C++
class Solution {
public:
    string convert(string s, int numRows) {
        int n = s.length(), r = numRows;
        if (r == 1 || r >= n) {
            return s;
        }
        string ans;
        int t = r * 2 - 2;
        for (int i = 0; i < r; ++i) { // 枚举矩阵的行
            for (int j = 0; j + i < n; j += t) { // 枚举每个周期的起始下标
                ans += s[j + i]; // 当前周期的第一个字符
                if (0 < i && i < r - 1 && j + t - i < n) {
                    ans += s[j + t - i]; // 当前周期的第二个字符
                }
            }
        }
        return ans;
    }
};
```
这么简单都没想出来  
直接模拟都行  
正解就是找周期规律(对于每行跳周期,加周期的第一个字符,有周期的第二个字符再加)  

力扣no.135  
n 个孩子站成一排。给你一个整数数组 ratings 表示每个孩子的评分  
你需要按照以下要求，给这些孩子分发糖果：  
每个孩子至少分配到 1 个糖果  
相邻两个孩子评分更高的孩子会获得更多的糖果  
请你给每个孩子分发糖果，计算并返回需要准备的 最少糖果数目  
```C++
class Solution {
public:
    int candy(vector<int>& ratings) {
        vector<int> a(ratings.size(),1);
        int l(ratings.size());
        for(int i(1);i<l;i++){
            if(ratings[i]>ratings[i-1]) a[i]=a[i-1]+1;
        }
        int ans=a[l-1];
        for(int i(l-2);i>=0;i--){
            if(ratings[i]>ratings[i+1]&&a[i]<=a[i+1]) a[i]=a[i+1]+1;
            ans+=a[i];
        }
        return ans;
    }
};
```
两次遍历解决  
但本质无需建立数组再加和,只要记录当前最长位置所在的最长单调序列,即可在O(1)空间解决

力扣no.68  
给定一个单词数组 words 和一个长度 maxWidth ，重新排版单词，使其成为每行恰好有 maxWidth 个字符，且左右两端对齐的文本  
你应该使用 “贪心算法” 来放置给定的单词；也就是说，尽可能多地往每行中放置单词。必要时可用空格 ' ' 填充，使得每行恰好有 maxWidth 个字符  
要求尽可能均匀分配单词间的空格数量。如果某一行单词间的空格不能均匀分配，则左侧放置的空格数要多于右侧的空格数  
文本的最后一行应为左对齐，且单词之间不插入额外的空格  
注意:  
单词是指由非空格字符组成的字符序列  
每个单词的长度大于 0，小于等于 maxWidth  
输入单词数组 words 至少包含一个单词  
```C++
class Solution {
    // blank 返回长度为 n 的由空格组成的字符串
    string blank(int n) {
        return string(n, ' ');
    }

    // join 返回用 sep 拼接 [left, right) 范围内的 words 组成的字符串
    string join(vector<string> &words, int left, int right, string sep) {
        string s = words[left];
        for (int i = left + 1; i < right; ++i) {
            s += sep + words[i];
        }
        return s;
    }

public:
    vector<string> fullJustify(vector<string> &words, int maxWidth) {
        vector<string> ans;
        int right = 0, n = words.size();
        while (true) {
            int left = right; // 当前行的第一个单词在 words 的位置
            int sumLen = 0; // 统计这一行单词长度之和
            // 循环确定当前行可以放多少单词，注意单词之间应至少有一个空格
            while (right < n && sumLen + words[right].length() + right - left <= maxWidth) {
                sumLen += words[right++].length();
            }

            // 当前行是最后一行：单词左对齐，且单词之间应只有一个空格，在行末填充剩余空格
            if (right == n) {
                string s = join(words, left, n, " ");
                ans.emplace_back(s + blank(maxWidth - s.length()));
                return ans;
            }

            int numWords = right - left;
            int numSpaces = maxWidth - sumLen;

            // 当前行只有一个单词：该单词左对齐，在行末填充剩余空格
            if (numWords == 1) {
                ans.emplace_back(words[left] + blank(numSpaces));
                continue;
            }

            // 当前行不只一个单词
            int avgSpaces = numSpaces / (numWords - 1);
            int extraSpaces = numSpaces % (numWords - 1);
            string s1 = join(words, left, left + extraSpaces + 1, blank(avgSpaces + 1)); // 拼接额外加一个空格的单词
            string s2 = join(words, left + extraSpaces + 1, right, blank(avgSpaces)); // 拼接其余单词
            ans.emplace_back(s1 + blank(avgSpaces) + s2);
        }
    }
};
```
排版题,纯模拟,真的烦人

力扣no.49  
给你一个字符串数组，请你将 字母异位词 组合在一起。可以按任意顺序返回结果列表  
字母异位词 是由重新排列源单词的所有字母得到的一个新单词  
```C++

```

力扣no.222 
给定一个完全二叉树的根节点 root ，求出该树的节点个数
```C++
class Solution {
public:
    int countNodes(TreeNode* root) {
        if (root == nullptr) {
            return 0;
        }
        int level = 0;
        TreeNode* node = root;
        while (node->left != nullptr) {
            level++;
            node = node->left;
        }
        int low = 1 << level, high = (1 << (level + 1)) - 1;
        while (low < high) {
            int mid = (high - low + 1) / 2 + low;
            if (exists(root, level, mid)) {
                low = mid;
            } else {
                high = mid - 1;
            }
        }
        return low;
    }

    bool exists(TreeNode* root, int level, int k) {
        int bits = 1 << (level - 1);
        TreeNode* node = root;
        while (node != nullptr && bits > 0) {
            if (!(bits & k)) {
                node = node->left;
            } else {
                node = node->right;
            }
            bits >>= 1;
        }
        return node != nullptr;
    }
};
```
你看我够不够2  
先向左到底算层数,然后二分查找就一个节点/满节点(最后一层),用二进制验证(对于12(1100),第一个1为root,然后rll(右左左))  

力扣no.3  
给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度  
```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        if(!s.size()) return 0;
        int len(s.size()),l(0),r(1),ans(1);
        bool h[128]={0};
        h[s[l]]=true;
        while(r<len){
            if(!h[s[r]]){
                ans=max(ans,r-l+1);
            }
            else{
                while(s[l]!=s[r]){
                    h[s[l]]=false;
                    l++;
                }
                l++;
            }
            h[s[r]]=true;r++;
        }
        return ans;
    }
};
```
滑动窗口,哈希表

力扣no.209  
给定一个含有 n 个正整数的数组和一个正整数 target   
找出该数组中满足其总和大于等于 target 的长度最小的 
子数组并返回其长度  
如果不存在符合条件的子数组，返回 0  
```C++
class Solution {
public:
    int minSubArrayLen(int s, vector<int>& nums) {
        int n = nums.size();
        if (n == 0) {
            return 0;
        }
        int ans = INT_MAX;
        int start = 0, end = 0;
        int sum = 0;
        while (end < n) {
            sum += nums[end];
            while (sum >= s) {
                ans = min(ans, end - start + 1);
                sum -= nums[start];
                start++;
            }
            end++;
        }
        return ans == INT_MAX ? 0 : ans;
    }
};
```
滑动窗口  

力扣no.128  
给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度  
```C++
class Solution {
public:
    int longestConsecutive(vector<int>& nums) {
        int n(0),t(0),ans(0),l(nums.size());
        map<int,bool> m;
        for(int i(0);i<l;i++){
            m[nums[i]]=1;
        }
        for(int i(0);i<l;i++){
            if(m[nums[i]]&&!m[nums[i]-1]){
                int at=nums[i];
                while(m[t++]){
                    m[t-1]=0;
                    n++;
                }
                ans=max(ans,n);
                n=0;
            }
        }
        return ans;
    }
};
```
检查nums[i-1]以确定是否为合法起点,避免重复检查  
注意边检查边删除更快,我用怪方法map,官方用的是unordered_set更好  
草,才知道map的实现是红黑树,比unordered_set慢很多  

力扣no.300  
给你一个整数数组 nums ，找到其中最长严格递增子序列的长度  
```C++
class Solution {
public:
    int lengthOfLIS(vector<int>& nums) {
        int l(nums.size()),ans(1);
        vector<int> dp(l);
        dp[0]=1;
        for(int i(1);i<l;i++){
                int t(1);
                for(int j(0);j<i;j++){
                    if(nums[i]>nums[j]) t=max(dp[j]+1,t);
                }
                dp[i]=t;
                ans=max(ans,t);
                t=1;
            }
        return ans;
    }
};
```
简单dp

力扣no.36  
请你判断一个 9 x 9 的数独是否有效  
验证已经填入的数字是否有效即可  
```C++
class Solution {
public:
    bool isValidSudoku(vector<vector<char>>& board) {
        int v1[9][10]={0},v2[9][10]={0},v3[9][10]={0};
        for(int i(0);i<9;i++)
            for(int j(0);j<9;j++){
                if(board[i][j]=='.') continue;
                int t=board[i][j]-'0';
                if(v1[i][t]) return 0;
                else v1[i][t]=1;
                if(v2[j][t]) return 0;
                else v2[j][t]=1;
                if(v3[i/3*3+j/3][t]) return 0;
                else v3[i/3*3+j/3][t]=1;
            }
            return 1;
    }
};
```
哈希表

力扣no.54  
给你一个 m 行 n 列的矩阵 matrix ，请按照 顺时针螺旋顺序 ，返回矩阵中的所有元素  
```C++
class Solution {
public:
    vector<int> spiralOrder(vector<vector<int>>& matrix) {
        if (matrix.size() == 0 || matrix[0].size() == 0) {
            return {};
        }

        int rows = matrix.size(), columns = matrix[0].size();
        vector<int> order;
        int left = 0, right = columns - 1, top = 0, bottom = rows - 1;
        while (left <= right && top <= bottom) {
            for (int column = left; column <= right; column++) {
                order.push_back(matrix[top][column]);
            }
            for (int row = top + 1; row <= bottom; row++) {
                order.push_back(matrix[row][right]);
            }
            if (left < right && top < bottom) {
                for (int column = right - 1; column > left; column--) {
                    order.push_back(matrix[bottom][column]);
                }
                for (int row = bottom; row > top; row--) {
                    order.push_back(matrix[row][left]);
                }
            }
            left++;
            right--;
            top++;
            bottom--;
        }
        return order;
    }
};
```
模拟可以,但是用哈希表占空间  
关于方向的改变,用方向索引数组(不同方向就是ij加的值不同)即可,我是傻子,用状态机  
最优是按层遍历,有分治递归的意思

力扣no.139  
给你一个字符串 s 和一个字符串列表 wordDict 作为字典  
请你判断是否可以利用字典中出现的单词拼接出 s  
```C++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        auto wordDictSet = unordered_set <string> ();
        for (auto word: wordDict) {
            wordDictSet.insert(word);
        }

        auto dp = vector <bool> (s.size() + 1);
        dp[0] = true;
        for (int i = 1; i <= s.size(); ++i) {
            for (int j = 0; j < i; ++j) {
                if (dp[j] && wordDictSet.find(s.substr(j, i - j)) != wordDictSet.end()) {
                    dp[i] = true;
                    break;
                }
            }
        }

        return dp[s.size()];
    }
};
```
动态规划,用dp[i]表示s的前i个字符能否被wordDict中的单词表示  
转移方程：dp[i]=dp[j]&&check(s[j+1,i])  
check(s[j+1,i])表示s[j+1,i]是否出现在字典中  

力扣no.322  
给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数   amount ，表示总金额  
计算并返回可以凑成总金额所需的 最少的硬币个数  
如果没有任何一种硬币组合能组成总金额，返回 -1  
```C++


```





未学会：矩阵快速幂
## 数据结构绪论
> *数据结构是一门研究非数值计算的程序设计问题中的操作对象,以及它们之间的关系和操作等相关问题的学科*

- 数据,数据元素,数据项----类,对象,成员(简单对比一下,不严谨)
- 逻辑结构分为集合,线性,树形,图形
- 物理结构分为顺序,链式
- ADT 抽象数据类型----类

## 算法
- 算法具有5个基本特性:输入,输出,有穷x,确定性,可行性
- 优秀算法应该具有:正确性,可读性,健壮性(对抗不合法输入),高效性(时空)
- 简介时空复杂度,不赘述(注意空间复杂度是算法辅助空间对于输入量的阶,这是我之前未明确的)

## 线性表
- 特性:顺序(前驱与后继),有穷
- 基本方法:init,is_empty,clear,get,find,insert,delete,size/length,其它方法都可以用基本方法建立
- 顺序实现需要:起始位置,最大容量(数组大小),长度(线性表大小),其为随机存储结构(O(1)时间存取),缺点是插入删除O(n)
- 链式实现基于node,node中有数据域与指针域,还需要头指针,可用头节点,确定位置的插入删除O(1),读取O(n)
- 静态链表就是数组的元素是节点,保存数据与后继的下标,对它的操作往往维护主链与备用链(数组的首尾往往是它们的头),元素不需实际移动,难在表长难以确定
- 循环链表利于从任意node开始遍历,维护时往往保存尾指针
- 双向链表也是常见思路

## 栈与队列

### 栈
> *stack,LIFO后进先出,为递归而生*

- 基本方法:受限制的线性表
- 在一个数组上建立对向生长的两个栈以共享空间,当数据类型相同且数量关系相反时,这及其有用
- 线性实现的空为top==-1,链式实现为top==NULL
- 栈的一个重要应用是中缀表达式->后缀表达式(优先级隐藏在顺序中)->结果

### 队列
> *queue,FIFO先进先出*

- 基本方法:受限制的线性表
- 为避免反复调整数组队列中的空间,使用循环队列,其为空与满的特点一致——头指针与尾指针相等,使用flag或者保留一个空位作为满的条件
- 注意循环队列的两个指针前后顺序不确定,因而计算length需要特殊处理,往往需要对size取余
- 链队列一切如常

> 在C专家编程中,作者指出指针往往指向头与尾的下一个这一数据结构惯例

## 串

### 基本

- 串的比较规则为字典序,注意a < aa,这个非常朴素,但是我没有深入思考过
- 基本方法:init,is_empty,clear,get,find,insert,delete,size/length 这些和线性表很相像,但注意操作对象是子串  
cat copy compare 这些是独特的, 但似乎也能用上面的方法实现,真正特殊的在我看来在于拷贝构造和比较
- 标记串顺序存储的结束可以用\0或者记录长度,链式存储往往在一个节点存放多个char,但总的来说不建议链式

### 串的模式匹配

- 朴素算法,暴力匹配,时间复杂度O(nm),非常朴素
- KMP算法,时间复杂度O(n+m),计算模式串的next数组(字符匹配失败后跳转到模式串的哪个位置)以不再需要回溯主串
- 但是相同字符算next会形成链(例如aaaa的next0123),因此可以进一步优化,计算nextval数组(类似并查集的路径压缩)

## 树

- 节点的子树数是节点的度,度为0的节点是叶节点/终端节点,反之是非终端节点/分支节点,非根的分支节点也叫内部节点
- 树的度是树内各节点度的最大值,节点之间存在父子/兄弟/祖先子孙的关系,根为第一层,树最大节点层次是树的深度
- 树有序性指节点的左右子树是否有序
- 森林指不相交的树的集合
- 基本方法:init,is_empty,clear,create,depty,root,get,assign,parent,left,right,deltree,delnode,insert

### 树的存储结构

有三种表示法:双亲表示法,孩子表示法,孩子兄弟表示法

- 双亲: 每个节点保存其父节点的索引,并且按需要可以保存长子/兄弟等等
- 孩子: 每个节点保存其所有子节点的索引,最优秀的保存方式是用数组保存节点,用单链表保存孩子在数组的位置,也可与双亲表示法结合(加个parent域)
- 孩子兄弟: 将树变形为二叉树,每个节点保存其长子与右兄弟的索引

### 二叉树

即节点度<=2,有序的树

- 只有左/右的二叉树即斜树(链表就是)
- 满二叉树: 所有叶节点都在同一层的二叉树(2^n-1个节点)
- 完全二叉树: 除了叶节点,所有节点都有两个孩子的二叉树(满二叉树的子集)

### 二叉树性质

- 第i层最多有2^(i-1)个节点
- 深度为k的二叉树最多有2^k-1个节点
- 叶节点数=度为2的节点数+1
- n个节点的完全二叉树深度为log2n(向下取整)+1
- 有n个节点的完全二叉树,按层序编号,对任一节点i有:
  - 若i=1,则节点i是二叉树的根,无双亲;若i>1,则其双亲是节点i/2
  - 若2i>n,则节点i无左孩子,否则其左孩子是节点2i
  - 若2i+1>n,则节点i无右孩子,否则其右孩子是节点2i+1

### 二叉树存储结构

- 完全二叉树用数组存,利用最后一个性质
- 一般二叉树用链式存储,每个节点保存其左孩子与右孩子的索引

### 二叉树遍历

前序中序后序层序

- 前序: 根左右
- 中序: 左根右
- 后序: 左右根

给定前中/中后遍历的序列,可唯一确定二叉树

```C++
void fun (tree* t) {
    if (t == NULL) return;
    // 前序工作
    fun(t->left);
    // 中序工作
    fun(t->right);
    // 后序工作
}
// 递归实现,只是业务代码位置不同
```
在遍历过程中建立节点即可实现二叉树建立(根据给定节点序列,在序列中用一定字符指示该子树为空,方可"转弯")

- 层序: 按层遍历

### 线索化

- 二叉树有大量的空指针,浪费空间,可以利用这些空指针来存储某种遍历的前驱/后继信息
- 但需要在二叉树的结构中增加两个标志域,表示该节点的左右孩子是否为前驱/后继
- 线索化用于经常以某种次序遍历的情况

二叉树是相对方便处理的一种树,所以我们更希望将其它树/森林转化  
树转化为二叉树的方法很简单,每个节点保存其第一个孩子与右兄弟的索引,反之亦可  
森林转化为二叉树的方法,将每棵树转化为根只有左孩子的二叉树,然后将另一二叉树作为前一棵二叉树的右孩子,反之亦可

### 赫夫曼树

> 赫夫曼编码是最基本的数据压缩算法,其核心思想是用最短的编码表示出现频率最高的字符

- 带权路径长度即所有叶节点的权值与深度的乘积之和
- 带权路径长度最小的二叉树称为赫夫曼树
- 赫夫曼树的构造方法有固定的范式,即每次从权值最小的两个节点/子树中取出,合并为一个子树,直到只剩下一个树(向上生长)
- 将字符的出现频率作为权值,即可构造赫夫曼树,并以赫夫曼树的路径作为编码(左0右1),确保编码是前缀码(避免歧义)

## 图

### 概念

- 顶点V(vertex),图中节点有穷非空,边E可空
- 边可有向/无向,写作`<A,B>/(A,B)`有向边亦称弧,两顶点作弧头弧尾
- *简单图*指无(A,A)且同一条边唯一
- 边/弧相对于点的数决定稀疏/稠密(模糊概念)

完全图

- 任意两点都有边的无向图称*无向完全图*(共(n*(n-1))/2条边)
- 有向完全图类似(共(n*(n-1))条边)

权

- 带权(指边/弧)图亦称网

点边关系

- 无向图有边`(A,B)`,称AB邻接,边依附/关联AB,点相接边数为其度
- 有向图有弧`<A,B>`,称A邻接到B,B邻接自A,弧关联AB,点相接边数为其度,分出度/入度

路径

- 路径即顶点序列,其长度为边/弧数目,顶点不重复为简单路径
- 头尾顶点一致为回路/环,除去头顶点不重复为简单回路/环

连通

- 无向图两顶点有路径为连通
- 无向图任意两点连通为连通图
- 极大(最多顶点)连通子图(包含依附的边)称为图的连通分量

有向图类似概念要求双向存在路径

- 强连通图/强连通分量

生成树

- 连通图的极小(包含所有点与此情况的最少边(n-1))连通子图称为生成树
- 有向图中有一顶点入度为0，其余为1称有向树
- 有向图去掉一些弧至其仅由有向树构成称其为图的有向森林

基本方法
- clear,create,delgrapy,insert,delete,get,is_adjacent,get_adjacent,dfs,bfs...

### 存储结构
`
邻接矩阵

- 邻接矩阵即一维数组表示点信息，二维数组表示两点间是否有边
- 无向简单图显然主对角线为0，且对于主对角线对称
- 对于有权图,亦可用二维数组表示两点间权值并用一个特殊值表示两点间无边
  
邻接表

- 邻接表即一维数组分数据域与指针域，指针域保存邻接点的索引
- 对于有向图,可以建立两个邻接表分别表示出入

十字链表

- 将有向图的邻接表与逆邻接表合并为一个十字链表,每个节点表示一条弧,记录起点/重点/同起点下一条弧/同终点下一条弧
- 是对有向图邻接表的优化

邻接多重表

- 将无向图顶点的邻接表合并为一个邻接多重表,每个节点表示一条边,记录顶点0/顶点1/顶点0下一条边/顶点1下一条边
- 是对无向图邻接表的优化

边集数组

- 边集数组即两个一维数组分别保存点信息与边的起点/终点/权
- 对顶点处理很慢,是处理边的特化

### 图的遍历

> 无论如何,你总要用一个数组记录是否已经访问该顶点

深度优先搜索(DFS)

```
dfs(图,位置){
    标记已访问
    工作
    枚举所有点
        如果邻接且未访问
            dfs(图,位置)
}
// 邻接矩阵时间O(n^2),邻接表时间O(n+e),考虑稀疏密集
main(){
    初始化
    枚举所有点
        如果未访问
            dfs(图,位置)
}
```

广度优先搜索(BFS)

```
bfs(图){
    初始化
    枚举所有点
        如果未访问
            标记已访问
            工作
            入队
                while 队列非空
                    出队
                    枚举邻接且未访问
                        标记已访问
                        工作
                        入队
}
```

### 图的应用算法

#### 最小生成树

- 最小生成树即权值最小的生成树

prim算法  
O(n^2)

- 从一个顶点开始,每次选取新顶点与已访问顶点相连的最小权值的边,直到所有顶点都被访问
- 实现中用一个数组记录连接顶点的顺序另一个数组记录所有顶点与已访问集合的最小权值
- 权为0的边表示已访问集合与该顶点相连,权为无穷的边表示该顶点未被访问
- 每连接一个顶点就更新最小权值,直至全为0

kruskal算法  
O(eloge)

- 每次选取不成环的最小权值的边,直到所有顶点都被访问
- 实现中用一个数组记录所有边的信息,另一个数组记录顶点归属的集合(初始化为0)
- 对于边的两顶点,根据集合路径查找归属,相等即成环,若为0,则返回顶点自身编号(自身集合)
- 数组[begin] = end,表示begin顶点归属end集合

#### 最短路径

dijkstra算法  
单源O(n^2),多源O(n^3)

- 实现中一个数组记录前驱路径,一个数组记录最短路径权值,一个数组标记是否已求得
- 每次选取最短路径的顶点,更新其邻接顶点的最短路径权值,并更新该顶点最短路径的上一顶点,直至遍历完所有顶点
- 贪心选择较小本质是以局部的信息确定最短路径

floyd算法  
O(n^3)

- 两个二维数组,一个记录最短路径权值(正常初始化),一个记录前驱路径(随便)
- 三重循环,判断ij两点间路过k是否能更短,逐渐用k点“连接”路径,DP思想

#### 拓扑排序

- AOV网指顶点表示活动,弧表示活动间的先后关系的有向图(不可存在回路)
- 拓扑排序即对AOV网进行排序,使得所有活动的前驱活动都排在该活动前面

拓扑排序算法  
O(n+e)

- 对AOV网选取一个入度为0的顶点,输出该顶点,并将该顶点的后继顶点的入度减1,重复直至所有顶点都被输出
- 注意可以每次选出所有入度为0的顶点,输出后一起减1,空间换时间

#### 关键路径

- AOE网指顶点表示事件,弧表示活动间的先后关系,权值表示所需时间的有向图(不可存在回路)
- 正常情况下,AOE网应存在一个入度为0的顶点(源点)与一个出度为0的顶点(汇点),代表整个工程的开始与结束
- 关键路径即从源点到汇点的最长路径,也即整个工程的最短时间

关键路径算法  
O(n+e)

- 定义四个参数,分别为事件(顶点)/活动(弧)的最早发生时间/(需要的)最晚发生时间
- 对AOE网进行拓扑排序,得所有事件的最早发生时间(完成各前置活动的时间的最大值)
- 随后对拓扑排序的逆序进行遍历,得所有事件的最晚发生时间(后续事件(最晚发生时间-活动时间)的最小值)
- 随后对AOE网的所有弧遍历,得所有工作的最早发生时间(前置顶点的最早发生时间)与最晚开始时间(后置顶点的最晚发生时间-工作所需时间),若两者相等,则为关键路径

## 查找

- 查找表即同一类型数据元素的集合
- 关键字/键值/Key是数据的某个数据项的值,可以标识数据,如果查找表的数据元素是记录,则关键字即为记录的某个数据项(字段),亦称关键码
- 根据是否能唯一标记,Key分为主关键字与次关键字
- 查找表分为静态查找表与动态查找表

静态查找表即不插入/删除数据的查找表,仅count()/get()/find()

动态查找表即插入/删除数据的查找表,可insert()/remove()/update()

- 为优化查找效率,我们面向查找表设计数据结构,即查找结构

### 顺序表查找(静态)

- 顺序表查找即遍历查找,时间复杂度O(n)
- 使用哨兵优化,将查找表的最后一个元素置为Key,则可以省去判断是否越界的操作

### 有序表查找(静态)

- 有序表查找即折半查找,时间复杂度O(logn),但要求表有序
- 使用插值查找优化,即根据Key与表中元素的分布情况,选择合适的折半查找位置mid=a[low]+(key-a[low]/a[high]-a[low])*(a[high]-a[low])
- 使用斐波那契查找优化,即根据黄金分割比例,选择合适的折半查找位置mid=low+F[k-1]-1

斐波那契查找优化  

- 计算目标在斐波那契数列中的位置,因为F[k]往往会大于n,所以需要将表的长度扩充到F[k],并将扩充部分的元素置为最大值
- mid=low+F[k-1]-1,如果a[mid]>key,则k=k-1调整high,否则k=k-2调整low,重复直至a[mid]=key(注意如果mid>n,则return n)或者low>high(return 0)

### 线性索引查找(静态)

- 线性索引即将索引项(主键+记录的位置)组织为线性结构,亦称索引表

#### 稠密索引  
O(n),前提是索引表有序

- 将表中所有记录添加索引项,索引表即为顺序表(注意排序),如果数据集太大,则索引表也会很大,反复访问磁盘会导致效率低下

#### 分块索引  
O(n^1/2)

- 将表中记录分为若干块,块内无序,块间有序,再建立块的索引表(最大主键+记录位置+记录数量)

#### 倒排索引  
O(1)

- 将表中所有记录的所有可能字段映射到所有有本字段的记录,搜索引擎的基本原理

### 二叉排序树查找(动态)

- 二叉排序树(二叉查找树)即左子树所有节点的Key都小于根节点的Key,右子树所有节点的Key都大于根节点的Key,且左右子树也为二叉排序树
- 其中序遍历即为从小到大排序

## 排序



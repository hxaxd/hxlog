## 数据结构绪论
> *数据结构是一门研究非数值计算的程序设计问题中的操作对象,以及它们之间的关系和操作等相关问题的学科*

- 数据,数据元素,数据项----类,对象,成员(简单对比一下,不严谨)
- 逻辑结构分为集合,线性,树形,图形
- 物理结构分为顺序,链式
- ADT 抽象数据类型----类

## 算法
- 算法具有5个基本特性:输入,输出,有穷x,确定性,可行性
- 优秀算法应该具有:正确性,可读性,健壮性(对抗不合法输入),高效性(时空)
- 简介时空复杂度,不赘述(注意空间复杂度是算法辅助空间对于输入量的阶,这是我之前未明确的)

## 线性表
- 特性:顺序(前驱与后继),有穷
- 基本方法:init,is_empty,clear,get,find,insert,delete,size/length,其它方法都可以用基本方法建立
- 顺序实现需要:起始位置,最大容量(数组大小),长度(线性表大小),其为随机存储结构(O(1)时间存取),缺点是插入删除O(n)
- 链式实现基于node,node中有数据域与指针域,还需要头指针,可用头节点,确定位置的插入删除O(1),读取O(n)
- 静态链表就是数组的元素是节点,保存数据与后继的下标,对它的操作往往维护主链与备用链(数组的首尾往往是它们的头),元素不需实际移动,难在表长难以确定
- 循环链表利于从任意node开始遍历,维护时往往保存尾指针
- 双向链表也是常见思路

## 栈与队列

### 栈
> *stack,LIFO后进先出,为递归而生*

- 基本方法:受限制的线性表
- 在一个数组上建立对向生长的两个栈以共享空间,当数据类型相同且数量关系相反时,这及其有用
- 线性实现的空为top==-1,链式实现为top==NULL
- 栈的一个重要应用是中缀表达式->后缀表达式(优先级隐藏在顺序中)->结果

### 队列
> *queue,FIFO先进先出*

- 基本方法:受限制的线性表
- 为避免反复调整数组队列中的空间,使用循环队列,其为空与满的特点一致——头指针与尾指针相等,使用flag或者保留一个空位作为满的条件
- 注意循环队列的两个指针前后顺序不确定,因而计算length需要特殊处理,往往需要对size取余
- 链队列一切如常

> 在C专家编程中,作者指出指针往往指向头与尾的下一个这一数据结构惯例

## 串

### 基本

- 串的比较规则为字典序,注意a < aa,这个非常朴素,但是我没有深入思考过
- 基本方法:init,is_empty,clear,get,find,insert,delete,size/length 这些和线性表很相像,但注意操作对象是子串  
cat copy compare 这些是独特的, 但似乎也能用上面的方法实现,真正特殊的在我看来在于拷贝构造和比较
- 标记串顺序存储的结束可以用\0或者记录长度,链式存储往往在一个节点存放多个char,但总的来说不建议链式

### 串的模式匹配

- 朴素算法,暴力匹配,时间复杂度O(nm),非常朴素
- KMP算法,时间复杂度O(n+m),计算模式串的next数组(字符匹配失败后跳转到模式串的哪个位置)以不再需要回溯主串
- 但是相同字符算next会形成链(例如aaaa的next0123),因此可以进一步优化,计算nextval数组(类似并查集的路径压缩)

## 树

- 节点的子树数是节点的度,度为0的节点是叶节点/终端节点,反之是非终端节点/分支节点,非根的分支节点也叫内部节点
- 树的度是树内各节点度的最大值,节点之间存在父子/兄弟/祖先子孙的关系,根为第一层,树最大节点层次是树的深度
- 树有序性指节点的左右子树是否有序
- 森林指不相交的树的集合
- 基本方法:init,is_empty,clear,create,depty,root,get,assign,parent,left,right,deltree,delnode,insert

### 树的存储结构

有三种表示法:双亲表示法,孩子表示法,孩子兄弟表示法

- 双亲: 每个节点保存其父节点的索引,并且按需要可以保存长子/兄弟等等
- 孩子: 每个节点保存其所有子节点的索引,最优秀的保存方式是用数组保存节点,用单链表保存孩子在数组的位置,也可与双亲表示法结合(加个parent域)
- 孩子兄弟: 将树变形为二叉树,每个节点保存其长子与右兄弟的索引

### 二叉树

即节点度<=2,有序的树

- 只有左/右的二叉树即斜树(链表就是)
- 满二叉树: 所有叶节点都在同一层的二叉树(2^n-1个节点)
- 完全二叉树: 除了叶节点,所有节点都有两个孩子的二叉树(满二叉树的子集)

### 二叉树性质

- 第i层最多有2^(i-1)个节点
- 深度为k的二叉树最多有2^k-1个节点
- 叶节点数=度为2的节点数+1
- n个节点的完全二叉树深度为log2n(向下取整)+1
- 有n个节点的完全二叉树,按层序编号,对任一节点i有:
  - 若i=1,则节点i是二叉树的根,无双亲;若i>1,则其双亲是节点i/2
  - 若2i>n,则节点i无左孩子,否则其左孩子是节点2i
  - 若2i+1>n,则节点i无右孩子,否则其右孩子是节点2i+1

### 二叉树存储结构

- 完全二叉树用数组存,利用最后一个性质
- 一般二叉树用链式存储,每个节点保存其左孩子与右孩子的索引

### 二叉树遍历

前序中序后序层序

- 前序: 根左右
- 中序: 左根右
- 后序: 左右根

给定前中/中后遍历的序列,可唯一确定二叉树

```C++
void fun (tree* t) {
    if (t == NULL) return;
    // 前序工作
    fun(t->left);
    // 中序工作
    fun(t->right);
    // 后序工作
}
// 递归实现,只是业务代码位置不同
```
在遍历过程中建立节点即可实现二叉树建立(根据给定节点序列,在序列中用一定字符指示该子树为空,方可"转弯")

- 层序: 按层遍历

### 线索化

- 二叉树有大量的空指针,浪费空间,可以利用这些空指针来存储某种遍历的前驱/后继信息
- 但需要在二叉树的结构中增加两个标志域,表示该节点的左右孩子是否为前驱/后继
- 线索化用于经常以某种次序遍历的情况

二叉树是相对方便处理的一种树,所以我们更希望将其它树/森林转化  
树转化为二叉树的方法很简单,每个节点保存其第一个孩子与右兄弟的索引,反之亦可  
森林转化为二叉树的方法,将每棵树转化为根只有左孩子的二叉树,然后将另一二叉树作为前一棵二叉树的右孩子,反之亦可

### 赫夫曼树

> 赫夫曼编码是最基本的数据压缩算法,其核心思想是用最短的编码表示出现频率最高的字符

- 带权路径长度即所有叶节点的权值与深度的乘积之和
- 带权路径长度最小的二叉树称为赫夫曼树
- 赫夫曼树的构造方法有固定的范式,即每次从权值最小的两个节点/子树中取出,合并为一个子树,直到只剩下一个树(向上生长)
- 将字符的出现频率作为权值,即可构造赫夫曼树,并以赫夫曼树的路径作为编码(左0右1),确保编码是前缀码(避免歧义)

## 图

### 概念

- 顶点V(vertex),图中节点有穷非空,边E可空
- 边可有向/无向,写作`<A,B>/(A,B)`有向边亦称弧,两顶点作弧头弧尾
- *简单图*指无(A,A)且同一条边唯一
- 边/弧相对于点的数决定稀疏/稠密(模糊概念)

完全图

- 任意两点都有边的无向图称*无向完全图*(共(n*(n-1))/2条边)
- 有向完全图类似(共(n*(n-1))条边)

权

- 带权(指边/弧)图亦称网

点边关系

- 无向图有边`(A,B)`,称AB邻接,边依附/关联AB,点相接边数为其度
- 有向图有弧`<A,B>`,称A邻接到B,B邻接自A,弧关联AB,点相接边数为其度,分出度/入度

路径

- 路径即顶点序列,其长度为边/弧数目,顶点不重复为简单路径
- 头尾顶点一致为回路/环,除去头顶点不重复为简单回路/环

连通

- 无向图两顶点有路径为连通
- 无向图任意两点连通为连通图
- 极大(最多顶点)连通子图(包含依附的边)称为图的连通分量

有向图类似概念要求双向存在路径

- 强连通图/强连通分量

生成树

- 连通图的极小(包含所有点与此情况的最少边(n-1))连通子图称为生成树
- 有向图中有一顶点入度为0，其余为1称有向树
- 有向图去掉一些弧至其仅由有向树构成称其为图的有向森林

基本方法
- clear,create,delgrapy,insert,delete,get,is_adjacent,get_adjacent,dfs,bfs...

### 存储结构

邻接矩阵

- 邻接矩阵即一维数组表示点信息，二维数组表示两点间是否有边
- 无向简单图显然主对角线为0，且对于主对角线对称
- 对于有权图,亦可用二维数组表示两点间权值并用一个特殊值表示两点间无边
  
邻接表

- 邻接表即一维数组分数据域与指针域，指针域保存邻接点的索引
- 对于有向图,可以建立两个邻接表分别表示出入

十字链表

- 将有向图的邻接表与逆邻接表合并为一个十字链表,每个节点表示一条弧,记录起点/重点/同起点下一条弧/同终点下一条弧
- 是对有向图邻接表的优化

邻接多重表

- 将无向图顶点的邻接表合并为一个邻接多重表,每个节点表示一条边,记录顶点0/顶点1/顶点0下一条边/顶点1下一条边
- 是对无向图邻接表的优化

边集数组

- 边集数组即两个一维数组分别保存点信息与边的起点/终点/权
- 对顶点处理很慢,是处理边的特化

### 图的遍历

> 无论如何,你总要用一个数组记录是否已经访问该顶点

深度优先搜索(DFS)

```
dfs(图,位置){
    标记已访问
    工作
    枚举所有点
        如果邻接且未访问
            dfs(图,位置)
}
// 邻接矩阵时间O(n^2),邻接表时间O(n+e),考虑稀疏密集
main(){
    初始化
    枚举所有点
        如果未访问
            dfs(图,位置)
}
```

广度优先搜索(BFS)

```
bfs(图){
    初始化
    枚举所有点
        如果未访问
            标记已访问
            工作
            入队
                while 队列非空
                    出队
                    枚举邻接且未访问
                        标记已访问
                        工作
                        入队
}
```

### 图的应用算法

#### 最小生成树

- 最小生成树即权值最小的生成树

prim算法  
O(n^2)

- 从一个顶点开始,每次选取新顶点与已访问顶点相连的最小权值的边,直到所有顶点都被访问
- 实现中用一个数组记录连接顶点的顺序另一个数组记录所有顶点与已访问集合的最小权值
- 权为0的边表示已访问集合与该顶点相连,权为无穷的边表示该顶点未被访问
- 每连接一个顶点就更新最小权值,直至全为0

kruskal算法  
O(eloge)

- 每次选取不成环的最小权值的边,直到所有顶点都被访问
- 实现中用一个数组记录所有边的信息,另一个数组记录顶点归属的集合(初始化为0)
- 对于边的两顶点,根据集合路径查找归属,相等即成环,若为0,则返回顶点自身编号(自身集合)
- 数组[begin] = end,表示begin顶点归属end集合

#### 最短路径

dijkstra算法
单源O(n^2),多源

- 实现中一个数组记录路径,一个数组标记

#### 拓扑排序

#### 关键路径


## 查找

## 排序


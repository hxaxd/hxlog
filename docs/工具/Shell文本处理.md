# Shell 文本处理

## 参考资料

- [命令行的艺术](https://github.com/jlevy/the-art-of-command-line/blob/master/README-zh.md)

## 文本基本操作

```bash
sort file/stdio # 排序 -n/r/f/k 按数字大小 / 反向排 / 忽略大小写 / 排每行的第 n 个字段
uniq file # 去重复打印 -d/c 只显示重复 / 显示行重复次数
command | tee filename # 重定向加打印 -af add / 覆盖
cut -f n -d 'c' file # 按 c 为分割提取每行第 n 个字段
paste file1 file2 # 按行拼接
join f1 f2 # 若第一个字段相同, 拼接这行 -a1/2 不匹配的按谁来
```

- [diff 输出的格式](https://www.ruanyifeng.com/blog/2012/08/how_to_read_diff.html)

```bash
diff fromfile tofile # 文本对比-bBi 忽略连续空格/忽略空白行/忽略大小写 

cmp -l file1 file2 # 对比二进制 返回第一个不同

patch -pn # 根据 diff 输出文件来更改
patch -R -pn # 还原
```

## 正则

- `^` 指定后一个模式匹配字符串的开始
- `$` 指定前一个模式匹配字符串的结束
- `*` 匹配任意长度的字符
- `+` 匹配至少一个字符
- `?` 匹配零或一个字符
- `{n}` 匹配 n 个 `{n}` 前面的模式
- `{n, }` 匹配至少 n 个 `{n, }` 前面的模式
- `{n, m}` 匹配 n 到 m 个 `{n, m}` 前面的模式
- `[]` 匹配任意字符中的一个
- `[^]` 匹配任意字符中的一个 (取反)
- `|` 逻辑或, 连接两个模式
- `()` 分组
- `\\` 转义
- `模式一(?=模式二)` 正向前瞻, 匹配模式二前的模式一, 但不获取匹配结果
- `模式一(?!模式二)` 负向前瞻
- `(?<=模式二)模式一` 正向后顾
- `(?<!模式二)模式一` 负向后顾
- `[:classname:]` 匹配字符类
    - `[:alnum:]` 字母和数字
    - `[:alpha:]` 字母
    - `[:blank:]` 空格和制表符
    - `[:cntrl:]` 控制字符
    - `[:digit:]` 数字
    - `[:graph:]` 可打印字符
    - `[:lower:]` 小写字母

## `grep`

```bash
grep [option] pattern file # 查找文件中匹配的行

# -A<显示行数>:除了显示符合范本样式的那一列之外, 并显示该行之后的内容 
# -B<显示行数>:除了显示符合样式的那一行之外, 并显示该行之前的内容 
# -C<显示行数>:除了显示符合样式的那一行之外, 并显示该行之前后的内容 
# -v:显示不被 pattern 匹配到的行, 相当于 [^] 反向匹配
# -i:忽略大小写
# -n:显示行号
```

## `sed`

```bash
sed [options] 'command' file(s) # 逐行编辑
sed [options] -f scriptfile file(s) # 从文件中读取命令

# -n:不输出模式空间内容到屏幕, 即不自动打印, 只打印匹配到的行
# -i:直接将处理的结果写入文件

# command : 地址操作内容

# 不给地址:对全文进行处理
# n 指定的行
# 1, n 指定的行范围

sed -n '1~2p'  # 只打印奇数行  (1~2 从第 1 行, 一次加 2 行)
sed -n '2~2p'  # 只打印偶数行

# d:删除模式空间匹配的行, 并立即启用下一轮循环
# p:打印当前模式空间内容, 追加到默认输出之后
# a:在指定行后面追加文本, 支持使用 \n 实现多行追加
# i:在行前面插入文本, 支持使用 \n 实现多行追加
# c:替换行为单行或多行文本, 支持使用 \n 实现多行追加
# !:模式空间中匹配行取反处理
# s///:查找替换, 支持使用其它分隔符, s@@@, s###, 加 g 表示行内全局替换
```

## `awk`

- awk 使用 AWK 语言, 我实在不喜欢

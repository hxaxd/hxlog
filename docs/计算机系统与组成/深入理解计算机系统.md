# 深入理解计算机系统

## 参考资料

- 深入理解计算机系统

## 计算机系统漫游

- 科普一个简单程序的全生命周期
- 考虑到所有内容后续都会详叙, 在此不做展开
- Amdahl 定律描述了改善任何过程的一般原则 (抓大头)

## 信息的表示和处理

### 位向量与计算机中的表示

- 字节是计算机中最小的可寻址内存单位
- C 语言用编译时的不同的机器级代码表示类型, 生成的程序并不包含类型信息
- 字长决定的最重要的系统参数就是虚拟地址空间的最大大小
- 三个场景关注大小端
    - 网络协议中, 数据在网络中传输时
    - 汇编语言中
    - C 语言的高级技巧
- 长度为 n 的位向量上 $^$, $~$, $&$ 运算形成布尔环
    - 用位向量编码集合子集是, $^$, $~$, $&$ 恰为并集, 补集, 交集
- 我们一般对有符号数使用算术右移 (进行类型拓展时同理)
- 我们对位向量加上一个解释去表示类型

### 整数表示与运算

- 补码可以理解为最高位权为 $-2^{n-1}$
- C 语言有无符号数转换只转换解释, 不转换位模式
    - 比较时小心有符号数被强转为无符号数
- 无符号类型截断就是取模, 对有符号数进行类型转换时, 先解释为无符号数, 再取模, 再解释为有符号数
- 有符号数的相加也可以理解为无符号数的相加, 只是结果需要解释为有符号数
    - 会出现正溢出和负溢出
- 无符号数与有符号数的加法逆元位模式一致
    - 对位模式取反再加一
- 无符号数与有符号数的乘法位模式一致
    - 先看成无符号数, 相乘, 取模, 再解释为有符号数
- C 语言有符号整数除法的结果是向零截断的
    - 所以右移运算不能直接替代除法, 需要补偿
    - 补偿方法为, 负数时, 先加上 $2^k - 1$, 再右移
- C 语言取模结果的符号与被除数 $x$ 的符号一致
    - 计算方法依旧一致, 先获得商 (向零截断), 再用被除数减去商乘以除数
    - 所以这里有无符号数除法和取模的位模式存在差异

### 浮点数

- $(-1)^s \times 2^e \times M$
- 根据 $E$ 的位模式, 将浮点数划分为以下几种
    - 全为 $0$ 非规格化
    - 全为 $1$ 时, $M$ 的位模式全为 $0$ 表示无穷大, 否则为 NaN
    - 之间的数, 规格化

#### 规格化数

- $E$ 的解释为 $E = e - bias$, 其中 $bias = 2^{k-1} - 1$ (偏置一半)
- $M$ 的解释为 $M = 1 + \sum_{i=0}^{n-2} 2^{-i} \times M_i$ ($1$ + 其位模式解释为小数点在开头的定点小数)

#### 非规格化数

- $E$ 的解释为 $E = 1 - bias$
- $M$ 的解释为 $M = \sum_{i=0}^{n-2} 2^{-i} \times M_i$ (小数点在开头的定点小数)
- 非规格化数用于表示 $0$ 以及接近 $0$ 的数
- 这么设计使得非规格化数的最大值到规格化数的最小值之间的过渡更加平滑
    - 并且单调, 使得浮点数的比较可以直接用位模式比较

#### 浮点数的舍入

- 向最近偶数舍入, 先向最近的整数, 若刚好位于两数中间, 则向偶数方向舍入 (默认, 为了减少统计误差)
- 向零舍入, 向上舍入, 向下舍入

#### 浮点数的运算

- 大部分与整数运算一致
- 实数加法 / 乘法不具有结合律
- 浮点乘法在加法上不具备分配性
- NaN 没有加法逆元

## 程序的机器级表示

### X86-64 指令集

- 大部分略
- 任何为寄存器生成 $32$ 位值的指令都会把该寄存器的高位部分置成 $0$
- 除数和余数是一个指令的两个结果
- 部分早期处理器将更新程序计数器作为执行一条指令的第一步
    - 这使得相对寻址指令,实际生成的机器代码当中的相对值是基于下一条指令的

```C
if (x > 0)
    y = 1;
else
    y = -1;
```

```x86asm
cmpq $0, x
jg .L1
movq $-1, y
jmp .L2
.L1:
movq $1, y
.L2:
```

- 这是编译器惯有的 `if` 翻译方法
- 当然, 相较于基于条件控制转移, 我们更喜欢基于条件数据传送 (显然它是包含条件控制转移的, 就是修改 PC)
    - 也就是根据不同的条件返回不同的数据, 这样的话能有效利用流水线
    - 有的时候也不得不用这个条件转移, 比如说某个分支不被满足的时候, 你预测进入它, 会直接导致错误

```C
while (x > 0)
    y++;
```

```x86asm
goto .L1
.L2:
incq y
.L1:
cmpq $0, x
jg .L2
```

- 这是编译器惯有的 `while` 翻译方法

```x86asm
cmpq $0, x
    jle .L_DONE     ; 如果初始条件 x <= 0，直接跳过循环
.L_LOOP:            ; 循环体开始
    incq y
    cmpq $0, x
    jg .L_LOOP      ; 如果 x > 0，跳回开头
.L_DONE:
```

- guarded-do, 如果初始条件不成立就直接跳过循环, 否则把代码变换为 `do-while` 循环
- `for` 循环, 就是简单包装一下, 就不详叙了
- `switch` 语句, 就是根据不同的情况跳转到不同的标签 (详见编译原理)

### 过程

- 尽可能低代价的进行传递控制, 传递数据, 分配和释放内存
- 传递控制就保存一下当前的 PC, 然后跳转到目标地址
- 传递数据就直接用寄存器传递, 或者用运行时栈传递
- 分配和释放内存就直接用栈来实现
- 当所有的局部变量都可以保存在寄存器中, 而且该函数不会调用任何其他函数时, 函数就可能没有栈帧
- 栈帧也需要对齐

#### 数据处理

- 有些时候, 局部数据必须存放在内存中
    - 寄存器不足够存放所有的本地数据
    - 对一个局部变量使用地址运算符
    - 某些局部变量是数组或结构, 因此必须能够通过数组或结构引用被访问到
- 部分寄存器被划分为被调用者保存寄存器, 保证调用前后寄存器的值不变
    - 其他的叫调用者保存寄存器, 调用者在调用前必须保存好它们的值 (如果需要), 调用后再恢复
- 因为栈向下增长, 所以栈上数组溢出时, 会覆盖上面的栈帧
- 为了处理变长数组, 编译器会记录栈帧底指针, 通过腾出一个被调用者保存寄存器来保存它
    - 解决栈顶指针变化导致的偏移量失效
- 数组寻址时的简单加乘计算被集成进专门的单元中, 非常快
- 过程返回时小于 $16$ 字节会用 $1$ - $2$ 个寄存器, 否则会调用拷贝
    - 大对象现代编译器更喜欢做一个 RVO 优化, 传入一个调用者提供的内存地址, 被调用者直接在该地址上构造

### 浮点数机器语言

- AVX 指令集
    - 扩展了 $256$ 位的向量寄存器
    - 用于浮点数标量是仅使用 $256$ 位中的低 $32$ 或 $64$ 位 (仅)
    - $256$ 位叫 YMM 寄存器
    - 低 $128$ 位叫 XMM 寄存器
- GCC 在做单双精度转换时, 会复制一份原始值, 并行转换出两个结果
- 所有的 XMM 寄存器都是调用者保存
- 编译器会将浮点常量的二进制表示存储在内存的数据段中 (没有真立即数)
- 比较时如果任一操作数是 NaN, 会设置 PF

## 处理器体系结构

### Y86-64 指令集

- Y86-64 的指令集是 X86-64 的子集, 只处理 8 字节的整数操作
- 还有很多简化, 不详叙
- `pushq %rsp` 压入减去 $8$ 前的 `%rsp` (同 X86-64)
- `popq %rsp` 不自动修改 `%rsp`
- 机器码
    - 第一个字节为指令
    - 可选第二个字节为两个寄存器
    - 可选接下来 $8$ 个字节常数 (小端)
- 状态码
    - `AOK` 正常
    - `HLT` 处理器执行了 `halt` 指令, 正常停机
    - `ADR` 非法地址访问
    - `INS` 非法指令

### HCL (硬件控制语言)

- 具体形式还是比较简单的, 不详叙, 注意不要混淆编程语言
- 将很多的逻辑门组合成一个网, 就能构建计算块, 称为组合电路
    - 每个逻辑门的输入必须连接系统输入 / 某个存储器单元的输出 / 某个逻辑门的输出
    - 两个或多个逻辑门的输出不能连接在一起
    - 这个网必须是无环的
- 多路复用器, 用所有控制输入组合的布尔表达式来选择数据输入的其中一个作为输出
    - 有字级形式 -> 类似 `switch`
    - HCL 中可以有允许不互斥的选择表达式, 但实际电路必须确保只有第一个满足的情况才会被选中
- 为了将组合电路时序化, 我们需要引入时钟信号
- 存储设备都是由同一个时钟控制的
    - 时钟寄存器存储单个位或字, 时钟信号控制寄存器加载输入值 (电路中锁住的值, 时钟为 1 时, 刷新输出等于输入, 否则保持原值)
    - 随机访问存储器存储多个字, 用地址来选择该读或该写哪个字 (包括内存与寄存器)
        - 寄存器文件属于随机访问存储器, 就是汇编中的寄存器
        - 寄存器文件有两个读端口和一个写端口, 可以同时读取两个寄存器 + 写入一个寄存器
        - 同时读写一个寄存器会读到一个变化

### Y86-64 的顺序实现

- 一条指令包括很多操作
    - 取指, 根据 PC 取指令, 并计算下一条指令的 PC
    - 译码, 从寄存器文件中读取操作数 (最多 $2$ 个)
    - 执行, 执行指令, 并设置条件码
    - 访存, 读写内存
    - 写回, 将结果写回寄存器文件 (最多 $2$ 个)
    - 更新 PC

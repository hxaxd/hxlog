# 计算机组成与设计

## 参考资料

- 计算机组成与设计: 硬件 / 软件接口 (RISC-V)

## 计算机抽象及相关技术

- 计算机体系结构中的 7 个伟大思想
    - 使用抽象简化设计
    - 加速经常性事件
    - 通过并行提高性能
    - 通过流水线提高性能
    - 通过预测提高性能
    - 存储层次
    - 通过冗余提高可靠性
- 对性能建模
    - 用户 CPU 时间 (CPU 性能), 用户程序运行所需的时间
    - 系统 CPU 时间 (系统性能), 操作系统运行用户程序的相关程序所需的时间
    - CPI, 指令平均时钟周期数
    - CPU 性能 = (指令数 * CPI) / 时钟频率
- 功耗墙
    - 动态功耗: 与 CMOS 开关活动相关的功耗
    - 静态功耗: 与晶体管泄漏电流相关的功耗
    - 功耗 = 0.5 *电容* 电压 *电压* 频率 + 静态功耗
- 增加性能就是增加能效
- 低利用率的计算机不一定具有更低功耗

## 指令: 计算机的语言

- 字是 $32$ 位 ($4$ 字节)
- 双字是 $64$ 位 ($8$ 字节)
- 大多有 $32$ 个寄存器 (`x0` - `x31`)
    - $2^30$ 字节内存寻址空间
- 由于常数 $0$ 经常用 (比如求相反数), `x0` 硬连线为 $0$
- 针对有无符号的整数有不同的指令, 原因是补码的拓展方式不同

```riscv
// 算术运算
add x3, x1, x2 // x3 = x1 + x2
sub x3, x1, x2 // x3 = x1 - x2

// 常数会在程序加载时放入内存
lw x1, constant_address // x1 = Memory[constant_address]
add x2, x2, x1 // x2 = x2 + constant

addi x1, x2, 100 // x1 = x2 + 100 立即数
                 // 因为是补码, 所以可以实现减法

// 数据传输
lw x1, 0(x2) // x1 = Memory[x2 + 0] 取字
lwu x1, 0(x2) // x1 = ZeroExtend(Memory[x2 + 0]) 取无符号字
sw x1, 0(x2) // Memory[x2 + 0] = x1 存字
// 半字
lh x1, 0(x2) // x1 = SignExtend(Memory[x2 + 0]) 取半字
lhu x1, 0(x2) // x1 = ZeroExtend(Memory[x2 + 0]) 取无符号半字
sh x1, 0(x2) // Memory[x2 + 0] = LowHalf(x1) 存半字
// 字节
lb x1, 0(x2) // x1 = SignExtend(Memory[x2 + 0]) 取字节
lbu x1, 0(x2) // x1 = ZeroExtend(Memory[x2 + 0]) 取无符号字节
sb x1, 0(x2) // Memory[x2 + 0] = LowByte(x1) 存字节
// CAS
lr.d x2, (x1) // x2 = Memory[x1] 加载并监控是否被修改
sc.d x3, x2, (x1) // if (没被修改) Memory[x1] = x2, x3 = 0; else x3 = 非零数

// 取立即数高位
lui x1, 0x12345 // x1 = 0x12345000 把高 20 位装入寄存器, 低 12 位清零, 原因是一条指令只能装下 20 位立即数

// 逻辑运算
and x3, x1, x2 // x3 = x1 & x2
or x3, x1, x2 // x3 = x1 | x2
xor x3, x1, x2 // x3 = x1 ^ x2
andi x3, x1, 0xFF // x3 = x1 & 0xFF 立即数
ori x3, x1, 0xFF // x3 = x1 | 0xFF 立即数
xori x3, x1, 0xFF // x3 = x1 ^ 0xFF 立即数

// 移位操作
sll x3, x1, x2 // x3 = x1 << (x2 & 0x1F) 逻辑左移
srl x3, x1, x2 // x3 = x1 >> (x2 & 0x1F) 逻辑右移
sra x3, x1, x2 // x3 = x1 >> (x2 & 0x1F) 算术右移
slli x3, x1, 4 // x3 = x1 << 4 逻辑左移 立即数
srli x3, x1, 4 // x3 = x1 >> 4 逻辑右移 立即数
srai x3, x1, 4 // x3 = x1 >> 4 算术右移 立即数

// 条件分支
beq x1, x2, 100 // if (x1 == x2) goto PC + 100
bne x1, x2, 100 // if (x1 != x2) goto PC + 100
blt x1, x2, 100 // if (x1 < x2) goto PC + 100
bge x1, x2, 100 // if (x1 >= x2) goto PC + 100
bltu x1, x2, 100 // if (x1 < x2) goto PC + 100 (无符号)
bgeu x1, x2, 100 // if (x1 >= x2) goto PC + 100 (无符号)

// 无条件跳转
jal x1, 100 // x1 = PC + 4; goto PC + 100 过程调用
jalr x1, 0(x2) // x1 = PC + 4; goto x2 + 0 过程返回
```

- RISC-V 指令都是 $32$ 位长, 分多类型
- R 型指令 (寄存器 - 寄存器运算)
    - $7$ 位操作码
    - $5$ 位目的操作数寄存器
    - $3$ 位操作码
    - $5$ 位源操作数寄存器
    - $5$ 位源操作数寄存器
    - $7$ 位操作码
- I 型指令 (立即数运算, 载入, 条件分支)
    - $7$ 位操作码
    - $5$ 位目的操作数寄存器
    - $3$ 位操作码
    - $5$ 位源操作数寄存器
    - $12$ 位立即数
- S 型指令 (存储, 立即数表示偏移量)
    - $7$ 位操作码
    - $5$ 位, 低位立即数
    - $3$ 位操作码
    - $5$ 位源操作数寄存器
    - $5$ 位源操作数寄存器
    - $7$ 位, 高位立即数
- B 型指令 (条件分支, 长的跟 S 一样, 立即数乘二表示偏移量)
- U 型指令 (大立即数)
    - $7$ 位操作码
    - $5$ 位目的操作数寄存器
    - $20$ 位立即数
- J 型指令 (无条件跳转, 长的跟 U 一样, 立即数乘二表示偏移量)
- 移位指令通常使用 I 型格式, 但只使用立即数字段的低位
- RISC-V 通过与全 $1$ 的数进行异或来实现按位取反
- 利用无符号比较指令 `bgeu` 可以用一条指令同时检查 $x < 0$ 和 $x \ge y$ (要么是真的越界了, 要么它是一个负数)

### 过程

- 六个步骤
    - 传递参数
    - 转交控制
    - 获取过程所需的存储资源
    - 执行所需的任务
    - 将结果值放在调用程序可以访问到的位置
    - 将控制返回到调用点
- `x10` - `x17` 用于传递参数和返回值
- `x1` 用于存放返回地址
    - 调用 `jal x1, target` 保存返回地址到 `x1` 并且跳转
    - 返回时使用 `jalr x0, 0(x1)` 跳转回 `x1` 中的地址并且不保存返回地址
- `x5` - `x7`, `x28` - `x31` 用作临时
- `x8` - `x9`, `x18` - `x27` 用作被调用者保存
    - `x8` 也是帧指针, 指向当前栈帧的起始位置
        - 服务于调试 / 溢出检测 / 动态分配
- `x2` 用作栈指针
- `x3` 用作全局指针
    - 指向 data 段中间, 用于快速访问高频数据
    - 编译器会进行相应优化
- `x4` 用作线程指针
    - 指向每个线程的本地存储区
    - 用于多线程程序

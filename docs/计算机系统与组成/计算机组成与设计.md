# 计算机组成与设计

## 参考资料

- 计算机组成与设计: 硬件 / 软件接口 (RISC-V)

## 计算机抽象及相关技术

- 计算机体系结构中的 7 个伟大思想
    - 使用抽象简化设计
    - 加速经常性事件
    - 通过并行提高性能
    - 通过流水线提高性能
    - 通过预测提高性能
    - 存储层次
    - 通过冗余提高可靠性
- 对性能建模
    - 用户 CPU 时间 (CPU 性能), 用户程序运行所需的时间
    - 系统 CPU 时间 (系统性能), 操作系统运行用户程序的相关程序所需的时间
    - CPI, 指令平均时钟周期数
    - CPU 性能 = (指令数 * CPI) / 时钟频率
- 功耗墙
    - 动态功耗: 与 CMOS 开关活动相关的功耗
    - 静态功耗: 与晶体管泄漏电流相关的功耗
    - 功耗 = 0.5 \* 电容 \* 电压 \* 电压 \* 频率 + 静态功耗
- 增加性能就是增加能效
- 低利用率的计算机不一定具有更低功耗

## 指令: 计算机的语言

- 字是 $32$ 位 ($4$ 字节)
- 双字是 $64$ 位 ($8$ 字节)
- 大多有 $32$ 个寄存器 (`x0` - `x31`)
    - $2^30$ 字节内存寻址空间
- 由于常数 $0$ 经常用 (比如求相反数), `x0` 硬连线为 $0$
- 针对有无符号的整数有不同的指令, 原因是补码的拓展方式不同

```riscv
// 算术运算
add x3, x1, x2 // x3 = x1 + x2
sub x3, x1, x2 // x3 = x1 - x2

// 常数会在程序加载时放入内存
lw x1, constant_address // x1 = Memory[constant_address]
add x2, x2, x1 // x2 = x2 + constant

addi x1, x2, 100 // x1 = x2 + 100 立即数
                 // 因为是补码, 所以可以实现减法

// 数据传输
lw x1, 0(x2) // x1 = Memory[x2 + 0] 取字
lwu x1, 0(x2) // x1 = ZeroExtend(Memory[x2 + 0]) 取无符号字
sw x1, 0(x2) // Memory[x2 + 0] = x1 存字
// 半字
lh x1, 0(x2) // x1 = SignExtend(Memory[x2 + 0]) 取半字
lhu x1, 0(x2) // x1 = ZeroExtend(Memory[x2 + 0]) 取无符号半字
sh x1, 0(x2) // Memory[x2 + 0] = LowHalf(x1) 存半字
// 字节
lb x1, 0(x2) // x1 = SignExtend(Memory[x2 + 0]) 取字节
lbu x1, 0(x2) // x1 = ZeroExtend(Memory[x2 + 0]) 取无符号字节
sb x1, 0(x2) // Memory[x2 + 0] = LowByte(x1) 存字节
// CAS
lr.d x2, (x1) // x2 = Memory[x1] 加载并监控是否被修改
sc.d x3, x2, (x1) // if (没被修改) Memory[x1] = x2, x3 = 0; else x3 = 非零数

// 取立即数高位
lui x1, 0x12345 // x1 = 0x12345000 把高 20 位装入寄存器, 低 12 位清零, 原因是一条指令只能装下 20 位立即数

// 逻辑运算
and x3, x1, x2 // x3 = x1 & x2
or x3, x1, x2 // x3 = x1 | x2
xor x3, x1, x2 // x3 = x1 ^ x2
andi x3, x1, 0xFF // x3 = x1 & 0xFF 立即数
ori x3, x1, 0xFF // x3 = x1 | 0xFF 立即数
xori x3, x1, 0xFF // x3 = x1 ^ 0xFF 立即数

// 移位操作
sll x3, x1, x2 // x3 = x1 << (x2 & 0x1F) 逻辑左移
srl x3, x1, x2 // x3 = x1 >> (x2 & 0x1F) 逻辑右移
sra x3, x1, x2 // x3 = x1 >> (x2 & 0x1F) 算术右移
slli x3, x1, 4 // x3 = x1 << 4 逻辑左移 立即数
srli x3, x1, 4 // x3 = x1 >> 4 逻辑右移 立即数
srai x3, x1, 4 // x3 = x1 >> 4 算术右移 立即数

// 条件分支
beq x1, x2, 100 // if (x1 == x2) goto PC + 100
bne x1, x2, 100 // if (x1 != x2) goto PC + 100
blt x1, x2, 100 // if (x1 < x2) goto PC + 100
bge x1, x2, 100 // if (x1 >= x2) goto PC + 100
bltu x1, x2, 100 // if (x1 < x2) goto PC + 100 (无符号)
bgeu x1, x2, 100 // if (x1 >= x2) goto PC + 100 (无符号)

// 无条件跳转
jal x1, 100 // x1 = PC + 4; goto PC + 100 过程调用
jalr x1, 0(x2) // x1 = PC + 4; goto x2 + 0 过程返回
```

### 指令格式

- RISC-V 指令都是 $32$ 位长, 分多类型
- R 型指令 (寄存器 - 寄存器运算)
    - $7$ 位操作码
    - $5$ 位目的操作数寄存器
    - $3$ 位操作码
    - $5$ 位源操作数寄存器
    - $5$ 位源操作数寄存器
    - $7$ 位操作码
- I 型指令 (立即数运算, 载入, 条件分支)
    - $7$ 位操作码
    - $5$ 位目的操作数寄存器
    - $3$ 位操作码
    - $5$ 位源操作数寄存器
    - $12$ 位立即数
- S 型指令 (存储, 立即数表示偏移量)
    - $7$ 位操作码
    - $5$ 位, 低位立即数
    - $3$ 位操作码
    - $5$ 位源操作数寄存器
    - $5$ 位源操作数寄存器
    - $7$ 位, 高位立即数
- B 型指令 (条件分支, 长的跟 S 一样, 立即数乘二表示偏移量)
- U 型指令 (大立即数)
    - $7$ 位操作码
    - $5$ 位目的操作数寄存器
    - $20$ 位立即数
- J 型指令 (无条件跳转, 长的跟 U 一样, 立即数乘二表示偏移量)
- 移位指令通常使用 I 型格式, 但只使用立即数字段的低位
- RISC-V 通过与全 $1$ 的数进行异或来实现按位取反
- 利用无符号比较指令 `bgeu` 可以用一条指令同时检查 $x < 0$ 和 $x \ge y$ (要么是真的越界了, 要么它是一个负数)

### 过程

- 六个步骤
    - 传递参数
    - 转交控制
    - 获取过程所需的存储资源
    - 执行所需的任务
    - 将结果值放在调用程序可以访问到的位置
    - 将控制返回到调用点
- `x10` - `x17` 用于传递参数和返回值
- `x1` 用于存放返回地址
    - 调用 `jal x1, target` 保存返回地址到 `x1` 并且跳转
    - 返回时使用 `jalr x0, 0(x1)` 跳转回 `x1` 中的地址并且不保存返回地址
- `x5` - `x7`, `x28` - `x31` 用作临时
- `x8` - `x9`, `x18` - `x27` 用作被调用者保存
    - `x8` 也是帧指针, 指向当前栈帧的起始位置
        - 服务于调试 / 溢出检测 / 动态分配
- `x2` 用作栈指针
- `x3` 用作全局指针
    - 指向 data 段中间, 用于快速访问高频数据
    - 编译器会进行相应优化
- `x4` 用作线程指针
    - 指向每个线程的本地存储区
    - 用于多线程程序

### 程序的生命周期

- 编译 -> 链接 -> 加载 -> 执行
- 加载器
    - 读取可执行文件首部以确定正文段和数据段的大小
    - 为正文和数据创建足够大的地址空间
    - 将可执行文件中的指令和数据复制到内存中
    - 将主程序的参数复制到栈
    - 初始化处理器寄存器并将栈指针指向第一个空闲位置
    - 跳转到启动例程, 将参数复制到参数寄存器中并调用程序的主例程
    - 当主例程返回时, 启动例程通过 `exit` 系统调用终止程序
- 动态链接优化为延迟过程链接
    - 只有在第一次调用时才链接过程
    - 后续调用直接跳转到已链接的过程 (直接改写全局偏移表 GOT)

### 增补

```riscv
auipc x1, 0x12345 // x1 = PC + 0x12345000 把高 20 位装入寄存器, 低 12 位清零, 原因是一条指令只能装下 20 位立即数

slt x3, x1, x2 // if (x1 < x2) x3 = 1 else x3 = 0 有符号比较
sltu x3, x1, x2 // if (x1 < x2) x3 = 1 else x3 = 0 无符号比较
slti x3, x1, 100 // if (x1 < 100) x3 = 1 else x3 = 0 有符号比较 立即数
sltiu x3, x1, 100 // if (x1 < 100) x3 = 1 else x3 = 0 无符号比较 立即数
```

- RISC-V 支持拓展
    - A - 原子指令拓展, 本质上就之前说的那两个指令
    - M - 整数乘除法拓展
    - F - 单精度浮点数拓展
    - D - 双精度浮点数拓展
    - C - 压缩指令拓展, 16 位指令

## 计算机的算术运算

- 加法的速度取决于向高位进位的计算速度
- 实现乘法
    - 模拟竖式乘法
    - 流水线竖式
    - 分治乘法 + 流水线
- 实现除法
    - 模拟竖式除法 (计算机猜不出来每次能除多少, 只能一点点减)
    - 流水线竖式 + 共用硬件寄存器空间
    - SRT 除法技术试图根据被除数和余数的高位来查找表, 以猜测每步的多个商的位数
- RISC-V 除法指令忽略溢出并不检查除零错误, 由软件处理这些情况
- 浮点数加法
    - 比较指数, 对齐
    - 尾数相加
    - 规格化结果
    - 异常 / 中断
    - 舍入结果
    - 如果舍入后不规格化, 则重复规格化和舍入步骤
- 浮点数乘法
    - 指数相加并减去偏置
    - 尾数相乘
    - 规格化结果
    - 异常 / 中断
    - 舍入结果
    - 如果舍入后不规格化, 则重复规格化和舍入步骤
    - 设置符号
- IEEE 754 在中间计算时, 总是在右边保留额外的位 (保护位, 舍入位) 以提高精度
- 在一个宽字内部进行的并行操作称为子字并行 (数据级并行)
    - SIMD 指令集
    - 适用于整型数据类型的并行执行策略不一定适用于浮点数据类型

## 处理器

- 有效表示信号为逻辑高, 无效表示信号为逻辑低
- 如果状态单元在每个有效时钟边沿都进行写入, 则可忽略写控制信号
- 写控制信号可以解决
    - 输入一个周期准备不好
    - 条件写入
    - 留住当前状态
    - 降低功耗
- 数据存储单元需要一个读信号
    - 因为存在无效地址
- 边沿触发的时钟同步方法
    - 支持状态单元在同一个时钟周期内读和写
    - 在一个时钟周期内不可能出现反馈

### 单周期处理器

- 数据链路
    - 取指
    - 译码, 包括立即数生成单元的工作 (符号拓展)
    - 执行, 同时输出零标识
    - 访存
    - 写回
- 多路选择器
    - ALU 输入源的第二个操作数可能是寄存器或立即数
    - 写回寄存器的数据可能来自 ALU 结果或数据存储器
    - 下一条指令地址可能是 PC+4 或分支目标地址
- 主控制单元: 根据指令的 Opcode 生成所有控制信号
    - RegWrite: 是否写寄存器堆
    - ALUSrc: ALU 第二个输入源 ($0=Reg$, $1=Imm$)
    - MemRead: 读数据存储器
    - MemWrite: 写数据存储器
    - MemtoReg (仅 RegWrite为 $1$ 是有效): 写回寄存器的数据源 ($0=ALU$, $1=Mem$)
    - Branch: 是否是分支指令
    - ALUOp: 传递给 ALU 控制单元的意图
- ALU 控制单元: 根据 ALUOp 和 funct 字段生成实际的 ALU 控制信号
    - ALU 控制信号决定 ALU 执行的具体操作
        - `00`: 加法 (用于算偏移量)
        - `01`: 减法 (用于比较)
        - `10`: 由 funct 字段决定具体操作 (R 型指令)
    - `funct3 & funct7` 决定具体操作
    - 输出 4 位 ALU 控制信号, 驱动 ALU 硬件
- 多周期实现允许每个指令多次使用同一个功能单元, 有助于减少所需的硬件数量

### 流水线处理器

- RISC-V 指令集为何适合流水线
    - 指令长度固定, 在分析指令之前就能取下一条指令
    - 指令格式规整, 在分析指令的同时就能读寄存器
    - 无内存运算指令, EX 阶段只做计算, MEM 阶段只做访存
- RISC-V 指令集相较于 Y86-64 少一个流水线寄存器
    - PC: 存放取指地址
    - IF: 取指
    - IF/ID: 指令
    - ID: 译码 & 读寄存器
    - ID/EX: 寄存器值, 立即数, 控制信号 (目标寄存器号等)
    - EX: 执行计算
    - EX/MEM: 执行和访存之间的寄存器
    - MEM: 访问内存
    - MEM/WB: 访存和写回之间的寄存器
    - WB: 写回寄存器
    - 这些寄存器必须足够大, 能存下所有需要传递到后续阶段的信息 (指令, 数据值, 控制信号等)
- 控制信号还是在 ID 阶段生成, 但不能立刻发送出去
    - 按生效阶段分组 (EX, MEM, WB)
        - EX: `ALUSrc`, `ALUOp`
        - MEM: `MemRead`, `MemWrite`, `Branch`
        - WB: `RegWrite`, `MemtoReg`
    - 把控制信号也放进流水线寄存器里, 随数据一起传递

### 流水线冒险

- 结构冒险
    - 多条指令想同时用同一个硬件
    - 比如取指和访存冲突
    - 采用哈佛架构思想, 指令 Cache 和数据 Cache 分开设计
- 数据冒险
    - 同 CSAPP
    - ALU 的输入端加一个巨大的多路选择器
    - 前递单元负责监控寄存器号, 决定多路选择器选谁
- 控制冒险
    - 同 CSAPP
    - MIPS 常用延迟分支, 编译器负责往分支指令后面的一条指令填一条有用的指令
    - 优化一: 缩短分支延迟
        - 在 ID 阶段增加额外的比较器与前递单元
        - 这样就能在 ID 阶段判断分支是否成立
        - 在 ID 阶段计算目标地址
    - 优化二: 分支预测
        - 基础方案同 CSAPP
        - 但是 IF 阶段还不知道是不是分支指令, 只能猜不跳转 / 到 ID 阶段再猜测
        - 进阶方案: 动态分支预测
            - 选上次的该位置的跳转结果作为本次预测 (以指令地址为索引的小表), 这样就可以在 IF 阶段预测
            - 优化为两位预测器, 连续错两次才改变预测结果

### 例外

- 例外指意外的控制流变化 (通常同步不可屏蔽)
    - 若由处理器外部事件引起, 则称为中断 (通常异步可屏蔽)
    - 如系统重启, 操作系统调用, IO设备请求, 非法指令
    - 其中只有 IO 设备请求是中断
- 当例外发生时
    - 在系统例外程序计数器中保存发生例外的指令的地址
        - 在系统例外原因寄存器中保存例外的原因 (其它体系结构常用向量式中断, 即根据不同的例外类型决定向量表上偏移量)
    - 将控制权转交给操作系统
    - 操作系统自由处理例外
    - 使用系统例外程序计数器, 返回到被中断的程序 / 终止程序
- 流水线中的例外处理
    - 类似于分支预测错误
        - 例外会改变处理器状态
        - 可能还需要跳回来重新执行那条出事的指令
    - 将其后续的指令清除
    - 将 RegWrite 信号置 0, 防止写回
    - 保存现场信息
    - 修改 PC, 跳转到例外处理程序
- RISC-V 保证精确例外
    - 如果指令引发例外, 那么其之前的所有指令都必须完全执行
    - 之后的所有指令都必须完全被丢弃
    - SEPC 必须精准指向引发例外的指令
    - 同时规定多例外同时发生时, 只处理最早发生的那个例外

### 指令级并行

- 流水线本就是一种指令级并行
- 另一种是多发射, 在每个时钟周期内发射多条指令
    - 如果指令发射与否的判断是在编译时完成的, 则称为静态多发射
    - 如果指令发射与否的判断是在运行时由硬件完成的, 则称为动态多发射
- 多发射流水线的主要任务
    - 将指令打包并放入发射槽
    - 处理数据和控制冒险
- 将分支预测的思想推广到其他指令, 称为推测
    - 预测结果正确性的检查机制
    - 预测出错后的恢复机制
    - 消除推测式执行带来的副作用的机制

#### 静态多发射

- 编译器负责打包指令与减少或消除所有的冒险
- 有的体系结构使用超长指令字 (VLIW)
    - 每条指令包含多条并行执行的操作
    - 硬件只负责执行, 不负责冒险检测
    - 需要非常复杂的编译器
- 双发射处理器
    - 嵌入式处理器常用
    - 拓展数据通路以支持每个周期发射两条指令
    - 限制: 每对指令中第一条必须是 ALU/Branch 指令, 第二条必须是 Load/Store 指令 (否则填 `nop`)
- 编译器会用循环展开 + 寄存器重命名来增加指令间的独立性配合多发射
    - 名字相关 / 反相关指指令之间因为使用了相同的寄存器名而产生的虚假依赖
- 静态多发射的缺点
    - 编译器复杂度高
    - 不能适应动态变化的运行时行为

#### 动态多发射 (超标量处理器)

- 动态多发射是与静态多发射相配合使用的, 优势是
    - 不可预测的停顿
    - 分支预测的不确定性
    - 二进制兼容性
- 动态调度处理器的流水线
    - 取指和发射单元
    - 多功能部件与保留站
    - 提交单元
- 取指和发射单元
    - 严格按程序顺序取指
    - 将指令发送到保留站
    - 如果数据已经在寄存器里, 直接拿走
    - 如果数据还没算出来, 记下我在等谁
- 多功能部件与保留站
    - 保留站: 每个功能单元前的小缓冲区
    - 当所有操作数都准备好了且功能单元空闲, 指令就开始执行 (乱序)
    - 指令执行完后, 结果广播到公共数据总线, 供其他保留站抓取
    - 指令结果先放在重排序缓冲里, 等待按序提交
    - 重排序缓冲也起到了寄存器重命名的作用, 消除名字相关
- 提交单元
    - 按程序顺序把 ROB 里的结果写回寄存器或内存
    - 确保发生异常时处理器状态是精确的
- 名字相关
    - 指令之间因为使用了相同的寄存器名而产生的虚假依赖
    - 通过寄存器重命名消除名字相关 (写入 ROB 临时位置而不是物理寄存器)
- 内存队列
    - 所有指令进读 / 写队列, 先计算地址, 再计算依赖
    - 读内存指令必须等到依赖的写内存指令完成后才能执行

## 存储器层次结构

- 同 CSAPP
- Cache 失效时停顿不会全停 (因为有乱序执行)
- 组相联的 LRU 一般使用近似 LRU 算法实现, 以减少硬件复杂度

### 可靠的存储器层次

- 可靠性: 平均无故障时间 / 年度失效率
- 可用性: 平均无故障时间 / (平均无故障时间 + 平均修复时间)
- 设计一种编码, 其中最近码汉明距离为 $d$
    - 能够检测到 $d-1$ 位错误
    - 能够纠正 $\lfloor (d-1)/2 \rfloor$ 位错误
- 所以它在正常编码中增加了奇偶校验位
    - 在检测 $1$ 位错误时非常有效
- 汉明纠错码
    - 增加多个校验位, 每个位检查数据位的不同组合
    - 能够纠正单个位错误, 检测双位错误

### 虚拟机

- 隔离, 简化配置, 易于管理, 屏蔽异构性, 增强安全性
- 允许虚拟机直接在硬件上执行的体系结构被冠以可虚拟化的名称

### 虚拟存储

# 计算机组成与设计

## 参考资料

- 计算机组成与设计: 硬件 / 软件接口 (RISC-V)

## 计算机抽象及相关技术

- 计算机体系结构中的 7 个伟大思想
    - 使用抽象简化设计
    - 加速经常性事件
    - 通过并行提高性能
    - 通过流水线提高性能
    - 通过预测提高性能
    - 存储层次
    - 通过冗余提高可靠性
- 对性能建模
    - 用户 CPU 时间 (CPU 性能), 用户程序运行所需的时间
    - 系统 CPU 时间 (系统性能), 操作系统运行用户程序的相关程序所需的时间
    - CPI, 指令平均时钟周期数
    - CPU 性能 = (指令数 * CPI) / 时钟频率
- 功耗墙
    - 动态功耗: 与 CMOS 开关活动相关的功耗
    - 静态功耗: 与晶体管泄漏电流相关的功耗
    - 功耗 = 0.5 *电容* 电压 *电压* 频率 + 静态功耗
- 增加性能就是增加能效
- 低利用率的计算机不一定具有更低功耗

## 指令: 计算机的语言

- 字是 $32$ 位 ($4$ 字节)
- 双字是 $64$ 位 ($8$ 字节)
- 大多有 $32$ 个寄存器 (`x0` - `x31`)
    - $2^30$ 字节内存寻址空间
- 由于常数 $0$ 经常用 (比如求相反数), `x0` 硬连线为 $0$
- 针对有无符号的整数有不同的指令, 原因是补码的拓展方式不同

```riscv
// 算术运算
add x3, x1, x2 // x3 = x1 + x2
sub x3, x1, x2 // x3 = x1 - x2

// 常数会在程序加载时放入内存
lw x1, constant_address // x1 = Memory[constant_address]
add x2, x2, x1 // x2 = x2 + constant

addi x1, x2, 100 // x1 = x2 + 100 立即数
                 // 因为是补码, 所以可以实现减法

// 数据传输
lw x1, 0(x2) // x1 = Memory[x2 + 0] 取字
lwu x1, 0(x2) // x1 = ZeroExtend(Memory[x2 + 0]) 取无符号字
sw x1, 0(x2) // Memory[x2 + 0] = x1 存字
// 半字
lh x1, 0(x2) // x1 = SignExtend(Memory[x2 + 0]) 取半字
lhu x1, 0(x2) // x1 = ZeroExtend(Memory[x2 + 0]) 取无符号半字
sh x1, 0(x2) // Memory[x2 + 0] = LowHalf(x1) 存半字
// 字节
lb x1, 0(x2) // x1 = SignExtend(Memory[x2 + 0]) 取字节
lbu x1, 0(x2) // x1 = ZeroExtend(Memory[x2 + 0]) 取无符号字节
sb x1, 0(x2) // Memory[x2 + 0] = LowByte(x1) 存字节
// CAS
lr.d x2, (x1) // x2 = Memory[x1] 加载并监控是否被修改
sc.d x3, x2, (x1) // if (没被修改) Memory[x1] = x2, x3 = 0; else x3 = 非零数

// 取立即数高位
lui x1, 0x12345 // x1 = 0x12345000 把高 20 位装入寄存器, 低 12 位清零, 原因是一条指令只能装下 20 位立即数

// 逻辑运算
and x3, x1, x2 // x3 = x1 & x2
or x3, x1, x2 // x3 = x1 | x2
xor x3, x1, x2 // x3 = x1 ^ x2
andi x3, x1, 0xFF // x3 = x1 & 0xFF 立即数
ori x3, x1, 0xFF // x3 = x1 | 0xFF 立即数
xori x3, x1, 0xFF // x3 = x1 ^ 0xFF 立即数

// 移位操作
sll x3, x1, x2 // x3 = x1 << (x2 & 0x1F) 逻辑左移
srl x3, x1, x2 // x3 = x1 >> (x2 & 0x1F) 逻辑右移
sra x3, x1, x2 // x3 = x1 >> (x2 & 0x1F) 算术右移
slli x3, x1, 4 // x3 = x1 << 4 逻辑左移 立即数
srli x3, x1, 4 // x3 = x1 >> 4 逻辑右移 立即数
srai x3, x1, 4 // x3 = x1 >> 4 算术右移 立即数

// 条件分支
beq x1, x2, 100 // if (x1 == x2) goto PC + 100
bne x1, x2, 100 // if (x1 != x2) goto PC + 100
blt x1, x2, 100 // if (x1 < x2) goto PC + 100
bge x1, x2, 100 // if (x1 >= x2) goto PC + 100
bltu x1, x2, 100 // if (x1 < x2) goto PC + 100 (无符号)
bgeu x1, x2, 100 // if (x1 >= x2) goto PC + 100 (无符号)

// 无条件跳转
jal x1, 100 // x1 = PC + 4; goto PC + 100 过程调用
jalr x1, 0(x2) // x1 = PC + 4; goto x2 + 0 过程返回
```

### 指令格式

- RISC-V 指令都是 $32$ 位长, 分多类型
- R 型指令 (寄存器 - 寄存器运算)
    - $7$ 位操作码
    - $5$ 位目的操作数寄存器
    - $3$ 位操作码
    - $5$ 位源操作数寄存器
    - $5$ 位源操作数寄存器
    - $7$ 位操作码
- I 型指令 (立即数运算, 载入, 条件分支)
    - $7$ 位操作码
    - $5$ 位目的操作数寄存器
    - $3$ 位操作码
    - $5$ 位源操作数寄存器
    - $12$ 位立即数
- S 型指令 (存储, 立即数表示偏移量)
    - $7$ 位操作码
    - $5$ 位, 低位立即数
    - $3$ 位操作码
    - $5$ 位源操作数寄存器
    - $5$ 位源操作数寄存器
    - $7$ 位, 高位立即数
- B 型指令 (条件分支, 长的跟 S 一样, 立即数乘二表示偏移量)
- U 型指令 (大立即数)
    - $7$ 位操作码
    - $5$ 位目的操作数寄存器
    - $20$ 位立即数
- J 型指令 (无条件跳转, 长的跟 U 一样, 立即数乘二表示偏移量)
- 移位指令通常使用 I 型格式, 但只使用立即数字段的低位
- RISC-V 通过与全 $1$ 的数进行异或来实现按位取反
- 利用无符号比较指令 `bgeu` 可以用一条指令同时检查 $x < 0$ 和 $x \ge y$ (要么是真的越界了, 要么它是一个负数)

### 过程

- 六个步骤
    - 传递参数
    - 转交控制
    - 获取过程所需的存储资源
    - 执行所需的任务
    - 将结果值放在调用程序可以访问到的位置
    - 将控制返回到调用点
- `x10` - `x17` 用于传递参数和返回值
- `x1` 用于存放返回地址
    - 调用 `jal x1, target` 保存返回地址到 `x1` 并且跳转
    - 返回时使用 `jalr x0, 0(x1)` 跳转回 `x1` 中的地址并且不保存返回地址
- `x5` - `x7`, `x28` - `x31` 用作临时
- `x8` - `x9`, `x18` - `x27` 用作被调用者保存
    - `x8` 也是帧指针, 指向当前栈帧的起始位置
        - 服务于调试 / 溢出检测 / 动态分配
- `x2` 用作栈指针
- `x3` 用作全局指针
    - 指向 data 段中间, 用于快速访问高频数据
    - 编译器会进行相应优化
- `x4` 用作线程指针
    - 指向每个线程的本地存储区
    - 用于多线程程序

### 程序的生命周期

- 编译 -> 链接 -> 加载 -> 执行
- 加载器
    - 读取可执行文件首部以确定正文段和数据段的大小
    - 为正文和数据创建足够大的地址空间
    - 将可执行文件中的指令和数据复制到内存中
    - 将主程序的参数复制到栈
    - 初始化处理器寄存器并将栈指针指向第一个空闲位置
    - 跳转到启动例程, 将参数复制到参数寄存器中并调用程序的主例程
    - 当主例程返回时, 启动例程通过 `exit` 系统调用终止程序
- 动态链接优化为延迟过程链接
    - 只有在第一次调用时才链接过程
    - 后续调用直接跳转到已链接的过程 (直接改写全局偏移表 GOT)

### 增补

```riscv
auipc x1, 0x12345 // x1 = PC + 0x12345000 把高 20 位装入寄存器, 低 12 位清零, 原因是一条指令只能装下 20 位立即数

slt x3, x1, x2 // if (x1 < x2) x3 = 1 else x3 = 0 有符号比较
sltu x3, x1, x2 // if (x1 < x2) x3 = 1 else x3 = 0 无符号比较
slti x3, x1, 100 // if (x1 < 100) x3 = 1 else x3 = 0 有符号比较 立即数
sltiu x3, x1, 100 // if (x1 < 100) x3 = 1 else x3 = 0 无符号比较 立即数
```

- RISC-V 支持拓展
    - A - 原子指令拓展, 本质上就之前说的那两个指令
    - M - 整数乘除法拓展
    - F - 单精度浮点数拓展
    - D - 双精度浮点数拓展
    - C - 压缩指令拓展, 16 位指令

## 计算机的算术运算

- 加法的速度取决于向高位进位的计算速度
- 实现乘法
    - 模拟竖式乘法
    - 流水线竖式
    - 分治乘法 + 流水线
- 实现除法
    - 模拟竖式除法 (计算机猜不出来每次能除多少, 只能一点点减)
    - 流水线竖式 + 共用硬件寄存器空间
    - SRT 除法技术试图根据被除数和余数的高位来查找表, 以猜测每步的多个商的位数
- RISC-V 除法指令忽略溢出并不检查除零错误, 由软件处理这些情况
- 浮点数加法
    - 比较指数, 对齐
    - 尾数相加
    - 规格化结果
    - 异常 / 中断
    - 舍入结果
    - 如果舍入后不规格化, 则重复规格化和舍入步骤
- 浮点数乘法
    - 指数相加并减去偏置
    - 尾数相乘
    - 规格化结果
    - 异常 / 中断
    - 舍入结果
    - 如果舍入后不规格化, 则重复规格化和舍入步骤
    - 设置符号
- IEEE 754 在中间计算时, 总是在右边保留额外的位 (保护位, 舍入位) 以提高精度
- 在一个宽字内部进行的并行操作称为子字并行 (数据级并行)
    - SIMD 指令集
    - 适用于整型数据类型的并行执行策略不一定适用于浮点数据类型

## 处理器

- 有效表示信号为逻辑高, 无效表示信号为逻辑低
- 如果状态单元在每个有效时钟边沿都进行写入, 则可忽略写控制信号
- 写控制信号可以解决
    - 输入一个周期准备不好
    - 条件写入
    - 留住当前状态
    - 降低功耗
- 数据存储单元需要一个读信号
    - 因为存在无效地址
- 边沿触发的时钟同步方法
    - 支持状态单元在同一个时钟周期内读和写
    - 在一个时钟周期内不可能出现反馈

### 单周期处理器

- 数据链路
    - 取指
    - 译码, 包括立即数生成单元的工作 (符号拓展)
    - 执行, 同时输出零标识
    - 访存
    - 写回
- 多路选择器
    - ALU 输入源的第二个操作数可能是寄存器或立即数
    - 写回寄存器的数据可能来自 ALU 结果或数据存储器
    - 下一条指令地址可能是 PC+4 或分支目标地址
- 主控制单元: 根据指令的 Opcode 生成所有控制信号
    - RegWrite: 是否写寄存器堆
    - ALUSrc: ALU 第二个输入源 ($0=Reg$, $1=Imm$)
    - MemRead: 读数据存储器
    - MemWrite: 写数据存储器
    - MemtoReg (仅 RegWrite为 $1$ 是有效): 写回寄存器的数据源 ($0=ALU$, $1=Mem$)
    - Branch: 是否是分支指令
    - ALUOp: 传递给 ALU 控制单元的意图
- ALU 控制单元: 根据 ALUOp 和 funct 字段生成实际的 ALU 控制信号
    - ALU 控制信号决定 ALU 执行的具体操作
        - `00`: 加法 (用于算偏移量)
        - `01`: 减法 (用于比较)
        - `10`: 由 funct 字段决定具体操作 (R 型指令)
    - `funct3 & funct7` 决定具体操作
    - 输出 4 位 ALU 控制信号, 驱动 ALU 硬件
- 多周期实现允许每个指令多次使用同一个功能单元, 有助于减少所需的硬件数量

### 流水线处理器

- RISC-V 的五级流水线
    - IF: 取指
    - ID: 译码 & 读寄存器
    - EX: 执行计算
    - MEM: 访问内存
    - WB: 写回寄存器
- RISC-V 指令集为何适合流水线
    - 指令长度固定, 在分析指令之前就能取下一条指令
    - 指令格式规整, 在分析指令的同时就能读寄存器
    - 无内存运算指令, EX 阶段只做计算, MEM 阶段只做访存

### 流水线冒险

- 结构冒险
    - 多条指令想同时用同一个硬件
    - 比如取指和访存冲突
    - 采用哈佛架构思想, 指令 Cache 和数据 Cache 分开设计
- 数据冒险
    - 同 CSAPP
- 控制冒险
    - 同 CSAPP
    - MIPS 常用延迟分支, 编译器负责往分支指令后面的一条指令填一条有用的指令
